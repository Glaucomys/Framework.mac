
Skip to content

    Pull requests
    Issues
    Marketplace
    Explore

    @Glaucomys

0
0

    1

Glaucomys/Framework.mac
Code
Issues 0
Pull requests 0
Projects 1
Wiki
Insights
Settings
Framework.mac/FRAMEWORK.mac
1554281 3 days ago
@Glaucomys Glaucomys Add files via upload
10248 lines (10171 sloc) 595 KB
| - kiss11.mac v11.001 by Maskoi 01/04/2019
| - Contributions by anonymoushero, crystane, eqmule, thenomadman, william12, kaeno1.
| - ChainPull, Debuffs and combat rewrites by ctaylor22.
| - PetTank, PullerPetTank & HunterPetTank roles developed by TreeHuginDruid
| - KISS Assist - A simple multi class macro
| Requires plugins* MQ2Cast, MQ2Exchange, MQ2Melee, MQ2MoveUtils, MQ2Posse, MQ2Rez, & MQ2Twist (Bards), MQ2Gmail, Extended Target Window and ninjadvloot.inc file.
| Usage - /mac kissassist assist TankName 95
| or target Main Tank and /mac kissassist assist
| This macro was written exclusively for subscribers of Redguides.com
| -------------------------------------------------------------------------------------
#warning
#turbo 120
<<<<<<< HEAD
=======
#warning
#turbo 120

#include framework\quests.inc
#include framework\ninjadvloot.inc
#include framework\Raid.inc
#include framework\common.inc
#include framework\ber.inc
#include framework\brd.inc
#include framework\bst.inc
#include framework\clr.inc
#include framework\dru.inc
#include framework\enc.inc
#include framework\mag.inc
#include framework\mnk.inc
#include framework\nec.inc
#include framework\pal.inc
#include framework\rng.inc
#include framework\rog.inc
#include framework\shd.inc
#include framework\shm.inc
#include framework\war.inc
#include framework\wiz.inc
#include framework\Manual.inc
|#DEFINE /squelch " "

#define AMIDEAD "/if (${watch_for_death[]}) /varset IAmDead 1"
#define DEADEXIT "/if (${Select[${Me.State},DEAD,FEIGN,STUN,BIND]} || ${IAmDead}) /return"
#define MOBINCAMP "/if (${Me.XTarget[1].ID} && ${SpawnCount[npc radius ${MeleeDistance} zradius 15 targetable playerstate 4]}) /return"

|/echo MezImmune: ${Ini[${InfoFileName},${ZoneName},MezImmune].Find[${MyTargetName}]}
|        /echo MobsToPull: ${Ini[${InfoFileName},${ZoneName},MobsTopull].Find[${MyTargetName}]}
|        /echo MobsToIgnore: ${Ini[${InfoFileName},${ZoneName},MobsToIgnore].Find[${MyTargetName}]}
|        /echo MobsToBurn: ${Ini[${InfoFileName},${ZoneName},MobsToBurn].Find[${MyTargetName}]}
| /varset targetannouncerID ${Spawn[id ${Target.ID}].TargetOfTarget.ID}
| /varset MyTargetID ${Spawn[id ${AnnouncerID}].TargetOfTarget.ID}

| ------------------------------casting events ----------------------------------------
#Event CAST_BEGIN                  "You begin casting#*#"
#Event CAST_BEGIN                  "You begin singing#*#"
#Event CAST_BEGIN                  "Your #1# begins to glow."
#Event CAST_COLLAPSE               "Your gate is too unstable, and collapses#*#"
#Event CAST_CANNOTSEE              "You cannot see your target#*#"
#Event CAST_COMPONENTS             "You are missing some required components#*#"
#Event CAST_COMPONENTS             "Your ability to use this item has been disabled because you do not have at least a gold membership#*#"
#Event CAST_DISTRACTED             "You need to play a#*#instrument for this song#*#"
#Event CAST_DISTRACTED             "You are too distracted to cast a spell now#*#"
#Event CAST_DISTRACTED             "You can't cast spells while invulnerable#*#"
#Event CAST_DISTRACTED             "You *CANNOT* cast spells, you have been silenced#*#"
#Event CAST_FDFAIL                 "#1# has fallen to the ground.#*#" 
#Event CAST_FIZZLE                 "Your spell fizzles#*#"
#Event CAST_FIZZLE                 "You miss a note, bringing your song to a close#*#"
#Event CAST_IMMUNE                 "Your target has no mana to affect#*#"
#Event CAST_IMMUNE                 "Your target is immune to changes in its attack speed#*#"
#Event CAST_IMMUNE                 "Your target is immune to changes in its run speed#*#"
#Event CAST_IMMUNE                 "Your target is immune to snare spells#*#"
#Event CAST_IMMUNE                 "Your target is immune to the stun portion of this effect#*#"
#Event CAST_IMMUNE                 "Your target cannot be mesmerized#*#"
#Event CAST_IMMUNE                 "Your target looks unaffected#*#"
#Event CAST_INTERRUPTED            "Your spell is interrupted#*#"
#Event CAST_INTERRUPTED            "Your casting has been interrupted#*#"
#Event CAST_NOMOUNT                "You can only summon a mount on dry land#*#"
#Event CAST_NOMOUNT                "You need to be in a more open area to summon a mount#*#"
#Event CAST_NOMOUNT                "You can not summon a mount here#*#"
#Event CAST_NOMOUNT                "You must have both the Horse Models and your current Luclin Character Model enabled to summon a mount#*#"
#Event CAST_NOTARGET               "You must first select a target for this spell#*#"
#Event CAST_NOTARGET               "This spell only works on#*#"
#Event CAST_NOTARGET               "You must first target a group member#*#"
#Event CAST_NOTREADY               "Spell recast time not yet met#*#"
#Event CAST_OUTOFMANA              "Insufficient Mana to cast this spell#*#"
#Event CAST_OUTOFRANGE             "Your target is out of range, get closer#*#"
#Event CAST_OUTDOORS               "This spell does not work here#*#"
#Event CAST_OUTDOORS               "You can only cast this spell in the outdoors#*#"
#Event CAST_RECOVER                "You haven't recovered yet#*#"
#Event CAST_RECOVER                "Spell recovery time not yet met#*#"
#Event CAST_RESISTED               "Your target resisted the #1# spell#*#"
#Event CAST_RESISTEDYOU            "You resist the #1# spell#*#"
#Event CAST_STANDING               "You must be standing to cast a spell#*#"
#Event CAST_STUNNED                "You can't cast spells while stunned#*#"
#Event CAST_STUNNED                "You are stunned#*#" 
#Event CAST_SUCCESS                "You are already on a mount#*#"
#Event CAST_TAKEHOLD               "Your spell did not take hold#*#"
#Event CAST_TAKEHOLD               "Your spell would not have taken hold#*#"
#Event CAST_TAKEHOLD               "Your spell is too powerfull for your intended target#*#"
#Event CAST_TAKEHOLD               "This pet may not be made invisible#*#"
|****************************************| GENERAL EVENTS |***********************************************|
#Event Camping           "#*#seconds to prepare your camp."
#Event EQBCIRC           "<#1#> #2#"
#Event FSEQBC            "#1# tells the fellowship, #2#"
#Event GUEQBC            "#1# tells the guild, #2#"
#Event GainSomething     "#*#You have gained|#1#|"
#Event GotHit            "#1# bashes YOU for #*# points of damage.#*#"
#Event GotHit            "#1# bites YOU for #*# points of damage.#*#"
#Event GotHit            "#1# crushes YOU for #*# points of damage.#*#"
#Event GotHit            "#1# gores YOU for #*# points of damage.#*#"
#Event GotHit            "#1# hits YOU for #*# points of damage.#*#"
#Event GotHit            "#1# kicks YOU for #*# points of damage.#*#"
#Event GotHit            "#1# mauls YOU for #*# points of damage.#*#"
#Event GotHit            "#1# pierces YOU for #*# points of damage.#*#"
#Event GotHit            "#1# punches YOU for #*# points of damage.#*#"
#Event GotHit            "#1# rampages YOU for #*# points of damage.#*#" 
#Event GotHit            "#1# smashes YOU for #*# points of damage.#*#"
#Event GotHit            "#1# slashes YOU for #*# points of damage.#*#"
#Event GotHit            "#1# tries to #*# YOU, but #*#"
#Event Invised           "You Vanish #*#"
#Event Joined            "#1# has joined the group."
#Event KTDismount        "[MQ2] KTDismount#*#"
#Event KTDoorClick       "[MQ2] KTDoorClick #1#"
#Event KTDoorClick       "[MQ2] KTDoorClick#*#"
#Event KTHail            "[MQ2] KTHail #1#"
#Event KTInvite          "[MQ2] KTInvite #1#"
#Event KTSay             "[MQ2] KTSay #1#"
#Event KTTarget          "[MQ2] KTTarget #1#"
#Event LeftGroup         "#1# has left the group."
#Event MezBroke          "#1# has been awakened by #2#."
#Event Missing           "#*#You are missing some required components.#*#"
#Event Missing           "#*#You are missing#*#"
#Event PTaunt            "#*#Taunting attackers as normal, Master.#*#"
#Event PetSusStateAdd1   "#*# tells you, 'By your command, master.#*#"
#Event PetSusStateAdd2   "#*#You cannot have more than one pet at a time.#*#"    
#Event PetSusStateSub    "#*# tells you, 'I live again...'#*#"
#Event PetToysPlease     "#*#PetToysPlease #1#"
#Event TaskUpdate        "Your task |#1#| has been updated#*#"
#Event Timer             Timer1
#Event TwistOn           "#*#Starting Twist11."
#Event TwistOff          "#*#Stopping Twist11"
#Event TooSteep          "The ground here is too steep to camp"  
#Event WornOff           "Your #1# spell has worn off of #2#."
#Event YouGotTell        "#1# tells you, #2#"
#Event Zoned             "LOADING, PLEASE WAIT#*#"
#Event Zoned             "You have entered#*#"
|****************************************| COMBAT EVENTS |***********************************************|
#event TargetCalled       "<#1#>#*#TANKING-> #*# <- ID:#2#"
| #Event Burn              "[MQ2] |${BurnText}|"
#Event AttackCalled      "<#1#>#*#TANKING-> #*# <- ID:#2#"
#Event CantHit           "You can't hit them from here."
#Event CantSee           "You cannot see your target."
#Event GoMOff            "The gift of magic fades."
#Event GoMOff            "Your#*#gift of#*#mana fades."
#Event GoMOn             "#*#granted#*#gift of#*#mana#*#"
#Event GoMOn             "You feel strengthened by a gift of magic."
#Event GoMOn             "You feel strengthened by magic."
#Event ImDead            "#*#Returning to Bind Location#*#"
#Event ImDead            "You died."
#Event ImDead            "You have been slain by#*#"
#Event TooClose          "Your target is too close to use a ranged weapon!"
#Event TooFar            "Your target is too far away, get closer!"
|#Event YouHit            "|${Me}| #1# #2# for #3# points of non-melee damage."
|#Event YouHit            "#1# has taken #2# damage from your #3#."
|#Event YouHit            "You #1# #2# for #3# points of damage."
|#Event YouHit            "|${Me}| #1# #2# for #3# points of non-melee damage.#4#"
|#Event YouHit            "#2# has taken #3# damage from your #1#.#4#"
|#Event YouHit            "You #1# #2# for #3# points of damage.#4#"   
|#Event YouHit            "You try to #*#, but miss"
|#Event YourPetHit        "|${Me.Pet.CleanName}| #1# #2# for #3# points of damage.#4#"
|#Event YourPetHit        "|${Me.Pet.CleanName}| #1# #2# for #3# points of non-melee damage.#4#"
|#Event YourPetHit        "|${Me}|`s pet #1# #2# for #3# points of damage.#4#"
|#Event YourPetHit        "|${Me}|`s pet #1# #2# for #3# points of non-melee damage.#4#"
|#Event YourPetHit        "|${Me}|`s warder #1# #2# for #3# points of damage.#4#"
|#Event YourPetHit        "|${Me}|`s warder #1# #2# for #3# points of non-melee damage.#4#"
|****************************************| Alliances |***********************************************|
#Event BerAlli         "#1# is targeted by a demolisher's alliance."
#Event BerAlliFulm		"The demolisher's alliance is fulfilled!"
#Event BerAlliFulm		"#*#demolisher's alliance is fulfilled!"
|****************************************| MANUAL EVENTS |***********************************************|
#event oorange "Your target is too far away, get closer!"
#event expp "You gain party experience!!" 
#event exp "You gain experience!!"
#event epic "You hear a dark voice in your mind."
#event mortalcoil "You harvest energy from your slain opponent."
#event selftarget "Try attacking someone other than yourself, it's more productive."
#event cannotsee "You cannot see your target."
#event skintick "Your skin loses feeling."
#event skinreset "Your skin festers with a foul disease."
#event swarmover "[MQ2] nomorepewpew"
#event Loot "[MQ2] loot time"

| -------------------------------------------------------------------------------------
| New Binds to replace old Events
| -------------------------------------------------------------------------------------
#bind AddAFriend     /addfriend
#bind AddMezImmune   /addimmune
#bind AddToIgnore    /addignore
#bind AddToPull      /addpull
#bind BackOff        /backoff
#bind BuffGroup      /buffgroup
#bind Burn           /burn
#bind Campfire       /campfire
#bind ChangeVarInt   /changevarint
#bind ChaseMe        /chaseme
#bind DebugAll       /debugall
#bind IniWrite       /iniwrite
#bind KissCheck      /kisscheck
#bind KissE          /kissedit
#bind MakeCampHere   /makecamphere
#bind MemMySpells    /memmyspells
#bind Parse          /parse
#bind SetPullArc     /SetPullArc
#bind StayHere       /stayhere
#bind Switch         /switchnow
#bind SwitchMA       /switchma
#bind ToggleVariable /togglevariable
#bind TrackMeDown    /trackmedown
#bind WriteMySpells  /writespells
#bind ZoneInfo       /zoneinfo
#bind combatreset       /combatreset
| -------------------------------------------------------------------------------------
| Sub Main
| -------------------------------------------------------------------------------------
Sub Main
    /doevents flush
    | Define debug variables before everything else
    /declare Debug                  int         outer       0
    /declare DebugAllOn             int         outer       0
    /declare DebugBuffs             int         outer       0
    /declare DebugCast              int         outer       0
    /declare DebugCombat            int         outer       0
    /declare DebugHeal              int         outer       0
    /declare DebugMez               int         outer       0
    /declare DebugMove              int         outer       0
    /declare DebugPet               int         outer       0
    /declare DebugPull              int         outer       0
    /declare DebugRK                int         outer       0
	/declare DebugFramework         int         outer       0
	/declare DebugMacroFlow         int         outer       0
	/declare MacroFlow              string      outer       Main
    /declare CampXLoc               int         outer       ${Me.X}
    /declare CampYLoc               int         outer       ${Me.Y}
    /declare CampZLoc               int         outer       ${Me.Z}
    /declare CampZone               int         outer       ${Zone.ID}
    /declare LookForward            int         outer       ${Me.Heading.DegreesCCW}
    /declare LoadFromINI            int         outer       0
    | Need to check for plugin MQ2Bucles and unload it. Do this ASAP so can use /while commands from the start
    /if (${Bool[${Plugin[MQ2Bucles]}]}) {
        /squelch /plugin MQ2Bucles unload noauto
        /echo MQ2Bucles detected! This macro doesn't like it! Unloading ...
    }
	/if (${Bool[${Plugin[MQ2Melee]}]}) {
        /squelch /plugin MQ2Melee unload
        /echo MQ2Melee detected! This plugin is the devil! Unloading ... PM me if you insist!
    }
    | ini file fix for zones with commas in them
    /declare ZoneName string outer ${Zone}${If[${Me.InInstance},_I,]}
    /if (${ZoneName.Find[,]} || ${ZoneName.Find[']} ) {
        /echo ${ZoneName} has a comma or apostrophe in the name, setting Zone Short Name ...
        /varset ZoneName ${Zone.ShortName}${If[${Me.InInstance},_I,]}
    }
	
	/declare IniLevel            int      outer
	/declare XPac                string      outer       Basic
	/if (${Me.Level}>=110) {
		/varset IniLevel 110
		/if (${Me.HaveExpansion[25]}) {
			/varset XPac TBL
		} else {
			/varset XPac ROS
		}
	} else /if (${Me.Level} >= 105) {
		/varset IniLevel 105
		/if (${Me.HaveExpansion[23]}) {
			/varset XPac EOK
		} else /if (${Me.HaveExpansion[22]}) {
			/varset XPac TBM
		} else {
			/varset XPac TDS
		}
	} else /if (${Me.Level}>=100) {
		/varset IniLevel 100
		/if (${Me.HaveExpansion[20]}) {
			/varset XPac COTF
		} else {
			/varset XPac ROF
		}
	} else /if (${Me.Level}>=95) {
		/varset IniLevel 95
		/varset XPac VOA
	} else /if (${Me.Level}>=90) {
		/varset IniLevel 90
		/varset XPac HOT
	} else /if (${Me.Level}>=85) {
		/varset IniLevel 85
		/if (${Me.HaveExpansion[16]}) {
			/varset XPac UF
		} else {
			/varset XPac SOD
		}
	} else /if (${Me.Level}>=80) {
		/varset IniLevel 80
		/varset XPac SOF
	} else /if (${Me.Level}>=75) {
		/varset IniLevel 75
		/if (${Me.HaveExpansion[13]}) {
			/varset XPac TBS
		} else {
			/varset XPac TSS
		}
	} else /if (${Me.Level}>=70) {
		/varset IniLevel 70
		/if (${Me.HaveExpansion[11]}) {
			/varset XPac POR
		} else /if (${Me.HaveExpansion[10]}) {
			/varset XPac DOD
		} else /if (${Me.HaveExpansion[9]}) {
			/varset XPac DON
		} else {
			/varset XPac OOW
		}
	} else /if (${Me.Level}>=65) {
		/varset IniLevel 65
		/if (${Me.HaveExpansion[7]}) {
			/varset XPac GOD
		} else /if (${Me.HaveExpansion[6]}) {
			/varset XPac LDON
		} else /if (${Me.HaveExpansion[5]}) {
			/varset XPac TLOY
		} else {
			/varset XPac TPOP
		}
	} else /if (${Me.Level}>=60) {
		/varset IniLevel 60
		/if (${Me.HaveExpansion[3]}) {
			/varset XPac TSOL
		} else /if (${Me.HaveExpansion[2]}) {
			/varset XPac TSOV
		} else {
			/varset XPac TROK
		} 
	} else /if (${Me.Level}>=55) {
		/varset IniLevel 55
	} else /if (${Me.Level}>=50) {
		/varset IniLevel 50
	} else /if (${Me.Level}>=45) {
		/varset IniLevel 45
	} else /if (${Me.Level}>=40) {
		/varset IniLevel 40
	} else /if (${Me.Level}>=35) {
		/varset IniLevel 35
	} else /if (${Me.Level}>=30) {
		/varset IniLevel 30
	} else /if (${Me.Level}>=25) {
		/varset IniLevel 25
	} else /if (${Me.Level}>=20) {
		/varset IniLevel 20
	} else /if (${Me.Level}>=10) {
		/varset IniLevel 10
	} else /if (${Me.Level}>=5) {
		/varset IniLevel 5
	}
	
    /declare MacroName              string      outer       Framework
    /declare MacroVer               string      outer       2.00
	/declare IniFileName            string      outer       framework/${MacroName}_${Me.Class.ShortName}_${IniLevel}_${XPac}.ini         
    /declare InfoFileName           string      outer       framework/${MacroName}_Info.ini
	/declare BuffFileName           string      outer       framework/${MacroName}_Buffs.ini
    /declare PIniSet                int         outer       0
    /declare pi                     int         local       0
    /declare NumParams              int         local       0
    /declare GoMTimer               timer       outer       0
    | Check for command line variables
    /if (${Macro.Params}) {
        /echo There is ${Macro.Params} command line parameter(s)
        /varset NumParams ${Math.Calc[${Macro.Params}-1]}
        /for pi 0 to ${NumParams}
            /if (${Defined[Param${pi}]}) {
                /echo P${pi}: ${Param${pi}}
                /declare PParam${pi} string outer ${Param${pi}}
            }
        /next pi
        /call PParse 0 ${NumParams}
    }
    | if Kiss finds a Kissassist_ServerName_ToonName.ini file it will use that one

    /declare KissAssistVer          string      outer       ${Ini[${IniFileName},General,KissAssistVer]}
    /if (${Debug}) /echo ${IniFileName} ${KissAssistVer} \agLine#: ${Macro.CurLine}
    /if (!${Ini[${IniFileName},General,KissAssistVer].Length}) /ini "${IniFileName}" "General" "KissAssistVer" "0.0"
| ************************* Aliases **************************************|
    /if (${Debug}) /echo \atDEBUG Ini/Alias info ${KissAssistVer.NotEqual[${MacroVer}]} "${KissAssistVer}" "${MacroVer}" \agLine#: ${Macro.CurLine}
    /if (${KissAssistVer.NotEqual[${MacroVer}]}) {
        /echo Version Mismatch Detected, Writing Aliases this can take up to 1 min
        /squelch /alias /afktoolson     /changevarint AFKTools AFKToolsOn
        /squelch /alias /assistat       /changevarint Melee AssistAt
        /squelch /alias /autofireon     /togglevariable AutoFireOn
        /squelch /alias /autorezon      /togglevariable AutoRezOn
        /squelch /alias /buffson        /togglevariable BuffsOn
        /squelch /alias /camphere       /togglevariable ReturnToCamp
        /squelch /alias /campradius     /changevarint General CampRadius
        /squelch /alias /chase          /togglevariable ChaseAssist
        /squelch /alias /chasedistance  /changevarint General ChaseDistance
        /squelch /alias /chaseoff       /changevarint General ChaseAssist 0        
        /squelch /alias /chaseon        /changevarint General ChaseAssist 1 
        /squelch /alias /debug          /togglevariable Debug
        /squelch /alias /debugbuffs     /togglevariable DebugBuffs
        /squelch /alias /debugcombat    /togglevariable DebugCombat
        /squelch /alias /debugcast      /togglevariable DebugCast
        /squelch /alias /debugheal      /togglevariable DebugHeal
        /squelch /alias /debugmez       /togglevariable DebugMez
        /squelch /alias /debugmove      /togglevariable DebugMove
        /squelch /alias /debugpull      /togglevariable DebugPull
        /squelch /alias /debugrk        /togglevariable DebugRK
		/squelch /alias /debugfw        /togglevariable DebugFramework
        /squelch /alias /dpsinterval    /changevarint DPS DPSInterval
        /squelch /alias /dpsmeter       /togglevariable DPSMeter
        /squelch /alias /dpson          /changevarint DPS DPSOn
        /squelch /alias /dpsskip        /changevarint DPS DPSSkip
        /squelch /alias /dpsspam        /togglevariable DPSSpam
        /squelch /alias /dpswrite       /togglevariable DPSWriteOn
        /squelch /alias /healson        /changevarint Heals HealsOn   
        /squelch /alias /interrupton    /togglevariable CastingInterruptOn
        /squelch /alias /ktdismount     /echo KTDismount
        /squelch /alias /ktdoor         /echo KTDoorClick        
        /squelch /alias /kthail         /echo KTHail
        /squelch /alias /ktinvite       /echo KTInvite
        /squelch /alias /ktsay          /echo KTSay
        /squelch /alias /kttarget       /echo KTTarget  
        /squelch /alias /looton         /changevarint General LootOn
        /squelch /alias /maxradius      /changevarint Pull MaxRadius
        /squelch /alias /maxzrange      /changevarint Pull MaxZRange
        /squelch /alias /medcombat      /togglevariable MedCombat
        /squelch /alias /medstart       /changevarint General MedStart
        /squelch /alias /meleedistance  /changevarint Melee MeleeDistance
        /squelch /alias /meleeon        /togglevariable MeleeOn
        /squelch /alias /mercassistat   /changevarint Merc MercAssistAt
        /squelch /alias /mezon          /changevarint Mez MezOn
        /squelch /alias /movewhenhit    /togglevariable MoveWhenHit 
        /squelch /alias /pethold        /togglevariable PetHold
        /squelch /alias /peton          /togglevariable PetOn
        /squelch /alias /pettoyson      /togglevariable PetToysOn
        /squelch /alias /pettoysplz     /echo PetToysPlease
        /squelch /alias /rebuffon       /togglevariable RebuffOn
        /squelch /alias /returntocamp   /togglevariable ReturnToCamp
        /squelch /alias /rezallon       /togglevariable AutoRezAll 1
        /squelch /alias /rezalloff      /togglevariable AutoRezAll 0
        /squelch /alias /scatteron      /togglevariable ScatterOn
        /squelch /alias /setae          /iniwrite AE
        /squelch /alias /setaggro       /iniwrite Aggro
        /squelch /alias /setbackoff     /backoff
        /squelch /alias /setbuffs       /iniwrite Buffs
        /squelch /alias /setburn        /iniwrite Burn
        /squelch /alias /setcure        /iniwrite Cure
        /squelch /alias /setdps         /iniwrite DPS
        /squelch /alias /setheals       /iniwrite Heals
        /squelch /alias /switchma       /switchma
        /squelch /alias /waithere       /togglevariable waithere
        /squelch /alias /trackme        /trackmedown
        /ini "${IniFileName}" "General" "KissAssistVer" "${MacroVer}"
    }
    /if (${Debug}) /echo \atDEBUG Aliases processed  \agLine#: ${Macro.CurLine}
| ************************* General **************************************|
    | Edit settings in your KissAssist_ToonName.ini file
    /echo Loading INI Info
    | Only call role from ini if not defined in command line from hot key
    /if (!${Defined[Role]}) {
        /call LoadIni General Role                  string      Assist
    } else /if (!${Ini[${IniFileName},General,Role].Length}) {
        /ini "${IniFileName}" "General" "Role" "${Role}"
    }
    /call LoadIni General CampRadius            int         30
    /call LoadIni General CampRadiusExceed      int         400
    /call LoadIni General ReturnToCamp          int         0
    /call LoadIni General ChaseAssist           int         0
    /call LoadIni General ChaseDistance         int         25
    /call LoadIni General MedOn                 int         1
    /call LoadIni General MedStart              int         20
    /call LoadIni General MedCombat             int         0
    /call LoadIni General LootOn                int         0
    /call LoadIni General RezAcceptOn           string      0|98
    /call LoadIni General AcceptInvitesOn       int         1
    /call LoadIni General GroupWatchOn          string      0
    /call LoadIni General CastingInterruptOn    int         0
    /declare GroupWatchPct int outer 20
    /if (${GroupWatchOn.Find[|]}) {
        /varset GroupWatchPct ${GroupWatchOn.Arg[2,|]}
        /varset GroupWatchOn ${GroupWatchOn.Arg[1,|]}
    }
    /call LoadIni General EQBCOn                string      0
    /declare EQBCSay                            string      outer   bc
    /if (${EQBCOn.Arg[2,|].Length} && ${EQBCOn.Arg[1,|].Equal[2]}) {
        /if (${Debug}) /echo ${EQBCOn} ${EQBCOn.Arg[1,|]} ${EQBCOn.Arg[2,|]} \agLine#: ${Macro.CurLine}
        /varset EQBCSay bct ${EQBCOn.Arg[2,|]}
        /varset EQBCOn 2
    }
    /if (${Select[${Me.Class.ShortName},BER,MNK,ROG,WAR]}==0) {
        /call LoadIni General MiscGem           int         8
        /call LoadIni General MiscGemLW         int         0
        /call LoadIni General MiscGemRemem      int         1
    } else {
        /declare MiscGem                        int         outer   0
        /declare MiscGemLW                      int         outer   0  
        /declare MiscGemRemem                   int         outer   0
    }
    /call LoadIni General CampfireOn            int         0 
    /if (${Int[${Ini[${IniFileName},General,CharInfo].Arg[2,|]}]}!=${Me.Level}) /ini "${IniFileName}" "General" "CharInfo" "${Me.Class}|${Me.Level}|${Me.Subscription}"
    /if (${Int[${Ini[${IniFileName},General,DefaultUI].Arg[1,|]}]}!=${EverQuest.CurrentUI.Equal[Default]}) /ini "${IniFileName}" "General" "DefaultUI" "${If[${EverQuest.CurrentUI.Equal[Default]},TRUE,FALSE|Custom UIs are not supported. Please switch to Default UI before posting bugs.]}"
    /if (${Select[${Me.Class.ShortName},WIZ,DRU]}) {
        /call LoadIni General GroupEscapeOn     int         0
    } else {
        /declare GroupEscapeOn                  int         outer    0
    }
    /call LoadIni General DPSMeter              int         1
    /call LoadIni General ScatterOn             int         0
	/declare SingleSize            int         1
	/declare Single[${SingleSize}]                    string      outer
	
	/call Custom_declares
| ************************* SpellSet *************************************|
    /call LoadIni SpellSet LoadSpellSet         int         0
    /call LoadIni SpellSet SpellSetName         string      "KissAssist"   
| ************************* Buffs ****************************************|
    /if (${LoadFromINI}) /call AutoLoad "buffs"
    /call LoadIni Buffs BuffsOn                 int         0
    /call LoadIni Buffs BuffsSize               int         20
    /declare Buffs[${BuffsSize}]                string      outer
    /call LoadIni Buffs Buffs                   string      NULL       Buffs        
    /call LoadIni Buffs RebuffOn                int         1
    /call LoadIni Buffs CheckBuffsTimer         int         10
    /call LoadIni Buffs PowerSource             string      NULL
	
	/declare checkmana                  int         outer       0
	/call CheckCastMana
| ************************* Melee ****************************************|
    /call LoadIni Melee AssistAt                int         95
    /if (${Select[${Me.Class.ShortName},BST,BER,MNK,PAL,RNG,ROG,SHD,WAR]}) {
        /call LoadIni Melee MeleeOn             int         1
    } else {
        /call LoadIni Melee MeleeOn             int         0
    }
    /call LoadIni Melee FaceMobOn               int         1
    /call LoadIni Melee MeleeDistance           int         75
	/call LoadIni Melee newMeleeDistance        int         75
    /call LoadIni Melee StickHow                string      "snaproll"
    /call LoadIni Melee AutoFireOn              int         0
    /call LoadIni Melee UseMQ2Melee             int         0
    /if (${Select[${Me.Class.ShortName},ROG]}) {
        /call LoadIni Melee AutoHide            int         1
    } else {
        /declare AutoHide                       int         outer 0
    }
| ************************* GoM ****************************************|
    /if (!${Select[${Me.Class.ShortName},BRD,BER,MNK,ROG,WAR]}) {
        /call LoadIni GoM GoMSHelp              string       "Format - Spell|Target, MA Me or Mob, i.e. Rampaging Servant Rk. II|Mob"
        /call LoadIni GoM GoMSize               int         3
        /declare GoMSpell[${GoMSize}]           string      outer
        /call LoadIni GoM GoMSpell              string      NULL       GoMSpell
    } else {
        /declare GoMSize                        int         outer 1
        /declare GoMSpell[${GoMSize}]           string      outer
    }
| ************************* Gmail ****************************************|
    /call LoadIni GMail GMailHelp               string      "Events currently support - Dead,Drag,GM,Level,Named,Leftgroup,Tells"
    /call LoadIni GMail GMailOn                 int         0
    /call LoadIni GMail GMailSize               int         5
    /declare GMail[${GMailSize}]                string      outer
    /call LoadIni GMail GMail                   string      NULL       GMail

| ************************* DPS ******************************************|
    /if (${LoadFromINI}) /call AutoLoad "dps"
    /call LoadIni DPS DPSOn                     int         0
    /call LoadIni DPS DPSSize                   int         20
    /call LoadIni DPS DPSSkip                   int         20
    /call LoadIni DPS DPSInterval               int         2
    /declare DPS[${DPSSize}]                    string      outer
    /call LoadIni DPS DPS                       string      NULL        DPS      
    /call LoadIni DPS DebuffAllOn               int         0
	/call LoadIni DPS AEOn                      int         0
	/call LoadIni DPS RangeOnly                 int         0
| ************************* Aggro ******************************************|
    /call LoadIni Aggro AggroOn                 int         0
    /if (${Select[${Me.Class.ShortName},SHD,WAR,PAL]})  {
        /call LoadIni Aggro AggroSize           int         10
    } else {
        /call LoadIni Aggro AggroSize           int         5
    }
    /declare Aggro[${AggroSize}]                string      outer
    /call LoadIni Aggro Aggro                   string      NULL        Aggro
| ************************* Bard *****************************************|
    /declare IAmABard                           bool        outer          ${Me.Class.Name.Equal[Bard]}
    /if (${IAmABard}) {
        /call LoadIni General TwistOn           int         0
        /call LoadIni General TwistMed          int         "Mana song gem"
        /call LoadIni General TwistWhat         string      "Twist order here"
        /call LoadIni Melee MeleeTwistOn        int         0
        /call LoadIni Melee MeleeTwistWhat      string      "DPS twist order here"
        /call LoadIni Pull PullTwistOn          int         0
    } else {
        /declare TwistOn                        int        outer       0
        /declare MeleeTwistOn                   int        outer       0 
        /declare PullTwistOn                    int        outer       0 
        /declare TwistWhat                      string     outer       0
        /declare MeleeTwistWhat                 string     outer       0
        /declare TwistMed                       int        outer       0
    }
| ************************* Heals ***************************************|
    /call LoadIni Heals Help                    string      "Format Spell|% to heal at i.e. Devout Light Rk. II|50"
    /if (${LoadFromINI}) /call AutoLoad "heals"
    /call LoadIni Heals HealsOn                 int         0
    /if (${Select[${Me.Class.ShortName},CLR,SHM,DRU,PAL]})  {
        /call LoadIni Heals HealsSize           int         15
    } else {
        /call LoadIni Heals HealsSize           int         5
    }
    /declare Heals[${HealsSize}]                string      outer
    /call LoadIni Heals Heals                   string      NULL        Heals
    /call LoadIni Heals XTarHeal                int         0
    /call LoadIni Heals XTarHeal2               int         0
    /call LoadIni Heals XTarHealList            string      ${If[${XTarHeal}&&${XTarHeal2},${XTarHeal}|${XTarHeal2},${If[${XTarHeal2},${XTarHeal2},${If[${XTarHeal},${XTarHeal},NULL]}]}]}
    /if (${Select[${Me.Class.ShortName},CLR,NEC,SHM,DRU,PAL]}) {
        /call LoadIni Heals AutoRezOn           int         0
        /call LoadIni Heals AutoRezWith         string      "Your Primary Rez Item/AA/Spell"
        /call LoadIni Heals AutoRez1            string      "${AutoRezWith}"
        /call LoadIni Heals AutoRez2            string      "Your Secondary Rez Item/AA/Spell"
        /call LoadIni Heals AutoRez3            string      "Your Third Rez Item/AA/Spell"
        /declare AutoRez[3]                     string      outer
        /call LoadIni Heals AutoRez             string      NULL        AutoRez
        /if (${AutoRez[1].Equal[null]}) /varset AutoRez[1] ${AutoRezWith}
    } else {
        /declare AutoRezOn                      int         outer       0
    }
    /call LoadIni Heals HealGroupPetsOn         int         0
	
	/call LoadIni Mod_Heal Xtarheal_ON								int	 0
	/call LoadIni Mod_Heal UseModHeal								int	 1
	/call LoadIni Mod_Heal PetPoint 								int  80	
	/call LoadIni Mod_Heal CLRPoint		 							int  80
	/call LoadIni Mod_Heal DRUPoint 								int  70
	/call LoadIni Mod_Heal SHMPoint 								int  60
	/call LoadIni Mod_Heal WIZPoint 								int  75
	/call LoadIni Mod_Heal MAGPoint 								int  75
	/call LoadIni Mod_Heal ENCPoint 								int  80
	/call LoadIni Mod_Heal NECPoint 								int  75
	/call LoadIni Mod_Heal WARPoint 								int  70
	/call LoadIni Mod_Heal MNKPoint 								int  60
	/call LoadIni Mod_Heal ROGPoint 								int  60
	/call LoadIni Mod_Heal RNGPoint 								int  90
	/call LoadIni Mod_Heal BSTPoint 								int  70
	/call LoadIni Mod_Heal SHDPoint 								int  90
	/call LoadIni Mod_Heal BRDPoint 								int  65
	/call LoadIni Mod_Heal BERPoint 								int  70
	/call LoadIni Mod_Heal PALPoint 								int  90
	/call LoadIni Mod_Heal GoMpoint 								int  80	

| ************************* Group Heals ***************************************|
	/call LoadIni Mod_Heal grpheal									int	 75
	/if (${Select[${Me.Class.ShortName},CLR,SHM,DRU,PAL]})  {
		/call LoadIni GHeals GHealsSize           int         5
	} else {
		/call LoadIni GHeals GHealsSize           int         2
	}
	/declare GHeals[${GHealsSize}]                string      outer
	/call LoadIni GHeals GHeals                   string      NULL        GHeals

	
| ************************* Cures ***************************************|
    /call LoadIni Cures CuresOn                 int         0
    /call LoadIni Cures CuresSize               int         5
    /declare Cures[${CuresSize}]                string      outer
    /call LoadIni Cures Cures                   string      NULL        Cures
| ************************* Pet *****************************************|
    /if (${Select[${Me.Class.ShortName},DRU,SHM,BST,ENC,MAG,NEC,SHD]}) {
        /call LoadIni Pet PetOn                 int         0
        /call LoadIni Pet PetSpell              string      "YourPetSpell"
        /if (${Select[${Me.Class.ShortName},BST,MAG,NEC]})  {
            /call LoadIni Pet PetFocus          string      "NULL"
        } else {
            /declare PetFocus                   string      outer   NULL
        }
        /call LoadIni Pet PetShrinkOn           int         0
        /call LoadIni Pet PetShrinkSpell        string      "Tiny Companion"
        /call LoadIni Pet PetBuffsOn            int         0
        /call LoadIni Pet PetBuffsSize          int         8
        /declare PetBuffs[${PetBuffsSize}]      string      outer
        /call LoadIni Pet PetBuffs              string      NULL    PetBuffs
        /call LoadIni Pet PetCombatOn           int         1
        /call LoadIni Pet PetAssistAt           int         95   
        /call LoadIni Pet PetAttackDistance     int         115          
        /declare PetToysDone                    int         outer   0
        /call LoadIni Pet PetToysSize           int         6
        /declare PetToys[${PetToysSize}]        string      outer
        /if (${Select[${Me.Class.ShortName},MAG]}) {
            /call LoadIni Pet PetToysOn         int         0
            /call LoadIni Pet PetToys           string      NULL    PetToys
            /call LoadIni Pet PetToysGave       string      NULL
        } else {
            /declare PetToysGave                string      outer   NULL
            /declare PetToysOn                  int         outer   0
        }
        /call LoadIni Pet PetBreakMezSpell      string      NULL
        /call LoadIni Pet PetRampPullWait       int         0  
        /call LoadIni Pet PetSuspend            int         0
        /call LoadIni Pet MoveWhenHit           int         0
        /call LoadIni Pet PetHoldOn             int         1
        /declare PetHold                        string     outer
        /if (${Me.AltAbility[Pet Discipline]}>=1) {
            /if (${Me.AltAbility[Pet Discipline]}<=5)      /varset PetHold hold
            /if (${Me.AltAbility[Pet Discipline]}>=6)      /varset PetHold ghold
        }
        /call LoadIni Pet PetForceHealOnMed     int         0
    } else {
        /declare PetForceHealOnMed              int         outer   0
        /declare PetOn                          int         outer   0
        /declare PetAssistAt                    int         outer   0
        /declare PetCombatOn                    int         outer   0
        /declare PetRampPullWait                int         outer   0
        /declare PetHoldOn                      int         outer   0
        /declare PetHold                        string      outer   0
    }
| ************************* Mez *****************************************|
    /if (${Select[${Me.Class.ShortName},BRD,ENC,NEC]}) {
        /call LoadIni Mez MezOn                 int         0
        /call LoadIni Mez MezRadius             int         50
        /call LoadIni Mez MezMinLevel           int         "Min Mez Spell Level"
        /call LoadIni Mez MezMaxLevel           int         "Max Mez Spell Level"
        /call LoadIni Mez MezStopHPs            int         80
        /call LoadIni Mez MezSpell              string      "Your Mez Spell"
        | necros can't AE mez
        /if (${Select[${Me.Class.ShortName},BRD,ENC]}) {
            /call LoadIni Mez MezAESpell        string      "Your AE Mez Spell|0"
            /declare MezAECount                 int         outer   ${MezAESpell.Arg[2,|]}
            /varset MezAESpell                  ${MezAESpell.Arg[1,|]}
        }
        /declare MezCount[13]                   int         outer 0
        /declare MezAEClosest                   int         outer 0
    } else {
        /declare MezOn                          int         outer 0
    }
        | This loads and declares the MezImmune var
        /call LoadIni "${ZoneName}" MezImmune   string      "List up to 10 mobs. Use full names i.e. a green snake,a blue tiger,a wide eye ooze or NULL" NULL ${InfoFileName}

| ************************* Burn ****************************************|
    /call LoadIni Burn  BurnSize                int         15
    /declare Burn[${BurnSize}]                  string      outer
    /call LoadIni Burn  BurnText                string      "Decepticons Attack"
    /call LoadIni Burn  BurnAllNamed            int         0
    /call LoadIni Burn  Burn                    string      NULL        Burn
    /call LoadIni Burn  UseTribute              int         0
| ************************* Pull ****************************************|
    /call LoadIni Pull PullWith                 string      "Melee"
    /call LoadIni Pull PullMeleeStick           int         0
    /call LoadIni Pull MaxRadius                int         350
    /call LoadIni Pull MaxZRange                int         50
    /call LoadIni Pull UseWayPointZ             int         0
    /call LoadIni Pull PullWait                 int         5
    /call LoadIni "${ZoneName}" MobsToPull      string      "List up to 25 mobs. Use full names i.e. a green snake,a blue tiger,a wide eye ooze or ALL for all mobs" NULL  ${InfoFileName}
    /call LoadIni "${ZoneName}" MobsToIgnore    string      "List up to 25 mobs. Use full names i.e. a green snake,a blue tiger,a wide eye ooze" NULL ${InfoFileName}
    /call LoadIni "${ZoneName}" MobsToBurn      string      "List up to 10 mobs. Use full names i.e. Beget Cube,Helias,Raze" Null ${InfoFileName}
    
    /call LoadIni Pull PullRadiusToUse          int         90
    /call LoadIni Pull PullRoleToggle           int         0
    /call LoadIni Pull ChainPull                int         0
    /call LoadIni Pull ChainPullHP              int         90
    /call LoadIni Pull ChainPullPause           string      30|2
    /call LoadIni Pull PullPause                string      ${ChainPullPause}
    /call LoadIni Pull PullLevel                string      0|0
    /call LoadIni Pull PullArcWidth             string      0
    | /call LoadIni Pull PullPath               string      NULL
| ************************* AFKTools ************************************|
    /call LoadIni AFKTools AFKHelp              string      "AFKGMAction=0 Off, 1 Pause Macro, 2 End Macro, 3 Unload MQ2, 4 Quit Game"
    /call LoadIni AFKTools AFKToolsOn           int         1
    /call LoadIni AFKTools AFKGMAction          int         1
    /call LoadIni AFKTools AFKPCRadius          int         500
    /call LoadIni AFKTools CampOnDeath          int         0
    /call LoadIni AFKTools ClickBacktoCamp      int         0
    /if (${Debug}) /echo \atDEBUG Load ini procesed \agLine#: ${Macro.CurLine}
| Do Not Edit These *****************************************************|
    /declare AddSpam                timer       outer       0
    /declare AddsArray[50,3]        string      outer       NULL
    /declare AdvpathPointNum        int         outer       0
    /declare AdvpathPointX          float       outer       0
    /declare AdvpathPointY          float       outer       0
    /declare AdvpathPointZ          float       outer       0
    /declare AggroOffTimer          timer       outer       0
    /declare AggroTargetID          string      outer
    /declare AggroTargetID2         string      outer       0
    /declare AmmoSwitch             int         outer       0
    /declare Attacking              int         outer       0
    /declare AutoRezAll             int         outer       0
    /declare BagNum                 int         outer       0
    /declare BBWindowOpen           timer       outer       0
    /declare BeforeArray[5]         string      outer       null
    /declare BeginMobID             string      outer
    /declare BPBWindowOpen          timer       outer       0
    /declare Banestrike             string      outer
    /declare BardStartTwist         int         outer       0
    /declare BindActive             int         outer       0
    /declare BurnActive             int         outer       0 
    /declare BlockedBuffsCount      int         outer       0
    /declare CalledTargetID         int         outer       0
    /declare CampOnDeathTimer       timer       outer       0
    /declare CampfireClickTimer     timer       outer       0
    /declare CampfireTimer          timer       outer       0
    /declare CantHit                int         outer       0
    /declare CantSee                int         outer       0
    /declare CastResult             string      outer
    /declare castReturn             string      outer       CAST_CANCELLED
    /declare ChainPullTemp          string      outer 
    /declare CleanBuffsTimer        timer       outer       0
    /declare CombatStart            int         outer       0
    /declare CorpseRezCheck         string      outer       null
    /declare CursorID               int         outer       0
    /declare CursorIDCount          int         outer       0
    /declare CursorIDTimer          timer       outer       0
    /declare DebuffCount            int         outer       0
    /declare DMZ                    int         outer       ${Select[${Zone.ID},345,344,202,203,279,151,33506]}
    /declare DontMoveMe             int         outer       0
    /declare DPSCounter             int         outer       0
    /declare DPSLastTime            int         outer       0
    /declare DPSPaused              int         outer       0
    /declare DPSPetTotal            int         outer       0
    /declare DPSSpam                int         outer       0
    /declare DPSTarget              int         outer       0
    /declare DPSTotal               int         outer       0
    /declare DPSTwisting            int         outer       0
    /declare DPSWriteOn             int         outer       0
    /declare DragCorpse             int         outer       0   
    /declare DStickDist             int         outer       0
    /declare DStickHow              string      outer       0
    /declare DurationMod            float       outer       1
    /declare EventByPass            int         outer       0
    /declare FailCounter            int         outer       0
    /declare FailMax                int         outer       3
    /declare GMailEvents            string      outer         
    /declare GSent                  int         outer       0
    /declare GoMActive              int         outer       0
    /declare GoMByPass              int         outer       0
    /declare GotHitToggle           int         outer       0
    /declare GlobalIndex            int         outer       0
    /declare GroupHeal[10]          string      outer
    /declare HealAgain              int         outer       0
    /declare IAmDead                int         outer       0
	/declare switchAmIDead          bool        outer       FALSE
    /declare IniNextTimer           timer       outer       0
    /declare JoinedParty            timer       outer       0
    /declare JustZoned              timer       outer       0
    /declare LastMobPullID          int         outer       0
    /declare LastZone               int         outer       ${Zone.ID}
    /declare LooterAssigned         int         outer       0
    /declare MacroReturn            string      outer
    /declare MASitTime              timer       outer       0
    /declare MainAssist             string      outer
    /declare MainAssistClass        string      outer
    /declare MainAssistType         string      outer
    /declare MashArray[10]          string      outer       null
    /declare MedStat                string      outer
    /declare MedStat2               string      outer       Endurance
    /declare Medding                int         outer       0
    /declare MercAssisting          int         outer       0
    /declare MercInGroup            int         outer       0
    /declare MezAETimer             timer       outer       0
    /declare MezArray[50,3]         string      outer       NULL
    /declare MezBroke               int         outer       0
    /declare MezImmuneIDs           string      outer
    /declare MezMobAECount          int         outer       0
    /declare MezMobCount            int         outer       0
    /declare MezMobFlag             int         outer       0
    /declare MezMod                 int         outer       0
    /declare MissingComponent       int         outer       0
    /declare MobCount               int         outer       0
    /declare MobFlag                int         outer       1
    /declare MobsToIgnoreByID       string      outer       null
    /declare MountOn                int         outer       1
    /declare MQ2MeleeReload         int         outer       0
    /declare MQ2CastReload          int         outer       0
    |/declare MyAAExp                float       outer       ${Me.PctAAExp}
    |/declare MyExp                  float       outer       ${Me.PctExp}
    /declare MyMerc                 string      outer       0
    /declare MyOriginalRole         string      outer
    /declare MyTargetID             int         outer       0
    /declare MyTargetName           string      outer       0
    /declare NamedCheck             int         outer       0
    /declare NeedCuring             int         outer       0
    /declare OrigRanged             string      outer       ${InvSlot[ranged].Item.Name}
    /declare PCsDetected            int         outer       0
    /declare ParseDPSTimer          int         outer       0
    /declare PetActiveState         int         outer       0     
    /declare PetAttack              timer       outer       0
    /declare PetAttackRange         int         outer       0
    /declare PetBuffCheck           timer       outer       0
    /declare PetFollowTimer         timer       outer       60s    
    /declare PetSuspendState        int         outer       0 
    /declare PetTanking             int         outer       0
    /declare PetTauntOn             int         outer       0
    /declare PetTotCount            int         outer       0
    /declare PullAggroTargetID      string      outer
    /declare PullAlertTimer         timer       outer       0
    /declare PullAmmo               string      outer       NULL
    /declare Pulled                 int         outer       0
    /declare PullHeading            float       outer       0
    /declare PullLSide              float       outer       0
    /declare PullRSide              float       outer       0
    /declare PullHold               int         outer       0
    /declare PullIgnore1            string      outer       NULL
    /declare PullIgnore2            string      outer       NULL
    /declare PullIgnore3            string      outer       NULL
    /declare Pulling                int         outer       0
    /declare PullItem               string      outer       NULL
    /declare PullMax                int         outer       0
    /declare PullMin                int         outer       0
    /declare PullMob                int         outer       0
    /declare PullMoveUse            string      outer
    /declare PullNavDistance        int         outer       0     
    /declare PullPathArrayX[999]    float       outer        
    /declare PullPathArrayY[999]    float       outer
    /declare PullPathArrayZ[999]    float       outer
    /declare PullPathWpCount        int         outer       0
    /declare PullRange              int         outer       0
    /declare PullTimer              timer       outer       0
    /declare PullTooFar             int         outer       0
    /declare PullWithAlt            string      outer       Melee
    /declare PullWaitTimer1         timer       outer       0
    /declare PullWaitTimer2         timer       outer       0
    /declare PullXPCheck            int         outer       1     
    /declare RangedSwitch           int         outer       0
    /declare ReMemCast              int         outer       0
    /declare ReMemCastLW            int         outer       0
    /declare ReMemMiscSpell         string      outer       ${Me.Gem[${MiscGem}].Name}
    /declare ReMemMiscSpellLW       string      outer       ${Me.Gem[${MiscGemLW}].Name}
    /declare ReMemWaitLong          string      outer       null
    /declare ReMemWaitShort         string      outer       null
    /declare ReadBuffsTimer         timer       outer       0
    /declare Redguides              int         outer       1
    /declare RememberCamp           int         outer       0
    /declare SHealPct               int         outer
    /declare SingleHealPoint        int         outer       0
    /declare SingleHealPointMA      int         outer       0    
    /declare SingleHeal[15]         string      outer
    /declare SitToMedTimer            timer        outer        6s
    /declare SpamTimer              timer       outer       0
    /declare SpellReadyL            int         outer       0
    /declare StickDist              int         outer       13
    /declare StickDistUW            int         outer       10
    /declare TankTimer              timer       outer       0
    /declare TempAmmo               string      outer       ${InvSlot[ammo].Item.Name}
    /declare TempMaxRadius          int         outer       0
    /declare ToClose                int         outer       0
    /declare TributeTimer           timer       outer       0
    /declare Twisting               int         outer       0
    /declare TwistHold               int         outer       0
    /declare ValidTarget            int         outer       0
    /declare WasTwisting            bool        outer       FALSE
    /declare WaitTimer              timer       outer       0
    /declare WayPointZRange         int         outer       ${MaxZRange}
    /declare WeaveArray[10]         string      outer       null
    /declare WhoToChase             string      outer
    /declare WriteBuffsMercTimer    timer       outer       0
    /declare WriteBuffsPetTimer     timer       outer       0
    /declare WriteBuffsTimer        timer       outer       0
    /declare XTSlot                 int         outer       0
    /declare XTSlot2                int         outer       0
    /declare XTarToHeal[20]         int         outer       0
    /declare ZDist                  float       outer       0
    /if (${Debug}) /echo \atDEBUG Misc Declares Processed \agLine#: ${Macro.CurLine}
    | Set AA DurationMod for various timer from Spell Casting Reinforcement AA
    /if (${Me.AltAbility[Spell Casting Reinforcement].Rank}==1) /varset DurationMod 1.15
    /if (${Me.AltAbility[Spell Casting Reinforcement].Rank}==2) /varset DurationMod 1.3
    /if (${Me.AltAbility[Spell Casting Reinforcement].Rank}==3) /varset DurationMod 1.5
    /if (${Me.AltAbility[Spell Casting Reinforcement].Rank}==4) /varset DurationMod 1.7
    /if (${Me.AltAbility[Spell Casting Reinforcement].Rank}==5) /varset DurationMod 1.9
    /if (${Me.AltAbility[Extended Ingenuity].Rank}==1) /varset DurationMod 1.15
    /if (${Me.AltAbility[Extended Ingenuity].Rank}==2) /varset DurationMod 1.3
    /if (${Me.AltAbility[Extended Ingenuity].Rank}==3) /varset DurationMod 1.5
    /if (${Me.AltAbility[Extended Ingenuity].Rank}==4) /varset DurationMod 1.6
    /if (${Me.AltAbility[Extended Ingenuity].Rank}==5) /varset DurationMod 1.7
    /if (${Me.AltAbility[Extended Ingenuity].Rank}==6) /varset DurationMod 1.8
    | Set AA DurationMod for mez timer from Spell Casting Reinforcement AA
    /if (${Me.AltAbility[Mesmerization Mastery].Rank}==1) /varset MezMod 6
    /if (${Me.AltAbility[Mesmerization Mastery].Rank}==2) /varset MezMod 12
    /if (${Me.AltAbility[Mesmerization Mastery].Rank}==3) /varset MezMod 18
    /if (${Me.AltAbility[Mesmerization Mastery].Rank}==4) /varset MezMod 24
    | Compensate for Eyes Wide open AA and Extended Target Window
    /declare n int local
    /declare XSlotTotal int outer 13
    /if (${Ini[${IniFileName},General,XTSlot].Length}) {
        /varset XTSlot ${Ini[${IniFileName},General,XTSlot]}
        /if (${XTSlot}) /xtarget set ${XTSlot} autohater
        /ini "${IniFileName}" "General" "XTSlot" "0"
        /while (${Me.XTarget[${XTSlot}].TargetType.NotEqual[Auto Hater]}) {
           /if (${DebugFramework}) /Echo Current Line ${Macro.CurLine}
		   /delay 5
        }
        /varset XTSlot 0
    }
    /for n 1 to ${XSlotTotal}
        /if (${Me.XTarget[${n}].TargetType.Equal[Auto Hater]}) {
            /if (${XTSlot} && !${XTSlot2}) /varset XTSlot2 ${n}
            /if (${XTSlot}==0) {
                /varset XTSlot ${n}
                /ini "${IniFileName}" "General" "XTSlot" "${XTSlot}"
            }
        }
    /next n
    |  Added extra slot check and Error Message
    /if (${XTSlot}==0 || ${ChainPull} && !${XTSlot2}) {
        /echo You need more slots in your Extended Target Window set to Auto.
    /if (${ChainPull}) {
            /echo Please set at least 2 slots to Auto for Chain Pulling and restart KissAssist.
        } else {
            /echo Please set at least 1 slot to Auto and restart KissAssist.
        }
        /endmacro
    }
    | Changed Logic for populating AggroTargetID. This change will include mobs in camp not on XTarget.
    /noparse /varset AggroTargetID ${If[${Me.XTarget[${XTSlot}].ID},${Me.XTarget[${XTSlot}].ID},${If[${AggroTargetID2},${AggroTargetID2},0]}]}
    /noparse /varset PullAggroTargetID ${If[${ChainPull}==0,${Me.XTarget[${XTSlot}].ID},${If[${Me.XTarget[${XTSlot}].ID} && (${Me.XTarget[${XTSlot}].ID}==${MyTargetID} || ${Me.XTarget[${XTSlot}].ID}!=${BeginMobID} || ${Me.XTarget[${XTSlot2}].ID}),${MyTargetID},0]}]}
| ************************* Merc ****************************************|
    /call LoadIni Merc Help                     string      "To use: Turn off Auto Assist in Manage Mercenary Window"
    /call LoadIni Merc MercOn                   int         0
    /call LoadIni Merc MercAssistAt             int         92
    /if (${Select[${Me.Class.ShortName},BST,BRD,CLR,DRU,ENC,MAG,NEC,PAL,RNG,SHM,SHD,WIZ]}) /varset MedStat Mana
    /if (${Select[${Me.Class.ShortName},BER,MNK,ROG,WAR]}) /varset MedStat Endurance
    /if (${Debug}) /echo \atDEBUG Timers Processed \agLine#: ${Macro.CurLine}
| -------------------------------------------------------------------------------------
| Check if required plugins are loaded and settings
| -------------------------------------------------------------------------------------
    |/call CheckPlugin MQ2Cast
    /call CheckPlugin MQ2Exchange
    /call CheckPlugin MQ2Moveutils
    /call CheckPlugin MQ2Posse
    /call CheckPlugin MQ2Rez
	/call CheckPlugin MQ2Spawnsort
    /call CheckPlugin MQ2Worsthurt
	/call CheckPlugin MQ2Debuffs
    /if (${IAmABard}) /call CheckPlugin MQ2Twist
    /if (!${IAmABard} && !${Bool[${Plugin[mq2twist]}]}) /declare Twist int outer 0
    /if (${UseMQ2Melee}) {
        /call CheckPlugin MQ2Melee
        /if (${Bool[${Plugin[mq2melee]}]}) {
        |  Turn aggro mode off and turn on melee mode in MQ2Melee
            /squelch /melee aggro=0
            /squelch /melee melee=1
            /squelch /melee petassist=0
            /squelch /melee on
            /squelch /melee stickmode=0
            /varset StickHow 0
        } else {
            /echo MQ2Melee plugin did NOT load. Setting UseMQ2Melee off. 
            /varset UseMQ2Melee 0
            /if (${StickHow.Equal[0]}) /varset StickHow auto
        }
    } else {
        /if (${Bool[${Plugin[mq2melee]}]}) {
            /plugin mq2melee unload noauto
            /varset MQ2MeleeReload 1
        }
        /if (${StickHow.Equal[0]}) /varset StickHow auto
    }
    /if (${Bool[${Plugin[mq2cast]}]} && !${UseMQ2Melee}) {
        /plugin mq2cast unload noauto
        /varset MQ2CastReload 1
    }
    /varset DStickHow ${StickHow}
    /if (${EQBCOn} && !${Macro.IsTLO[EQBC]}) /plugin mq2eqbc noauto
    |  Set MQ2moveutils variables
    /stick set autosave off
    |/stick set moveback 12
    /stick set verbflags 0
    /stick set breakonkb on
    /stick set breakonmouse off
    /stick set breakdist ${CampRadiusExceed}
    /stick set breakonwarp on
    /stick set usefleeing on
    /stick set delaystrafe on
    /stick set feign on
    | Set up MQ2rez if RezAcceptOn=1
    /if (${RezAcceptOn.Arg[1,|].Equal[1]}) {
        /squelch /rez accept on
        /squelch /rez loot off
        /if (${Int[${RezAcceptOn.Arg[2,|]}]}>0) /rez pct ${Int[${RezAcceptOn.Arg[2,|]}]}
    } else {
        /squelch /rez accept off
    }
   /if (${Macro.IsTLO[Posse]}) {
       /if (${Select[${AFKToolsOn},1,2]}) {
            /posse radius ${AFKPCRadius}
            /posse friendnotify off
            /posse strangernotify on
            /if (!${Posse.Status})  {
                /posse on
                /posse load
            }
        }
    } else {
        /varset AFKToolsOn 0
    }
    | Initialize variables for ninjadvloot.inc include file
    /call SetupAdvLootVars
    /if (${HealsOn}) {
        /call SortArray Heals 100|100 >
        |/call FindSingleHeals
        |/call FindGroupHeals
		/call SortArray GroupHeal 100|100 >
    }
    /call CreateTimersHeals
    /call AlertAddToList 3 "${MobsToIgnore}"
    /call CreateTimersGoM
    /if (${DPSOn}) {
        /call SortArray DPS 1|1 <
    } else {
        /call CreateTimersDPS
    }
    /if (${BuffsOn}) {
        /call SortArray Buffs 100|100 >
    } else {
        /call CreateTimersBuffs
    }
    /if (${AggroOn}) /call SortArray Aggro 1|1 >
    /call SortArray Burn 1|1 >
    /if (${AutoRezOn}) /call CreateTimersRez
    /if (${MezOn}) /call CreateTimersMez
    /if (!${MezImmune.Find[List up to 10 mobs]}) /call AlertAddToList 4 "${MezImmune}"
    /if (${PullLevel.Find[auto]}) {
       /varcalc PullMin ${Me.Level}-5
       /varcalc PullMax ${Me.Level}+2       
    } else /if (${PullLevel.Equal[0|0]} || ${PullLevel.Equal[0]} || ${PullLevel.Equal[null]} || !${PullLevel.Find[|]}) {
       /varset PullMin 1
       /varset PullMax 200
       /varset PullLevel off
    } else {
       /varset PullMin ${PullLevel.Left[${Math.Calc[${PullLevel.Find[|]}-1]}]}
       /varset PullMax ${PullLevel.Right[${Math.Calc[${PullLevel.Length}-${PullLevel.Find[|]}]}]} 
    }
    /if (${PullMin}>${PullMax} || ${PullMin}==0 || ${PullMax}==0) {
       /echo Invalid Pull Level Settings resetting to default.
       /varset PullMin 1
       /varset PullMax 200
       /varset PullLevel off
    }
    | Checking your ini file for errors
    /if (!${Ini[FRAMEWORK/${MacroName}_Buffs.ini,${Me.ID},Zone].Length}) {
        /echo Checking your ini file for errors. 
        /delay 10
        /call ScanIni
    }
    /if (${NumParams}) {
        /call PParse 1 ${NumParams}
    }
    /if (${GMailOn}) /call GmailIniParse
	

| -------------------------------------------------------------------------------------
| Assign Main Tank from command line parameter or targeted player, merc or pet
| -------------------------------------------------------------------------------------
    /if (${ParseDPSTimer}>=1) {
        /target id ${Me.ID}
        /delay 10 ${Target.ID}==${Me.ID}
        /if (${DPSOn}) /varset DPSOn 2
        /if (${Select[${Me.Class.ShortName},mag,nec,bst]}) {
            /varset Role PetTank
        } else {
            /varset Role Tank
        }
        /call AssignMainAssist
        /call CheckRoles 1
        /call CheckBuffs 0
        /call Bind_Parse ${ParseDPSTimer}
    }
	/call KissConditons
    /if (!${MainAssist.Length} || ${MainAssist.Equal[null]}) {
       | Make pet if it isn't up already !!!!
        /if (${Select[${Role},pettank,pullerpettank,hunterpettank]} && !${Me.Pet.ID}) {
            /echo My role is (${Role}), but I have no active pet.
            /echo Making my pet so I can assign it as Main Assist!
            /call DoPetStuff
        }
        /if (!${Target.ID} && ${Select[${Role},tank,pullertank,hunter]}) {
            /target id ${Me.ID}
            /delay 10 ${Target.ID}==${Me.ID}
        }
        /if ((!${Target.ID} || ${Target.ID}!=${Me.ID}) && ${Select[${Role},pettank,pullerpettank,hunterpettank]}) {
            /target id ${Me.ID}
            /delay 10 ${Target.ID}==${Me.ID}
        }
        /call AssignMainAssist
    }
    | Check command line for tank name
    /if (${MainAssist.Length}) {
        /if (${Debug})  /echo ${MainAssist} \agLine#: ${Macro.CurLine}
        /target id ${Spawn[=${MainAssist}].ID}
        /if (${Debug}) /echo targeting ${Spawn[=${MainAssist}].ID} \agLine#: ${Macro.CurLine}
        /delay 30 ${Target.ID}==${Spawn[=${MainAssist}].ID}
        | Target PC instead of familiar or pet
        /if (${Spawn[=${MainAssist}].Type.Equal[Pet]} && !${MainAssist.Find[`s]}) {
            /tar pc ${MainAssist}
            /delay 10 ${Target.ID}==${Spawn[${MainAssist} pc].ID}
        }
        /call AssignMainAssist
    }
    /if ((!${Target.ID} || ${Target.CleanName.NotEqual[${Me.CleanName}]}) && ${Select[${Role},hunter,pullertank]}) {
        /target id ${Me.ID}
        /delay 10 ${Target.ID}==${Me.ID}
    }
    | Targeted myself end macro
    /if (${Target.CleanName.Equal[${Me.CleanName}]} && (${Role.Equal[assist]} || ${Role.Equal[puller]})) {
        /echo ERROR: You cannot assist yourself! Please target Main Tank and restart macro.
        /beep
        /endmacro
    }
    | Error control no tank selected end macro
    /if (!${Target.ID} || !${Select[${Target.Type},Mercenary,PC,Pet]} || ${Me.Type.Equal[corpse]}) {
        /echo ERROR: You have >> ${Target.CleanName} << targeted. Please target a Mercenary, PC or Pet for Main Tank and restart the macro.
        /beep
        /endmacro
    }
    
    /call CheckRoles 1
    /varset WhoToChase ${MainAssist}
    /varset MyOriginalRole ${Role}
    /if (${XTarHeal} && ${XTarHealList.NotEqual[null]}) /call SetXTargetHealList "${XTarHealList}"
    /if (${Role.Find[Puller]} && ${Float[${PullArcWidth}]}>0) /call SetPullAngles ${Me.Heading.Degrees} ${Float[${PullArcWidth}]} 1
    /echo ================================
    /echo Redguides presents
    /echo ${MacroName} v.${MacroVer} by Maskoi Modded by Toots
    /popup ${MacroName} v.${MacroVer} by Maskoi Modded by Toots
    /echo ================================
    /doevents
    /if (${Select[${Role},tank]}) {
        /if (${MainAssist.Equal[${Me}]}) {
            /echo I am Tanking & Main Assist
        }
    } else /if (${Select[${Role},puller]}) {
        /echo I am Puller. KissAssisting >> ${MainAssist} << at ${AssistAt}%
        /if (${ChainPull}) /echo  What? I have to chain pull now.
    } else /if (${Select[${Role},pullertank]}) {
        /echo I am Puller & Tank.
    | PetTank set role
    } else /if (${Select[${Role},pettank]}) {
        /echo My Pet >> ${Me.Pet.CleanName} << is Tanking & KissAssisting >> ${MainAssist} <<
    | PullerPetTank set role
    } else /if (${Select[${Role},pullerpettank]}) {
        /echo I am Pulling & my Pet >> ${Me.Pet.CleanName} << is Tanking.
        /echo We are all doomed.
        /delay 10
        /echo DOOMED!
    | HunterPetTank set role
    } else /if (${Select[${Role},hunterpettank]}) {
        /echo I am Hunting & my Pet >> ${Me.Pet.CleanName} << is Tanking.       
    } else /if (${Select[${Role},hunter]}) {
        /echo I am Hunting.
    } else /if (${Select[${Role},offtank]}) {
        /echo I am Off Tanking. KissAssisting >> ${MainAssist} << at ${AssistAt}%
    } else {
        /echo KissAssisting >> ${MainAssist} << at ${AssistAt}%
        /echo ${MainAssist} is a ${MainAssistType} ${Spawn[=${MainAssist}].Class}
    }
    /if (${Role.Find[Puller]} && ${Float[${PullArcWidth}]}>0) {
        /echo Pulling an Area starting from the Left at ${PullLSide} degrees ending at ${PullRSide} degrees. 
    }
    | If I am group leader set Main Assist Tag for Group Check for pet and make master MainAssist
    /if (${Select[${Me},${Group.Leader}]} && (${Spawn[group ${MainAssist}].ID} || (${Spawn[${MainAssist}].Type.Equal[pet]} && ${Spawn[group ${Spawn[${MainAssist}].Master.CleanName}].ID}))) { 
        | If Main Assist is someone else than who its suppose to be unset Group tag
        /if (${Group.MainAssist.Name.Length} && ${Group.MainAssist.Name.NotEqual[${MainAssist}]}) {
            /call AssignGroupRole unset "${Group.MainAssist.Name}" 2
        }
        /if (!${Group.MainAssist.Name.Length}) {
            /if (${Spawn[${MainAssist}].Type.Equal[pet]}) {
                /call BroadCast ${EQBCOn} r "Assigning ${Spawn[${MainAssist}].Master.CleanName} as Main Assist in Group Window"
                /call AssignGroupRole set "${Spawn[${MainAssist}].Master.CleanName}" 2
            } else {
            /call BroadCast ${EQBCOn} r "Assigning ${MainAssist} as Main Assist in Group Window"
            /call AssignGroupRole set "${MainAssist}" 2
            }
        }
    } else /if (${Select[${Me},${Group.Leader}]}) {
        /if (${Group.MainAssist.Name.Length} && ${Group.MainAssist.Name.NotEqual[${MainAssist}]}) {
            /call AssignGroupRole unset "${Group.MainAssist.Name}" 2
        }
    }
    /squelch /target clear
    /squelch /assist off
    /if (${Role.Find[pull]} || ${Role.Find[hunt]}) {
        /if (${PullPathWpCount} && ${PullMoveUse.Equal[advpath]}) {
            /call BroadCast ${EQBCOn} r "PULL: Path >> ${PullPath} <<  found with ${PullPathWpCount} waypoints."
            /call BroadCast ${EQBCOn} r "PULL: Using MQ2AdvPath to Pull with."
        } else /if (${Bool[${Plugin[MQ2Nav]}]}) {
            /if (${Navigation.MeshLoaded}) {
                | Set pullmoveuse to nav if mq2nav is detected without a mq2advpath path
                /varset PullMoveUse nav
                /call BroadCast ${EQBCOn} r "PULL: The MQ2Nav mesh for ${Zone} is loaded"
                /call BroadCast ${EQBCOn} r "PULL: Using MQ2Nav to Pull with ${PullWith}"
            }   
        } else {   
            /varset PullMoveUse los
            /call BroadCast ${EQBCOn} r "PULL: Using Line of Sight to Pull with ${PullWith}"
        }
            } else {
        /if (${Bool[${Plugin[MQ2Nav]}]}) {
            /if (${Navigation.MeshLoaded}) {
                | Set pullmoveuse to nav if mq2nav is detected without a mq2advpath path
                /varset PullMoveUse nav
                /echo The MQ2Nav mesh for ${Zone} is loaded
                /echo Using MQ2Nav to Move.
            }
        } else {
            /varset PullMoveUse los
            /echo Using MoveUtil to move with.
        }
    }
    /if (${LoadSpellSet}) /call LoadSpellSet
    /if (${Role.Find[puller]} && ${Bool[${Plugin[MQ2Map]}]}) {
        /squelch /mapfilter CastRadius color 25 225 25
        /squelch /mapfilter SpellRadius color 25 25 225
    }
    /call WinTitle
	
| -------------------------------------------------------------------------------------
| Raid Settings 
| -------------------------------------------------------------------------------------

	/if (${Raid.Members}) {
		/varset autoloot 0
		/if (${Bool[${Plugin[MQ2AutoLoot]}]}) {
			/autoloot off
		}
		/join VMRaidToons:1492
	}
| -------------------------------------------------------------------------------------
| Main Loop
| -------------------------------------------------------------------------------------
    /bc Entering Mainloop!
	/while (1) {
		|/varset MacroFlow Mainloop
		|/if (${MacroFlow}) /Echo Current Sub Current Line ${Macro.CurLine}
		|AMIDEAD
		/if (${DebugFramework}) /Echo Current Line ${Macro.CurLine}
		/if (!${Role.Equal[raidassist]} && !${Role.Equal[manual]} && !${Select[${Zone.ID},345,344,202,203,279]}) {
			/doevents
			|/if (${IAmDead}) /call DeathSub
			/if (${ChainPull}!=2) {
				/call CampfireBack
				/if (${Cursor.ID}) /call CheckCursor
				/if (${AFKToolsOn}) /call AFKTools
				/call _${Me.Class.ShortName}
				|Checking for combat
				/if (!${DPSPaused} && ${Select[${Role},manual,tank,pettank,pullertank,pullerpettank,hunter,hunterpettank]} && (!${Me.Combat} || ${Target.ID}!=${MyTargetID} || ${MyTargetID}==0) && ${Me.XTarget[1].ID} && ${SpawnCount[npc radius ${MeleeDistance} zradius 15 targetable playerstate 4]} && !${Spawn[corpse id ${MyTargetID}].ID}) /call FindTarget 1
				/if (!${DPSPaused} && !${Spawn[${MainAssistType} ${MainAssist} group].ID} && !${Select[${Role},manual,petassist,tank,puller,offtank]} && ${SpawnCount[npc radius ${MeleeDistance} zradius 15 targetable playerstate 4]}) /call FindTarget 2
				|/if (!${DPSPaused} && !${Select[${Role},manual,petassist,tank,pettank,puller,pullertank,pullerpettank,hunter,hunterpettank,offtank]} && (${MyTargetID}==0 || !${Spawn[targetable id ${MyTargetID}].ID} || ${Spawn[corpse id ${MyTargetID}].ID}) && ${Me.XTarget[1].ID} && ${SpawnCount[npc radius ${MeleeDistance} zradius 15 targetable playerstate 4]}) /call FindTarget 2
		
				/if (!${DPSPaused} && !${Spawn[corpse id ${MyTargetID}].ID} && ${Spawn[targetable id ${MyTargetID}].ID} && ${Spawn[${SpawnSearchType} id ${MyTargetID}].PctHPs}<=${AssistAt} && ${Spawn[${SpawnSearchType} id ${MyTargetID}].Distance}<${MeleeDistance} && (!${Target.Mezzed.ID} || ${Select[${Role},manual,petassist,tank,pettank,puller,pullertank,pullerpettank,hunter,hunterpettank,offtank]})) /call EngageTarget
			
				
				|/call CombatReset 0 mainloop
			
				/if (${Math.Distance[${CampYLoc},${CampXLoc}]} >= 10 && ${Me.XTarget[1].ID}==0 && ${ReturnToCamp}) /call DoWeMove 0 mainloop
				/if (${Me.CombatState.NotEqual[COMBAT]} && ${ChaseAssist}) /call DoWeChase
				/if ((${CombatStart} || ${AggroTargetID} || ${Me.CombatState.NotEqual[COMBAT]})) /call DoMiscStuff
				/if (${MercOn}) /call MercsDoWhat
				/call CastMana MainLoop
				
				
				/if (${PetOn}) {
					/call DoPetStuff
					/call CheckPetBuffs
				}
				/if (${Me.CombatState.NotEqual[COMBAT]}) {
					/call WriteBuffs
					/call WriteBuffsMerc
					/call WriteBuffsPet
				}
				/if (${CuresOn}) /call CheckCures
				/if (${BuffsOn} && (!${IAmDead} || !${Me.Invis} || !${ReadBuffsTimer})) /call CheckBuffs 0
				
				
				/if (${Me.CombatState.NotEqual[COMBAT]}) {
					/if (${MedOn}) /call DoWeMed
					/if (${GroupWatchOn}) /call GroupWatch
				}
				
				
			} else {
				/if (${DebugFramework}) /Echo Current Line ${Macro.CurLine}
				/call AFKTools
			}
			
			/if (${Select[${Role},puller,pullertank,pullerpettank,hunter,hunterpettank]}) {
				/if (${DebugFramework}) /Echo Current Line ${Macro.CurLine}
				/if (!${PullMob}) /call FindMobToPull 1
				/call PullCheck 
				/varset PullMob 0
			}
			/if (${LootOn}) /call LootStuff

		} else /if (${Role.Equal[manual]} && !${Select[${Zone.ID},345,344,202,203,279]}) {
			/if (${DebugFramework}) /Echo Current Line ${Macro.CurLine}
			/doevents
			/call manual_${Me.Class.ShortName}
			/if (${BuffsOn}) /call CheckBuffs
			/if (${PetOn}) /call DoPetStuff
		} else /if (${Role.Equal[raidassist]} && !${Select[${Zone.ID},345,344,202,203,279]}) {
			/if (${DebugFramework}) /Echo Current Line ${Macro.CurLine}
			/doevents
			/call _${Me.Class.ShortName}
			/if (${BuffsOn}) /call CheckBuffs
			/if (${PetOn}) /call DoPetStuff
		} else /if (!${Select[${Zone.ID},345,344,202,203,279]}) {
			/call RezCheck
		}
    }
    | From here down executed when /endmacro is issued or macro crashes due to error.
:OnExit 
    /if (!${MacroQuest.LastCommand.Find[/end]}) {
         /ini "${IniFileName}" "KissError"  "LastCMD:" "${MacroQuest.LastCommand}"
         /ini "${IniFileName}" "KissError"  "ErrorDateTime:" "${Time.Date} ${Time.Time24}"
         /ini "${IniFileName}" "KissError"  "ErrorMsg:" "${MacroQuest.Error}"
         /ini "${IniFileName}" "KissError"  "DataError:" "${MacroQuest.MQ2DataError}"
         /ini "${IniFileName}" "KissError"  "SyntaxError:" "${MacroQuest.SyntaxError}"
         /ini "${IniFileName}" "KissError"  "RunningTime:" "${MacroQuest.Running}"
         /ini "${IniFileName}" "KissError"  "BuildDate:" "${MacroQuest.BuildDate}"
         /ini "${IniFileName}" "KissError"  "CurrentUI:" "${EverQuest.CurrentUI}"
    }
	/leave VMRaidToons:1492
    /endmacro
/return
	
    | From here down executed when /endmacro is issued or macro crashes due to error.
:OnExit 
    /if (!${MacroQuest.LastCommand.Find[/end]}) {
        /ini "${IniFileName}" "KissError"  "LastCMD:" "${MacroQuest.LastCommand}"
        /ini "${IniFileName}" "KissError"  "ErrorDateTime:" "${Time.Date} ${Time.Time24}"
        /ini "${IniFileName}" "KissError"  "ErrorMsg:" "${MacroQuest.Error}"
        /ini "${IniFileName}" "KissError"  "DataError:" "${MacroQuest.MQ2DataError}"
        /ini "${IniFileName}" "KissError"  "SyntaxError:" "${MacroQuest.SyntaxError}"
        /ini "${IniFileName}" "KissError"  "RunningTime:" "${MacroQuest.Running}"
        /ini "${IniFileName}" "KissError"  "BuildDate:" "${MacroQuest.BuildDate}"
        /ini "${IniFileName}" "KissError"  "CurrentUI:" "${EverQuest.CurrentUI}"
    }
    /if (${MQ2CastReload}) /plugin mq2cast
    /if (${MQ2MeleeReload}) /plugin mq2melee
    /if (${XTSlot}) {
        /xtarget set ${XTSlot} autohater
        /ini "${IniFileName}" "General" "XTSlot" "0"
    }
    /endmacro
/return
| -------------------------------------------------------------------------------------
| SUB: PParse Parse passed command line parameters
| -------------------------------------------------------------------------------------    
    Sub PParse(int iniLoaded, int nump)
		/if (${Debug}) /echo \atDEBUG PParse: iniLoaded: ${iniLoaded} NumP: ${nump} \agLine#: ${Macro.CurLine}
		
        /declare i int local 0
        /declare j int local 0
        /declare k int local 0
        /declare TempPathX float local 0
        /declare TempPathY float local 0
        /declare TempPathZ float local 0
        /declare ipa int local 0
        /declare ipb int local 0
        | Command Line Passed Parameterss start with the number 0. 0 is the first param and is counted as 1 param even though the loop is 0 to 0.
        /for i 0 to ${nump}
            /if (${Debug}) /echo \atDEBUG PParse: ${i}. ${Defined[PParam${i}]} P${i}: ${PParam${i}} \agLine#: ${Macro.CurLine}
            /if (${Defined[PParam${i}]}) {
                | ipa increases the param counter by 1 so we can assign the variable after the current parma. 
                | /mac kissassist assist ma bob - if Param1 is ma for mainassist the next param is bob
                /varcalc ipa ${i}+1
                /varcalc ipb ${i}-1
                /if (${PParam${i}.Equal[ini]} && ${Defined[IniFileName]}) {
                    /varset IniFileName ${PParam${ipa}}
                    /echo Ini file has been set to >> ${PParam${ipa}} <<
                    /varset PIniSet 1
                }
                /if (${Select[${PParam${i}},assist,manual,petassist,tank,pettank,puller,pullertank,pullerpettank,hunter,hunterpettank,offtank]}) {
                    /if (!${Defined[Role]}) /declare Role string outer
                    /varset Role ${PParam${i}}
                }
                /if (${PParam${i}.Equal[ma]} && ${Defined[MainAssist]}) {
                    /if (!${Defined[PParam${ipa}]}) /declare PParam${ipa} string outer
                    /varset MainAssist ${PParam${ipa}}
                }
                /if (${Select[${PParam${i}},parse,assist,manual,petassist,tank,pettank,puller,pullertank,pullerpettank,hunter,hunterpettank,offtank]}==0 && ${Int[${PParam${i}}]}==0 && !${PParam${i}.Find[.ini]} && ${Defined[MainAssist]}) /varset MainAssist ${PParam${i}}
                /if (${PParam${i}.Equal[assistat]} && ${Defined[AssistAt]}) {
                    /if (!${Defined[PParam${ipa}]}) /declare PParam${ipa} string outer
                    /varset AssistAt ${PParam${ipa}}
                }
                /if (${Defined[PParam${ipb}]}) {
                    /if (${PParam${ipb}.NotEqual[parse]}) {
                        /if (${Int[${PParam${i}}]} >= 1 && ${Int[${PParam${i}}]} <= 100 && ${Defined[AssistAt]}) {
                            /varset AssistAt ${PParam${i}}
                        }
                    }
                }
                /if (${Defined[PullPathWpCount]}) {
                    /if (${PParam${i}.Equal[path]} && ${Defined[PullPath]}) {
                        /call CheckPlugin MQ2AdvPath
                        /if (${Bool[${Plugin[MQ2AdvPath]}]}) {
                            /delay 20 ${AdvPath.Active}
                            | Play path on pause to load info . Only way we can grab info from advpath
                            /if (${AdvPath.PathList[${PParam${ipa}}]}) {
                                /play ${PParam${ipa}} pause
                                /varset PullPath ${PParam${ipa}}
                                /delay 10
                                | Set PullPathWpCount with total amount of waypoints in path
                                /varset PullPathWpCount ${AdvPath.Waypoints}    
                                | Load path points into array
                                /for k 1 to ${PullPathWpCount} 
                                    /if (${Debug}) /echo \atDEBUG PParse WP#: ${Int[${Math.Calc[${k}-1]}]}-${k} Distance Between: ${Math.Distance[${TempPathY},${TempPathX}:${AdvPath.Y[${k}]},${AdvPath.X[${k}]}]} \agLine#: ${Macro.CurLine}
                                    /varset PullPathArrayX[${k}] ${AdvPath.X[${k}]}
                                    /varset PullPathArrayY[${k}] ${AdvPath.Y[${k}]}
                                    /varset PullPathArrayZ[${k}] ${AdvPath.Z[${k}]}
                                    /varset TempPathX ${PullPathArrayX[${k}]}
                                    /varset TempPathY ${PullPathArrayY[${k}]}
                                    /varset TempMaxRadius ${Math.Distance[${CampYLoc},${CampXLoc}:${PullPathArrayY[${k}]},${PullPathArrayX[${k}]}]}
                                    /if (${TempMaxRadius}>${MaxRadius}) /varset MaxRadius ${TempMaxRadius}
                                    /if (${Debug}) /echo \atDEBUG PParse: WP: ${k} WPX: ${PullPathArrayX[${k}]} WPY: ${PullPathArrayY[${k}]} \agLine#: ${Macro.CurLine}
                                /next k    
                                /varset TempMaxRadius ${MaxRadius}
                                /play off
                                | Tell Kiss were are using MQ2advpath for pulling
                                /varset PullMoveUse advpath
                            }
                        } else {
                            /echo Path ${PParam${ipa}} not found.
                            /varset PullMoveUse 
                            /varset PullPathWpCount 0
                            /varset UseWayPointZ 0
                        }
                    }
                }
                /if (${PParam${i}.Equal[parse]} && ${Defined[ParseDPSTimer]}) {
                    /if (!${Defined[PParam${ipa}]}) /declare PParam${ipa} string outer
                    /varset ParseDPSTimer ${PParam${ipa}}
                    /call KissConditons
                } else /if (${PParam${i}.Equal[scanini]}) {
                    /ini framework/${MacroName}_Buffs.ini ${Me.ID} Zone NULL
                } else /if (${PParam${i}.Equal[autoload]}) {
                    /varset LoadFromINI 1
                }
                /varset ipa 0
                /varset ipb 0
            }
        /next i
        /if (${iniLoaded}) {
            /if (${Select[${PullMoveUse},los,nav]}>=1) /varset UseWayPointZ 0
        }
        /if (${Debug}) {
            |these are not set when this sub gets called first time so in practice we cant echo them...
            /if (${iniLoaded}) {
                /echo \atDEBUG PParse Leave Role: ${Role} MA:${MainAssist} AssistAt:${AssistAt} INI:${IniFileName} PullPath:${PullPath} Parse:${ParseDPSTimer} \agLine#: ${Macro.CurLine}
            } else {
                /echo \atDEBUG PParse Leave
            }
        }
    /return


| -------------------------------------------------------------------------------------
| SUB: Validate Target Combined Spawn and Target
| -------------------------------------------------------------------------------------
    Sub ValidateTarget(int SpawnID)
        /if (${DebugCombat}) /echo \atDEBUGCOMBAT ValidateTarget Enter Target Name:${Target.CleanName} ID:${Target.ID} Spawn Name: ${Spawn[${SpawnID}].CleanName} ID:${SpawnID} \agLine#: ${Macro.CurLine}
        /declare j int local
        /declare PullValid int local 0
        /declare MobID int local 0
        /declare MobName string local
        /declare MobType string local
        /declare MeleeDistanceCheck int local ${MeleeDistance}       
        /varset ValidTarget 0
        /if (${SpawnID}) {
           /varset MobID ${Spawn[${SpawnID}].ID}
           /varset MobName ${Spawn[${SpawnID}].CleanName}
           /varset MobType ${Spawn[${SpawnID}].Type}
        } else {
           /varset MobID ${Target.ID}
           /varset MobName ${Target.CleanName}
           /varset MobType ${Target.Type}
        }
        /if (!${MobID}) /return NoTarget
        /if (${DebugCombat}) /echo \atDEBUGCOMBAT ValidateTarget Validate 1 \agLine#: ${Macro.CurLine}
        /if (${Select[${MobType},AURA,BANNER,CAMPFIRE,CORPSE,CHEST,ITEM,TRIGGER,TRAP,TIMER,MOUNT,Mercenary]}) /return BadTargetType
        /if (${DebugCombat}) /echo \atDEBUGCOMBAT ValidateTarget Validate 2 \agLine#: ${Macro.CurLine}
        | If mob found on ignore and not on xtarget skip
        /if (${MobsToIgnore.Find[${MobName}]} && ${Select[${MobID},${Me.XTarget[1].ID},${Me.XTarget[2].ID},${Me.XTarget[3].ID},${Me.XTarget[4].ID},${Me.XTarget[5].ID},${Me.XTarget[6].ID},${Me.XTarget[7].ID},${Me.XTarget[8].ID},${Me.XTarget[9].ID},${Me.XTarget[10].ID},${Me.XTarget[11].ID},${Me.XTarget[12].ID},${Me.XTarget[13].ID}]}==0) /return MobOnIgnoreList
        /if (${MobsToIgnoreByID.Find[${MobID}|]}) /return MobOnIgnoreListByID
        | Check if target is somewhere on my extended target.        
        /if (${Select[${Role},tank]} && ${MobCount}<=${XSlotTotal} && ${Spawn[${MainAssist} ${MainAssistType} group].ID}) {
            /if (${SpawnCount[id ${MobID} xtarhater]}==0) /return NotOnXTarget
        }
        /if (${Spawn[id ${MobID}].MaxRangeTo}>${MeleeDistance}) /varcalc MeleeDistanceCheck ${Spawn[id ${MobID}].MaxRangeTo}+5
        /if (${ReturnToCamp} && ${Math.Distance[${Spawn[${MobID}].Y},${Spawn[${MobID}].X}:${CampYLoc},${CampXLoc}]}>${MeleeDistanceCheck} && !${Pulling} && ${Select[${Role},tank,pullertank,pettank,pullerpettank]}) /return OutofCampRadius
        /if (${DebugCombat}) /echo \atDEBUGCOMBAT ValidateTarget Validate 3 \agLine#: ${Macro.CurLine}
        /if (${MobName.Find[eye of]} && ${SpawnCount[pc ${MobName.Right[${Math.Calc[${MobName.Length}-7]}]}]}) /return Spell-Eye-PC        
        /if (${MobType.Equal[Pet]} && ${Spawn[${MobID}].Master.Type.Equal[PC]}) /return PET-PC
        /if (!${Select[${EverQuest.Server},zek]} && ${Select[${MobType},PC]}) /return PC
        | This prevents characters on the Zek server from attacking PC targets in their group
        /if (${Select[${EverQuest.Server},zek]} && ${Select[${MobType},PC]}) {
            /if (${Spawn[id ${MobID} group].ID}>0) /return GroupMember
            /if (${MobID}==${Spawn[=${MainAssist}].ID}) /return MA
        }
        /if (${DebugCombat}) /echo \atDEBUGCOMBAT ValidateTarget Validate 4 \agLine#: ${Macro.CurLine}
        | Only valid when pulling
        /if (${Pulling} && !${Pulled}) {
            /if ((${Select[${PullMoveUse},los,nav]}>=1 && ${Math.Distance[${Spawn[${MobID}].Y},${Spawn[${MobID}].X}:${CampYLoc},${CampXLoc}]}>${MaxRadius})) /return OutofRadius
            /if (${Select[${Role},puller,pullertank,pullerpettank]} && !${Spawn[${MobID}].LineOfSight} && ${PullMoveUse.Equal[los]}) /return NoLOS            
            /if (${SpawnCount[loc ${Spawn[${MobID}].X} ${Spawn[${MobID}].Y} radius 12 pc]}>=1 && ${Pulling} && ${Math.Distance[${Spawn[${MobID}].Y},${Spawn[${MobID}].X}:${Me.Y},${Me.X}]}>=16) /return PCNear
            /if (${Spawn[${MobID}].PctHPs}<=99) /return PullNotFullHealth
            /if (${Spawn[${MobID}].Level}<${PullMin} || ${Spawn[${MobID}].Level}>${PullMax}) /return BadLevel 
            /if (${Window[TargetOfTargetWindow].Open} && ${Target.ID}==${MobID}) {
            | - If mob I'm pulling is aggroed already by non damaging spell by someone else.
               /delay 10 ${Target.ID}==${MobID}
               /if (${Me.TargetOfTarget.Type.Equal[PC]} && ${Me.TargetOfTarget.Name.NotEqual[${Me}]} && ${Group.Member[${Me.TargetOfTarget.Name}].Index}<1) /return PullToTTNotPuller
               /if (${Me.TargetOfTarget.Type.Equal[PET]} && ${Me.TargetOfTarget.Name.NotEqual[${Me.Pet.CleanName}]}) /return PullToTTNotMyPet
            }
            /if (${DebugPull} && !${MobsToPull.Find[null]}) /echo \atDEBUGPULL ValidateTarget ${MobsToPull} \agLine#: ${Macro.CurLine}
            /if (${MobsToPull.Find[ALL for all]} || ${MobsToPull.Equal[ALL]}) {
                /varset PullValid 1
            } else {
                /for j 1 to 25
                    /if (${DebugPull}) /echo \atDEBUGPULL ValidateTarget ${j} ${MobsToPull.Arg[${j},,]} ${MobName.Find[${MobsToPull.Arg[${j},,]}]} \agLine#: ${Macro.CurLine}
                    /if (${MobName.Find[${MobsToPull.Arg[${j},,]}]}) {
                        /varset PullValid 1
                        /break
                    }
                /next j
            }
            /if (!${PullValid}) /return PullMobNotonList
        }
        /varset ValidTarget 1
        /if (${DebugCombat}) /echo \atDEBUGCOMBAT ValidateTarget Leave \agLine#: ${Macro.CurLine}
    /return ${ValidTarget}

| -------------------------------------------------------------------------------------
| SUB: CombatTargetCheck
| -------------------------------------------------------------------------------------
    Sub CombatTargetCheck
        | If mob is dead return
		/echo Hey Dumbass I am in CombatTargetCheck
        /if (${Spawn[${MyTargetID}].Type.Equal[Corpse]} || !${Spawn[${MyTargetID}].ID} || ${DPSPaused}) /return 
        /declare CMyTargetID int Local ${MyTargetID}
        | Check target matches MA if group mainassist assigned and MA is in group
        /if (${Spawn[=${MainAssist}].ID} && ${Group.MainAssist.ID} && ${Spawn[=${MainAssist}].ID}==${Group.MainAssist.ID}) {
            /if (${Target.ID}!=${Me.GroupAssistTarget.ID} && ${Group.MainAssist.ID}!=${Me.ID}) {
                /if (${MyTargetID}!=${Me.GroupAssistTarget.ID} && ${Spawn[id ${Me.GroupAssistTarget.ID} npc].ID}) {
                    /echo My target does not match MA's. Switching to new target.
                    /varset MyTargetID ${Me.GroupAssistTarget.ID}
                    /varset MyTargetName ${Spawn[id ${Me.GroupAssistTarget.ID}].CleanName}
                }
            }
        } else /if (${CalledTargetID} && ${CalledTargetID}!=${MyTargetID}) {
            /varset MyTargetID ${CalledTargetID}
            /varset MyTargetName ${Spawn[${CalledTargetID}].CleanName}
            /varset CalledTargetID 0
            /varset MyTargetName ${Spawn[id ${MyTargetID}].CleanName}

        }
        /if (${CMyTargetID}!=${MyTargetID} && ${Target.ID}!=${MyTargetID} && ${Spawn[${MyTargetID}].ID}) {
            /squelch /target id ${MyTargetID}
            /delay 10 ${Target.ID}==${MyTargetID}
            /if (!${Group.Member[${MainAssist}].Index}) /xtarget set ${XTSlot} currenttarget
        }
    /return



| -------------------------------------------------------------------------------------
| SUB: BeforeAttack
| -------------------------------------------------------------------------------------    
    Sub BeforeAttack(TarID, int CondCheck)
        /declare i int local
        /declare UseThis string local
        /declare UseThisArg3 string local
        /declare UseThisArg4 string local
        /for i 1 to ${BeforeArray.Size}
            /varset UseThis ${BeforeArray[${i}].Arg[1,|]}
            /if (!${Bool[${UseThis}]} || !${Target.ID}) /return 
            /if (!${BeforeArray[${i}].Find[|cond]} && ${CondCheck}==2) /continue
            /if (!${ConOn} || !${BeforeArray[${i}].Find[|cond]} || ${If[${Cond[${BeforeArray[${i}].Mid[${Math.Calc[${BeforeArray[${i}].Find[|cond]}+5]},3]}]},1,0]}) {
            /if (${FindItem[=${UseThis}].ID} && ${Me.ItemReady[${UseThis}]}) {
                /useitem "${UseThis}"
                /echo ## Before Attack >> ${UseThis} <<
            } else /if (${Me.AltAbility[${UseThis}]} && ${Me.AltAbilityReady[${UseThis}]} && ${Me.AltAbility[${UseThis}].Type}!=5 && ${UseThis.NotEqual[twincast]})  { 
                /alt act ${Me.AltAbility[${UseThis}].ID}
                /echo ## Before Attack >> ${UseThis} <<
            } else /if (${Me.CombatAbility[${UseThis}]} && !${Me.CombatAbilityTimer[${UseThis}]} && ${Me.CombatAbilityReady[${UseThis}]} && ${Spell[${UseThis}].EnduranceCost}<${Me.Endurance}) {
                /disc ${Me.CombatAbility[${Me.CombatAbility[${UseThis}]}].ID}
                /echo ## Before Attack >> ${UseThis} <<
            } else /if (${Me.Ability[${UseThis}]} && ${Me.AbilityReady[${UseThis}]}) {
                /doability "${UseThis}"
                /echo ## Before Attack >> ${UseThis} <<
            } else /if (${UseThis.Find[command:]}) {
                /call CastCommand "${UseThis.Lower}" ${MyTargetID} 0                
            }
            /delay 3
            }
        /next i
    /return 0
| -------------------------------------------------------------------------------------
| SUB: CombatPet
| -------------------------------------------------------------------------------------
    Sub CombatPet
        /if (${DebugCombat}) /echo \atDEBUGCOMBAT CombatPet: Enter \agLine#: ${Macro.CurLine}
        /if (${DebugFramework}) /Echo Combat Pet 1 ${Macro.CurLine}
		/if (${PetAttack} || ${DPSPaused}) /return
        /if (${Select[${Role},pettank,pullerpettank,hunterpettank]} && ${Me.Pet.ID} && !${Me.Pet.Combat}) /pet attack 
        /if (${Me.Pet.ID} && (${PetAttack} || ${Me.Pet.Combat})) /return
        |/call FindTarget 4
		|/call CombatTargetCheck
        /if (!${Target.Mezzed.ID} && !${Me.Pet.Combat}) {
            /if (${Select[${Role},pettank,pullerpettank]}) {
                /if ((${Me.Pet.Stance.NotEqual[FOLLOW]}) && (${Math.Distance[${Me.Pet.Y},${Me.Pet.X}:${CampYLoc},${CampXLoc}]}>${CampRadius}) || (${Math.Distance[${Me.Y},${Me.X}:${CampYLoc},${CampXLoc}]}>${CampRadius})) /pet follow            
            }
			/if (${DebugFramework}) /Echo Combat Pet 2 ${Macro.CurLine}
            /pet attack
            /pet swarm
            /delay 10
            | Set timer to check if pet is attacking every 3s 
            /varset PetAttack 30
        } else {
            /if (${Target.Mezzed.ID} && ${Select[${Role},pettank,pullerpettank]} && ${PetBreakMezSpell.NotEqual[null]}) /call BreakMez
        }
        /if (${DebugCombat}) /echo \atDEBUGCOMBAT CombatPet: Leave \agLine#: ${Macro.CurLine}
    /return  
| -------------------------------------------------------------------------------------
| SUB: BreakMez - Written by Trehuggindruid for KissAssist
| -------------------------------------------------------------------------------------
    Sub BreakMez   
        /if (${PetBreakMezSpell.Equal[null]}) /return
        /if (${DebugCombat}) /echo \atDEBUGCOMBAT BreakMez: Enter \agLine#: ${Macro.CurLine}
        /declare PetBreakMezTargetID int local ${MyTargetID}
        /echo ATTEMPTING TO BREAK MEZ ON: (${Target.CleanName}) ID:(${PetBreakMezTargetID})
        /while (${Target.Mezzed.ID}) {
            /if (${DebugCombat}) /echo \atDEBUGCOMBAT Break Mez with: - ${PetBreakMezSpell} \agLine#: ${Macro.CurLine}
            /call CastWhat "${PetBreakMezSpell}" ${PetBreakMezTargetID} BreakMez 0 0
            |--- DO NOT CHANGE THIS CONDITION!!!!!!
            /if (${Target.Mezzed.ID}) {
                /if (${DebugCombat}) /echo \atDEBUGCOMBAT Mez NOT broken, trying again! \agLine#: ${Macro.CurLine}
            } 
        }
        /varset PetAttack 0
        /echo + Mez broken !
        /if (${Me.Pet.ID} && !${Me.Pet.Combat}) /pet attack
        /if (${DebugCombat}) /echo \atDEBUGCOMBAT BreakMez: Leave \agLine#: ${Macro.CurLine}
    /return 
| -------------------------------------------------------------------------------------
| SUB: CombatReset
| -------------------------------------------------------------------------------------
    Sub CombatReset(int SFlag, string CalledFrom)
        /declare DPSCalcTimer timer local 10
        /while (${DPSCalcTimer}) {
            /doevents
        }
        /declare DPSCalc string local
        /declare DPSTCalc string local
        /declare DPSMyDam string local
        /declare DPSPCalc string local
        /declare DPSPTCalc string local
        /declare DPSMyPetDam string local
        /declare DPSMeAndPetDam string local
        /declare DPSMPCalc string local
        /declare DPSMPTCalc string local
        /if (${DebugCombat}) /echo \atDEBUGCOMBAT CombatReset: Enter ${SFlag} ${CalledFrom} \agLine#: ${Macro.CurLine}
        
        /declare i int local
        /declare j int local
        /call MobRadar ${MeleeDistance} CombatReset
        /for j 1 to 50
            /if (${AddsArray[${j},1].Equal[${MyTargetID}]}) /call RemoveFromArray AddsArray ${j}
            /if (${MobCount}==0) /call RemoveFromArray AddsArray ${j}
            /if (${MezOn} && ${j}<=13) {
                /if (${MezArray[${j},1].Equal[${MyTargetID}]}) {
                    /call RemoveFromArray MezArray ${j}
                } else /if (${MezArray[${j},1].NotEqual[NULL]}) {
                    /if (!${Spawn[${MezArray[${j},1]}].ID} || ${Spawn[${MezArray[${j},1]}].Type.Equal[Corpse]}) /call RemoveFromArray MezArray ${j}
                }
            }
        /next j
        /if (${MezOn}) {
            /if (${MezImmuneIDs.Find[|${MyTargetID}]}) /varset MezImmuneIDs ${MezImmuneIDs.Replace[|${MyTargetID},]}
            /varset j 1
            /while (${Bool[${MezImmuneIDs.Arg[${j},|].Length}]}) {
                /if (!${Bool[${Spawn[${MezImmuneIDs.Arg[${j},|]}].ID}]} || ${Spawn[${MezImmuneIDs.Arg[${j},|]}].Type.Equal[corpse]} ) {
                    /varset MezImmuneIDs ${MezImmuneIDs.Replace[|${MezImmuneIDs.Arg[${j},|]},]}
                } else {
                    /varcalc j ${j}+1
                }
            }
        }
        /if (${MobsToIgnoreByID.NotEqual[null]}) {
            /varset j 1
            /while (${Bool[${MobsToIgnoreByID.Arg[${j},|].Length}]} && ${MobsToIgnoreByID.Arg[${j},|].NotEqual[null]}) {
                /if (!${Bool[${Spawn[${MobsToIgnoreByID.Arg[${j},|]}].ID}]} || ${Spawn[${MobsToIgnoreByID.Arg[${j},|]}].Type.Equal[corpse]} ) {
                    /varset MobsToIgnoreByID ${MobsToIgnoreByID.Replace[|${MobsToIgnoreByID.Arg[${j},|]},]}
                } else {
                    /varcalc j ${j}+1
                }
            }
        }
        /varset CalledTargetID 0
        /varset AggroTargetID2 0
        /varset MyTargetID 0
        /varset MyTargetName
        /varset ValidTarget 0
        /varset MercAssisting 0
        /varset CombatStart 0
        /varset Pulled 0
        /varset NamedCheck 0
        /call PullReset
        /if (${UseMQ2Melee}) /squelch /melee melee=0
        /squelch /attack off
        /if (${Me.AutoFire}) /autofire
        /squelch /target clear
        /if (!${Group.Member[${MainAssist}].Index}) /xtarget set ${XTSlot} autohater
        /varset Attacking 0
        /if (${DPSOn}) {
            /for i 1 to ${DPS.Size}
                /if (${Int[${DPS[${i}].Arg[2,|]}]}<101) { 
                    /varset DPSTimer${i} 0
                    /varset FDTimer${i}  0
                }
            /next i
        }
        /if (${Me.Pet.ID}) {
            /varset PetAttack 0
            /pet back off
            /if (${PetHoldOn}) /pet ${PetHold} on
        }
        /if (${DebuffAllOn} && ${DebuffCount}) {
            /varset j 0
            /for i 1 to ${XSlotTotal}
                /if (${Me.XTarget[${i}].ID} && ${Me.XTarget[${i}].TargetType.Equal[Auto Hater]} && ${Me.XTarget[${i}].Type.NotEqual[Corpse]} && ${Me.XTarget[${i}].Distance}<=${MeleeDistance}) /varcalc j ${j}+1
            /next i
            /if (${j}==0) {
                /for i 1 to ${DebuffCount}
                    /varset DBOTimer${i} 0
                    /varset DBOList${i}
                /next i
            }
        }
        /if (${Defined[DPSTimeStart${MyTargetID}]}) /deletevar DPSTimeStart${MyTargetID}
        /varset DPSLastTime 0
        /varset DPSTotal 0
        /varset DPSTarget 0
        /varset DPSPetTotal 0
        /varset DPSCounter 0
        /varset BurnActive 0
        /if (!${TwistOn} && ${MeleeTwistOn}) /varset DPSTwisting 0
        /if (${LootOn} && !${SFlag}) {
            /delay 10
            /call LootStuff
            /if (${IAmABard}) {
                /while (${Me.BardSongPlaying}) {
                    /if (${Twist}) /squelch /twist off
                    /stopsong
                    /delay 10
                }
            }
        }
        /if (${IAmABard}) /call DoBardStuff
        /call AlertClearList 2 CombatReset
        /varset TankTimer 3s
        /squelch /target clear
        /if (!${Group.Member[${MainAssist}].Index}) /xtarget set ${XTSlot} autohater
        /if (${DebugCombat}) /echo \atDEBUGCOMBAT CombatReset: Leave \agLine#: ${Macro.CurLine}
        /varset PetFollowTimer 60s
        /delay 2s ${AggroOffTimer}==0
        /doevents Timer
        /doevents flush
        /if (${Stick.Active} && ${Stick.StickTarget}!=${If[${Spawn[=${WhoToChase}].Type.Equal[Pet]},${Spawn[=${WhoToChase}].Master.ID},${Spawn[=${WhoToChase}].ID}]}) /stick off
        /if (${UseMQ2Melee}) /squelch /melee melee=1
        /if (${Select[${Me.Class.ShortName},ROG]}) /call Roguestuff
    /return

| -------------------------------------------------------------------------------------
| SUB: CastReady
| -------------------------------------------------------------------------------------
    Sub CastReady(string castWhat,string sentFrom)
        /varset SpellReadyL 0
        /if (!${Bool[${castWhat}]}) /return 0
        /if (${sentFrom.Equal[rezwithcheck]}) {
            /if (${Select[TRUE,${Me.AltAbilityReady[${castWhat}]},${Me.ItemReady[=${castWhat}]},${Me.CombatAbilityReady[${castWhat}]},${Me.AbilityReady[${castWhat}]}]}==0) {
                /if (${Me.Book[${castWhat}]}) {
                    /if (!${Me.Gem[${castWhat}]}) {
                        /varset SpellReadyL 5
                        /return ${SpellReadyL}
                    }
                }
            }
        } else /if (${sentFrom.Equal[singleheal]}) {
            /if (${Me.Gem[${castWhat}]}) {
                /while (${Me.SpellInCooldown}) {
                    /delay 2
                }
            }
        }
        /varset SpellReadyL ${Select[TRUE,${Me.AltAbilityReady[${castWhat}]},${Me.ItemReady[=${castWhat}]},${Me.CombatAbilityReady[${castWhat}]},${Me.AbilityReady[${castWhat}]},${Me.SpellReady[${castWhat}]}]}
    /return ${SpellReadyL}
| -------------------------------------------------------------------------------------
| SUB: CastWhat
| -------------------------------------------------------------------------------------
    Sub CastWhat(string castWhat,int WhatID,string sentFrom,int CastOnCorpse,int Cond#)
        /if (!${IAmABard} && ${Me.Casting.ID}) /return CAST_CASTING
        /if (${DebugCast}) /echo \atDEBUGCAST CastWhat Enter \aw ${castWhat} ID: ${WhatID} Target:${Spawn[id ${WhatID}].CleanName} SentFrom: ${sentFrom} \agLine#: ${Macro.CurLine}
        /declare ReadyToCast int local 0
        /varset castReturn X
        /varset CastResult CAST_NO_RESULT
        /declare EventsCalcTimer timer local 0
        /if (${castWhat.Find[command:]} || ${Me.AltAbility[${castWhat}]} || ${Me.CombatAbility[${castWhat}]} || ${FindItem[=${castWhat}].ID} || ${Me.Ability[${castWhat}]} || ${Me.Book[${castWhat}]}) {
            /if (${IAmABard}) {
                /varset ReadyToCast ${Select[TRUE,${Me.ItemReady[=${castWhat}]},${Me.AltAbilityReady[${castWhat}]},${Me.CombatAbilityReady[${castWhat}]},${Me.AbilityReady[${castWhat}]},${Bool[${Me.Gem[${castWhat}]} && ${Me.GemTimer[${castWhat}]}==0]},${Bool[${castWhat.Find[command:]}]}]} 
            } else {
                /varset ReadyToCast ${Select[TRUE,${Me.ItemReady[=${castWhat}]},${Me.AltAbilityReady[${castWhat}]},${Me.CombatAbilityReady[${castWhat}]},${Me.AbilityReady[${castWhat}]},${Me.SpellReady[${castWhat}]},${Bool[${castWhat.Find[command:]}]}]} 
            }
            /if (${DebugCast}) /echo \atDEBUGCAST CastWhat \aw ${Me.ItemReady[=${castWhat}]},${Me.AltAbilityReady[${castWhat}]},${Me.CombatAbilityReady[${castWhat}]},${Me.AbilityReady[${castWhat}]},${Me.SpellReady[${castWhat}]},${Bool[${castWhat.Find[command:]}]}  \agLine#: ${Macro.CurLine}
            /if (${ReadyToCast}) {
                /if (${DebugCast}) /echo \atDEBUGCAST CastWhat \aw Target Info !${Target.ID} ${Target.ID}!=${WhatID} ${Spawn[id ${WhatID}].ID} \agLine#: ${Macro.CurLine}
                /if (!${Target.ID} || (${Target.ID}!=${WhatID} && ${Spawn[id ${WhatID}].ID})) /call CastTarget ${WhatID}
                /if (${Cond#} && ${If[${Cond[${Cond#}]},0,1]}) /return ${CastResult}
                /if (${sentFrom.Equal[DPS]} && ${Spell[${castWhat}].SpellType.Equal[Detrimental]}) {
                    /if (!${Me.CombatAbilityReady[${castWhat}]} && !${Me.AbilityReady[${castWhat}]} && (${Me.AltAbilityReady[${castWhat}]} || ${Me.SpellReady[${castWhat}]})) {
                        /call CastDPSSpellCheck "${castWhat}"
                        /if (${DebugCast}) /echo \atDEBUGCAST CastWhat ${Macro.Return} \agLine#: ${Macro.CurLine}
                        /if (${Macro.Return}) {
                            /if (${DebugCast}) /echo \atDEBUGCAST CastWhat --${castWhat} is already on Mob. Skipping. \agLine#: ${Macro.CurLine}
                            /return ${CastResult}
                        }
                    } 
                }
                /if (${sentFrom.Find[Buffs]} && ${Spell[${castWhat}].SpellType.Find[Beneficial]} && ${WhatID}!=${Me.ID}) {
                    /call CastBuffsSpellCheck "${castWhat}"
                    /if (${DebugCast}) /echo \atDEBUGCAST CastWhat ${Macro.Return} \agLine#: ${Macro.CurLine}
                    /if (${Macro.Return}) {
                        /if (${DebugCast}) /echo \atDEBUGCAST CastWhat --${castWhat} is already on Target. Skipping. \agLine#: ${Macro.CurLine}
                        /varset CastResult CAST_HASBUFF
                        /return ${CastResult}
                    }
                }
                /if (${Spell[${castWhat}].CastTime}) /call StopMoving 
                /if (${ReadyToCast}==1 && ${Me.ItemReady[=${castWhat}]} && ${FindItem[=${castWhat}].ID}  ) /call CastItem "${castWhat}" ${WhatID} 0
                /if (${ReadyToCast}==2 && ${Me.AltAbilityReady[${castWhat}]} && !${FindItem[=${castWhat}].ID}) /call CastAA "${castWhat}" ${WhatID} ${CastOnCorpse}
                /if (${ReadyToCast}==3 && ${Me.CombatAbilityReady[${castWhat}]} && ${Spell[${castWhat}].EnduranceCost}<${Me.Endurance}) /call CastDisc "${castWhat}" ${WhatID} ${CastOnCorpse}
                /if (${ReadyToCast}==4 && ${Me.AbilityReady[${castWhat}]}) /call CastSkill "${castWhat}" ${WhatID} 0
                /if (${ReadyToCast}==5 && ${Me.SpellReady[${castWhat}]} && ${Me.Book[${castWhat}]} && ${Spell[${castWhat}].Mana}<${Me.CurrentMana}) /call CastSpell "${castWhat}" ${WhatID} ${sentFrom} ${CastOnCorpse}
                /if (${ReadyToCast}==6 && ${castWhat.Find[command:]}) /call CastCommand "${castWhat.Lower}" ${WhatID} 0
            } else {
                /if (!${FindItem[=${castWhat}].ID} && ${Me.Book[${castWhat}]} && !${Me.Gem[${castWhat}]} && !${Me.AltAbility[${castWhat}]} && ${ReadyToCast}==0) {
                    /call CastMem "${castWhat}" ${sentFrom}
                    /if (${Macro.Return.NotEqual[notready]} && ${Me.Gem[${castWhat}]}!=0) {
                        /varset ReadyToCast 7
                        /if ((!${Target.ID}) || (${Target.ID}!=${WhatID} && ${Spawn[id ${WhatID}].ID})) /call CastTarget ${WhatID}
                        /if (${Cond#} && ${If[${Cond[${Cond#}]},0,1]}) /return ${CastResult}
                        /call CastSpell "${castWhat}" ${WhatID} ${sentFrom} ${CastOnCorpse}
                    }
                }
            }
        }    
        /varset EventsCalcTimer 5
        /while (${EventsCalcTimer}) {
            /doevent YouHit
            /doevent YourPetHit
        }
        /varset SitToMedTimer ${SitToMedTimer.OriginalValue}
        |Remem spell originally in Miscgem slot except if combat or just rezd
        /if (${MiscGemRemem} && ${ReadyToCast}==7) /call CastReMem
        /if (${DebugCast}) /echo \atDEBUGCAST CastWhat \aw Leave \agLine#: ${Macro.CurLine}
    /return ${CastResult}
| -------------------------------------------------------------------------------------
| SUB: CastWait
|--------------------------------------------------------------------------------------
    Sub CastWait(string WaitSpell)
        /if (${DebugCast}) /echo \atDEBUGCAST CastWait Enter \agLine#: ${Macro.CurLine}
        /if (${Spell[${WaitSpell}].CastTime}) {
			/delay 15 !${Me.Casting.ID}
            /while (${Me.Casting.ID}) {
                /delay 5
            }
        }
        /if (${DebugCast}) /echo \atDEBUGCAST CastWait Leave \agLine#: ${Macro.CurLine}
    /return    
| -------------------------------------------------------------------------------------
| SUB: CastAA
|--------------------------------------------------------------------------------------
    Sub CastAA(string WhatAA,int WhatID,int CastOnCorpse)
        /if (${DebugCast}) /echo \atDEBUGCAST CastAA Enter \agLine#: ${Macro.CurLine}
        /if (${Select[${WhatAA},Banestrike,15073]} && !${Banestrike.Find[|${Target.Race}|]} && ${Spawn[${MyTargetID}].Distance3D}>70 && ${CombatStart}) /return
        /alt act ${Me.AltAbility[${WhatAA}].ID}
        /call CastWait "${WhatAA}"
        /delay 5
        /if (${Me.AltAbilityReady[${WhatAA}]}) {
            /varset CastResult CAST_RECOVER
        } else {
            /varset CastResult CAST_SUCCESS
        }
        /if (${DebugCast}) /echo \atDEBUGCAST CastAA Leave \agLine#: ${Macro.CurLine}
    /return ${CastResult}
|--------------------------------------------------------------------------------------
| SUB: CastItem
|--------------------------------------------------------------------------------------
    Sub CastItem(string WhatItem,int WhatID,int CastOnCorpse)
        /if (${DebugCast}) /echo \atDEBUGCAST CastItem Enter \agLine#: ${Macro.CurLine}
        | Prevent casting of Prestige items on silver and F2P accounts
        /if (${Me.Subscription.NotEqual[gold]} && ${FindItem[=${WhatItem}].Prestige}) /return CAST_NO_RESULT
        /if (${IAmABard}) {
            /if (${DebugCast})  /echo \atDEBUGCAST I am a bard CastItem ${WhatItem} \agLine#: ${Macro.CurLine}
            /call CastBard "${WhatItem}" ${WhatID} CastItem
            /if (${DebugCast}) /echo \atDEBUGCAST ${Macro.Return} \agLine#: ${Macro.CurLine}
            /varset CastResult  ${Macro.Return}  
        } else {
            /useitem "${WhatItem}" 
            /delay 5
			/call DoCastingEvents 
            /while (${Me.Casting.ID}) {
                /delay 5
            }
            /call DoCastingEvents
            /varset CastResult ${castReturn}
           |  Assign cast success if item on cooldown or summoned item consumed
            /if (!${Me.ItemReady[=${WhatItem}]} || !${FindItem[=${WhatItem}].ID} && !${Select[${CastResult},CAST_IMMUNE,CAST_RESISTED]})  /varset CastResult CAST_SUCCESS
        }    
        /if (${DebugCast}) /echo \atDEBUGCAST CastItem Leave \agLine#: ${Macro.CurLine}
    /return ${CastResult}
|--------------------------------------------------------------------------------------
| SUB: CastDisc
|--------------------------------------------------------------------------------------
    Sub CastDisc(string WhatDisc,int WhatID,int CastOnCorpse)
        /declare WaitTimerCD timer local 
        /if (${DebugCast}) /echo \atDEBUGCAST CastDisc Enter \agLine#: ${Macro.CurLine}
            /if (!${Spell[${WhatDisc}].Duration} || (${Spell[${WhatDisc}].Duration} && ${Spell[${WhatDisc}].TargetType.Equal[Self]} && !${Me.ActiveDisc.ID}) || ${Spell[${WhatDisc}].TargetType.NotEqual[Self]} || ${Spell[${WhatDisc}].DurationWindow}) {
            /varset WaitTimerCD 30
            /while (${Me.CombatAbilityReady[${WhatDisc}]} && ${WaitTimerCD}) {
                /disc ${Me.CombatAbility[${Me.CombatAbility[${WhatDisc}]}].ID}
                /delay 5
            }
            /varset CastResult CAST_SUCCESS
        }
        /if (${DebugCast}) /echo \atDEBUGCAST CastDisc Leave \agLine#: ${Macro.CurLine}
    /return ${CastResult}  
|--------------------------------------------------------------------------------------
| SUB: CastCommand
|--------------------------------------------------------------------------------------
    Sub CastCommand(string WhatSkill,int WhatID,int CastOnCorpse)
        /if (${DebugCast}) /echo \atDEBUGCAST CastCommand Enter \agLine#: ${Macro.CurLine}
        /declare CommandText string local ${WhatSkill.Replace[command:,]}
        /if (${DebugCast}) /echo \atDEBUGCAST "${CommandText}" \agLine#: ${Macro.CurLine}
        /docommand ${CommandText}
        /delay 5 
        /varset CastResult CAST_SUCCESS
        /if (${DebugCast}) /echo \atDEBUGCAST CastCommand Leave \agLine#: ${Macro.CurLine}
    /return ${CastResult}    
|--------------------------------------------------------------------------------------
| SUB: CastSkill
|--------------------------------------------------------------------------------------
    Sub CastSkill(string WhatSkill,int WhatID,int CastOnCorpse)
        /if (${DebugCast}) /echo \atDEBUGCAST CastSkill Enter \agLine#: ${Macro.CurLine}
        /doability "${WhatSkill}"
        /delay 20 !${Me.AbilityReady[${WhatSkill}]}
        /if (!${Me.AbilityReady[${WhatSkill}]}) /varset CastResult CAST_SUCCESS
        /if (${DebugCast}) /echo \atDEBUGCAST CastSkill Leave \agLine#: ${Macro.CurLine}
    /return ${CastResult}
|--------------------------------------------------------------------------------------
| SUB: CastSpell
|--------------------------------------------------------------------------------------
    Sub CastSpell(string WhatSpell,int WhatID,string sentFrom,int CastOnCorpse)
        /if (${DebugCast}) /echo \atDEBUGCAST CastSpell Enter Line#: ${WhatSpell} ID:${WhatID} SentFrom:${sentFrom} ${Me.GemTimer[${WhatSpell}]} \agLine#: ${Macro.CurLine}
        /declare MaxTryNum int local 2
        /declare TryNum int local 0
        /if (${IAmABard}) {
            /call CastBard "${WhatSpell}" ${WhatID} CastSpell
            /return ${CastResult}  
        }
        /if (!${Target.CanSplashLand} && ${Spell[${WhatSpell}].TargetType.Equal[Free Target]}) {
           /echo Splash Spell will not cast at targets location. Skipping ${WhatSpell}
           /return CAST_NO_RESULT
        }
        /if (${Me.Gem[${WhatSpell}]}) {
            /while (1) {
                /if (${Me.GemTimer[${WhatSpell}]}==0 || ${Me.SpellReady[${WhatSpell}]}) {
                    /cast "${WhatSpell}"
                    /if (${DebugCast}) /echo \atDEBUGCAST CastSpell cast "${WhatSpell}" \agLine#: ${Macro.CurLine}
                    /call DoCastingEvents
                    /if (${DebugCast}) /echo \atDEBUGCAST CastSpell Return from DoCastingEvents 1 CastResult: ${CastResult} \agLine#: ${Macro.CurLine}
                    /varcalc TryNum ${TryNum}+1
                    /while (${Me.Casting.ID} && ${Window[CastingWindow].Open} && ${CastResult.NotEqual[CAST_CANCELLED]}) {
                        /if (${CastingInterruptOn}) {
                            /if (${DebugCast}) /echo \atDEBUGCAST CastSpell ENTER Interrupts SentFrom ${sentFrom} Spell:${WhatSpell} CastID:${Me.Casting.ID} \agLine#: ${Macro.CurLine}
                            /if (${sentFrom.Equal[SingleHeal]}) {
                               /call CastInteruptHeals "${WhatSpell}"
                            } else /if (${Select[${sentFrom},dps,gom,burn]}>0) {
                               /call CastInteruptDPS "${WhatSpell}"
                            } else /if (${Select[${sentFrom},buffs,buffs-nomem]}>0) {
                               /call CastInteruptBuffs "${WhatSpell}"
                            }
                            /if (${DebugCast}) /echo \atDEBUGCAST CastSpell LEAVE Interrupts SentFrom ${sentFrom} \agLine#: ${Macro.CurLine}    
                        }
                        /doevents YouHit
                        /doevents YourPetHit
                    }
                   /call DoCastingEvents 5
                   /if (${DebugCast}) /echo \atDEBUGCAST CastSpell Return from DoCastingEvents 2 CastResult: ${CastResult} \agLine#: ${Macro.CurLine}
                   /if (${CastResult.Equal[CAST_CANCELLED]} || ${castReturn.Equal[x]}) /break
                   /varset CastResult ${castReturn} 
                }
                |Don't change this it has to be PullAggroTargetID or you break ChainPulling.
                /if (${sentFrom.Equal[Pull]} && ${PullAggroTargetID}) /return CAST_SUCCESS 
                /if (${TryNum}<${MaxTryNum} && ${Select[${CastResult},CAST_FIZZLE,CAST_INTERRUPTED,CAST_RESISTED]}) {
                    /if  (${Spell[${WhatSpell}].RecastTime.TotalSeconds}<=2) {
                        /while (${Me.GemTimer[${WhatSpell}]} && !${Me.SpellReady[${WhatSpell}]}) { 
                            /delay 5
                        }
                    } else {
                        /break
                    }
                } else {
                    /break
                }
            }   
        } else {
            /echo Skip Casting ${WhatSpell}. Spell Not Memed.
            /varset CastResult CAST_NO_RESULT
        }
        /if (${DebugCast}) /echo \atDEBUGCAST CastSpell Leave ${Me.GemTimer[${WhatSpell}]} ${CastResult} \agLine#: ${Macro.CurLine}
    /return  ${CastResult}  
| ----------------------------------------------------------------------------
| SUB: Cast DPS Spell Check ${Spell[${Spell[Gift of T'Vem].ID}].RecastTime}
| ----------------------------------------------------------------------------        
    Sub CastDPSSpellCheck(SpellToCheck)  
        /if (${DebugCast}) /echo \atDEBUGCAST DPSSpellCheck \awEnter \agLine#: ${Macro.CurLine}
        /declare i int local 0
        /declare k int local 0
        /for i 1 to 85
            /if (${Target.Buff[${i}].ID}==0) /break
            /if (${DebugCast}) /echo \atDEBUGCOMBAT DPSSpellCheck \aw ${i} ${Target.Buff[${i}].Name} ${Int[${Target.Buff[${i}].ID}]}==${Spell[${SpellToCheck}].ID} ${Target.Buff[${i}].Caster} ${Spell[${SpellToCheck}].NumEffects} \agLine#: ${Macro.CurLine}
            /if (${Target.Buff[${i}].ID}==${Spell[${SpellToCheck}].ID} && ${Target.Buff[${i}].Caster.Equal[${Me}]}) {
                /if (${DebugCast}) /echo \atDEBUGCOMBAT DPSSpellCheck ${Target.Buff[${i}].Name} is already on the target. \agLine#: ${Macro.CurLine}
                /return TRUE
            }
            /if (${Spell[${SpellToCheck}].HasSPA[470]}==TRUE) {
                /for k 1 to ${Spell[${SpellToCheck}].NumEffects} 
                    /if (${Spell[${SpellToCheck}].Attrib[${k}]}==470) {
                        /if (${DebugCast}) /echo \atDEBUGCOMBAT DPSSpellCheck ${k} ${Target.Buff[${i}].ID}==${Spell[${SpellToCheck}].Trigger[${k}].ID} ${Target.Buff[${i}].Name}==${Spell[${SpellToCheck}].Trigger[${k}].Name} && ${Target.Buff[${i}].Caster.Equal[${Me}]} 
                        /if (${Target.Buff[${i}].ID}==${Spell[${SpellToCheck}].Trigger[${k}].ID} && ${Target.Buff[${i}].Caster.Equal[${Me}]}) {
                            /if (${DebugCast}) /echo \atDEBUGCOMBAT DPSSpellCheck The spell ${SpellToCheck}triggers ${Spell[${SpellToCheck}].Trigger[${k}].Name} is already on the target. \agLine#: ${Macro.CurLine}
                            /return TRUE
                        }
                    }
                /next k
            }
        /next i
        /if (${DebugCast}) /echo \atDEBUGCAST DPSSpellCheck \awLeave \agLine#: ${Macro.CurLine}
    /return FALSE  
| ----------------------------------------------------------------------------
| SUB: Cast Buffs Spell Check
| ----------------------------------------------------------------------------        
    Sub CastBuffsSpellCheck(SpellToCheck)
        /if (${DebugCast}) /echo \atDEBUGCAST CastBuffsSpellCheck \awEnter \agLine#: ${Macro.CurLine}    
        /declare i int local
        /declare k int local
        /delay 5s ${Target.BuffsPopulated}==TRUE
        /for i 1 to 85
            | Check if target buff exists
            /if (${Target.Buff[${i}].Name.Length}) {
                | Does buff have children spells like Unified Hand of Assurance or Talisman of the Wulthan
                /if (${Spell[${SpellToCheck}].HasSPA[374]} || ${Spell[${SpellToCheck}].HasSPA[340]} ) {
                    /if (${DebugCast}) /echo \at${i}  ${Target.Buff[${i}].Name}  ${Target.Buff[${i}].Caster} 
                    | Scroll thru children spells according to number of effects
                    /for k 1 to ${Spell[${SpellToCheck}].NumEffects} 
                        | Double check spell attrib to make sue it has children spells
                        /if (${Spell[${SpellToCheck}].Attrib[${k}]} == 374 || ${Spell[${SpellToCheck}].Attrib[${k}]} == 340) {
                            | If child spell is already on target skip
                            /if (${Target.Buff[${i}].ID}==${Spell[${SpellToCheck}].Base2[${k}]}) {
                                /if (${DebugCast}) /echo \at${i} ${k} BuffSpellCheck: The spell ${Spell[${Spell[${SpellToCheck}].Base2[${k}]}].Name} is already on the target. \agLine#: ${Macro.CurLine}
                                /return TRUE
                            | If child spell doesn't stack with target buff skip
                            } else /if (!${Spell[${Spell[${SpellToCheck}].Base2[${k}]}].WillStack[${Target.Buff[${i}]}]}) {
                                /if (${DebugCast}) /echo \at${i} ${k} BuffSpellCheck: The spell ${Spell[${Spell[${SpellToCheck}].Base2[${k}]}].Name} does not stack with ${Target.Buff[${i}].Name} on the target. \agLine#: ${Macro.CurLine}
                                /return TRUE
                            }
                        }
                    /next k
                | If spell is already on target skip    
                } else /if (${Target.Buff[${i}].ID}==${Spell[${SpellToCheck}].ID}) {
                    /if (${DebugCast}) /echo \at The spell ${SpellToCheck} is already on the target. \agLine#: ${Macro.CurLine}
                    /return TRUE
                |If  spell doesn't stack with target buff skip    
                } else /if (!${Spell[${SpellToCheck}].WillStack[${Target.Buff[${i}]}]}) {
                    /if (${DebugCast}) /echo \at${i} The spell ${SpellToCheck} does not stack with ${Target.Buff[${i}].Name} on the target. \agLine#: ${Macro.CurLine}
                    /return TRUE
                }
            }            
        /next i
        /if (${DebugCast}) /echo \atDEBUGCAST CastBuffsSpellCheck \awLeave \agLine#: ${Macro.CurLine} 
    /return FALSE
| -------------------------------------------------------------------------------------
| SUB: Cast Weave
| -------------------------------------------------------------------------------------    
    Sub CastWeave(TarID)
        /if (${DebugCast}) /echo \atDEBUGCAST CastWeave \awEnter \agLine#: ${Macro.CurLine} 
        /declare i int local
        /declare DPSat1 int Local 0
        /declare DPSWeaveDelay timer local 2
        /declare DPSWeaveSpell string local
        /declare DPSWeaveArg3 string local         
        /declare DPSWeaveArg4 string local     
        /for i 1 to ${WeaveArray.Size}
            /varset DPSat1 ${Int[${WeaveArray[${i}].Arg[2,|]}]}
            /varset DPSWeaveSpell ${WeaveArray[${i}].Arg[1,|]}
            /if (${Debug}) /echo \at Cast DPSWeaveSpell:(${DPSWeaveSpell}) at (${DPSat1}%) ${i} \agLine#: ${Macro.CurLine}
            /if (${DPSat1}==0 || !${TarID} || ${Spawn[${TarID}].Type.Equal[corpse]}) /return 
            /if (${DPSat1}<${Spawn[${TarID}].PctHPs}) /continue
            /if (!${ConOn} || !${WeaveArray[${i}].Find[|cond]} || ${If[${Cond[${WeaveArray[${i}].Mid[${Math.Calc[${WeaveArray[${i}].Find[|cond]}+5]},3]}]},1,0]}) {
            /if (${Me.AltAbilityReady[${WeaveArray[${i}].Arg[1,|]}]} || ${Me.ItemReady[${WeaveArray[${i}].Arg[1,|]}]} || ${Me.CombatAbilityReady[${WeaveArray[${i}].Arg[1,|]}]} || ${Me.AbilityReady[${WeaveArray[${i}].Arg[1,|]}]}) {
                    /call CastWhat "${DPSWeaveSpell}" ${TarID} WeaveStuff 0 0
                /while (${DPSWeaveDelay}) {
                    /doevents
                }
                /if (${Macro.Return.Equal[CAST_SUCCESS]})  {
                    /echo -- Weaving: ${DPSWeaveSpell}
                    /return 1
                }
            } 
            }
        /next i
        /if (${DebugCast}) /echo \atDEBUGCAST CastWeave \awLeave \agLine#: ${Macro.CurLine} 
    /return 0    
|--------------------------------------------------------------------------------------
| SUB: CastBard
|--------------------------------------------------------------------------------------
    Sub CastBard(string BardSpell,int WhatID,string sentFrom,int CastOnCorpse)
        | Bard song with long refresh is not ready so return and do not interupt twisting.
        /if (${Me.GemTimer[${BardSpell}]}>=1 && ${Me.Book[${BardSpell}]}) /return
        /if (${DebugCast}) /echo \atDEBUGCAST CastBard \awEnter ${BardSpell} ${WhatID} ${sentFrom} ${CastResult} \agLine#: ${Macro.CurLine}
        /varset WasTwisting ${Twist}
        /while (${Me.BardSongPlaying}) {
            /if (${Twist}) /squelch /twist off
            /stopsong
            /delay 30 !${Twist}
        }
        /if (${Target.ID}!=${WhatID} && ${Spawn[id ${WhatID}].ID}) /call CastTarget ${WhatID}
        /if (${FindItem[=${BardSpell}].ID}) {
            /if (${Debug}) /echo I am a bard CastBard ${BardSpell}
            /useitem "${BardSpell}"
            /delay 5
            /while (${Me.Casting.ID}==${FindItem[=${BardSpell}].Spell.ID}) {
                /delay 5
            }
            /call DoCastingEvents 
            /varset CastResult ${castReturn}  
        } else /if (${Me.GemTimer[${BardSpell}]}==0 && ${Me.Book[${BardSpell}]}) {
            /delay 2 
            /squelch /twist once ${Me.Gem[${BardSpell}]}
            /delay 30
            /varset CastResult CAST_SUCCESS
        }
        /if (${WasTwisting} && !${Twist}) /squelch /twist 
        /if (${DebugCast}) /echo \atDEBUGCAST CastBard \awLeave ${BardSpell} ${WhatID} ${sentFrom}  ${CastResult}  \agLine#: ${Macro.CurLine}
    /return ${CastResult}     
|--------------------------------------------------------------------------------------
| SUB: CastTarget
|--------------------------------------------------------------------------------------
    Sub CastTarget(int CTWhatID)
        /if (${DebugCast}) /echo \atDEBUGCAST CastTarget Enter \aw ID:${CTWhatID} Target:${Spawn[id ${CTWhatID}].CleanName} \agLine#: ${Macro.CurLine}
        /squelch /target clear
        /delay 10 !${Target.ID}
        /squelch /target id ${CTWhatID}
        /delay 10 ${Target.ID}==${CTWhatID}
        /if (${DebugCast}) /echo \atDEBUGCAST CastTarget Leave \agLine#: ${Macro.CurLine}
    /return  
|--------------------------------------------------------------------------------------
| SUB: CastMem
|--------------------------------------------------------------------------------------
    Sub CastMem(string WhatMemSpell,string sentFrom)
        /declare WaitTimerCM timer local 0
        /if (${DebugCast}) /echo \atDEBUGCAST CastMem Enter \agLine#: ${Macro.CurLine}
        | Prevent tanks and heals trying to mem spells during combat.
        /if ((${Attacking} && ${MainAssist.Equal[${Me}]}) || (${HealsOn} && ${AggroTargetID} && ${sentFrom.NotEqual[Heal]} && !${Me.Mount.ID})) {
            /echo Cannot mem a spell (Spell: ${WhatMemSpell}; SentFrom: ${sentFrom}) durring combat or while you have aggro.
            /return notready
        }
        /if (${Cursor.ID}) /call CheckCursor CastMem
        /if (${Spell[${WhatMemSpell}].Mana}>${Me.CurrentMana}) /return notready
        /if (${IAmABard}) {
            /varset WasTwisting ${Twist}
            /while (${Me.BardSongPlaying}) {
				/if (${DebugFramework}) /Echo Current Line ${Macro.CurLine}
                /if (${Twist}) /squelch /twist off
                /stopsong
                /delay 10
            }
        }
        /if (${MiscGemRemem} && ${MiscGemLW} && ${Spell[${WhatMemSpell}].RecastTime.TotalSeconds}>30 && ${ReMemWaitLong.Equal[null]}) {
           /varset ReMemWaitLong ${WhatMemSpell}
           /varset DontMoveMe 1
           /call CastMemSpell "${WhatMemSpell}" ${MiscGemLW} 0 CastMem
           /varset DontMoveMe 0
           /return notready
        }
        /varset ReMemWaitShort ${WhatMemSpell}
        /varset DontMoveMe 1
        /call CastMemSpell "${WhatMemSpell}" ${MiscGem} 0 CastMem
        /varset DontMoveMe 0
        /if (${Me.Gem[${WhatMemSpell}]}) {
            /varset WaitTimerCM 350
            /while (!${Me.SpellReady[${WhatMemSpell}]} && ${WaitTimerCM}) {
				/if (${DebugFramework}) /Echo Current Line ${Macro.CurLine}
                /delay 5
            }
            /delay 10
        }
        /if (${IAmABard}) {
            /if (${WasTwisting} && !${Twist}) /squelch /twist
        }
        /if (!${Me.Gem[${WhatMemSpell}]}) /return notready
        /if (${DebugCast}) /echo \atDEBUGCAST CastMem Leave \agLine#: ${Macro.CurLine}
   /return 0
|--------------------------------------------------------------------------------------
| SUB: CastReMem
|--------------------------------------------------------------------------------------
    Sub CastReMem(string WhatMemSpell,string sentFrom)
        /if (${DebugCast}) /echo \atDEBUGCAST CastTarget Enter \agLine#: ${Macro.CurLine}
        |We need to check if the spell just cast was swaped out and other spell needs to bo rememed.
        |Need a way to carry a flag so remem will be done out of combat after the spell has been cast.
        /if (${CastResult.Equal[CAST_SUCCESS]}) {
            |Is it the MiscGem?
            /if (${WhatMemSpell.Equal[${ReMemWaitShort}]}) {
                /varset ReMemCast 1
            |Is it the MiscGemLW
            } else /if (${WhatMemSpell.Equal[${ReMemWaitLong}]}) {
                /varset ReMemCastLW 1
            }
        }
        /if (${MiscGemRemem}==1 || ${MiscGemRemem}==2) {
            /if (!${Me.Gem[${ReMemMiscSpell}]} && ${ReMemCast} && !${CombatStart} && !${Me.Buff[Resurrection Sickness].ID} && !${sentFrom.Find[-nomem]}) {
                /if (${Cursor.ID}) /call CheckCursor CastReMem
                /varset DontMoveMe 1
                /call CastMemSpell "${ReMemMiscSpell}" ${MiscGem} 0 CastReMem
                /varset DontMoveMe 0
                /varset ReMemCast 0
                /varset ReMemWaitShort null
            }
        }
        |Remem spell originally in Long Wait Gem slot
        /if ((${MiscGemRemem}==1 || ${MiscGemRemem}==3) && ${MiscGemLW} && ${ReMemWaitLong.NotEqual[null]}) {
            /if (${ReMemCastLW} && !${Me.Buff[Resurrection Sickness].ID}) {
                /if (${Cursor.ID}) /call CheckCursor CastReMem2
                /varset DontMoveMe 1
                /call CastMemSpell "${ReMemMiscSpellLW}" ${MiscGemLW} ${Int[${Me.Gem[${ReMemMiscSpellLW}]}]} CastReMem
                /varset DontMoveMe 0
                /varset ReMemCastLW 0
                /varset ReMemWaitLong null
            }
        }
        /if (${DebugCast}) /echo \atDEBUGCAST CastTarget Leave \agLine#: ${Macro.CurLine}
    /return
|--------------------------------------------------------------------------------------
| SUB: CastMemSpell
|--------------------------------------------------------------------------------------
    Sub CastMemSpell(SpellToMem, int gemNum, int ForceIt, string sentFrom)
        /if (${DebugCast}) /echo \atDEBUGCAST CastMemSpell Enter \agLine#: ${Macro.CurLine}
        /if (${Int[${SpellToMem.Length}]}==0 || ${SpellToMem.Equal[null]} || ${gemNum}==0) /return

        /if (${Int[${Me.Gem[${SpellToMem}]}]}>0 && !${ForceIt}) /return
        | Unmem a spell if already memmed in a diffent gem
        /if (${ForceIt}) {
            /if (${Int[${Me.Gem[${SpellToMem}]}]}>0 && ${gemNum}!=${ForceIt}) {
                /notify CastSpellWnd CSPW_Spell${Int[${Math.Calc[${ForceIt}-1]}]} rightmouseup
                /delay 20 ${Int[${Me.Gem[${gemNum}].ID}]}==0
            }
        }
        /if (${Me.Book[${SpellToMem}]}) {
            /if (${Int[${Me.Gem[${gemNum}].ID}]}>0) {
                /notify CastSpellWnd CSPW_Spell${Int[${Math.Calc[${gemNum}-1]}]} rightmouseup
                /delay 20 ${Int[${Me.Gem[${gemNum}].ID}]}==0
            }
            /if (!${Int[${Me.Gem[${gemNum}].Name.Length}]} || ${Me.Gem[${gemNum}].Name.NotEqual[${SpellToMem}]}) {
                /while (${Me.Moving}) {
					/if (${DebugFramework}) /Echo Current Line ${Macro.CurLine}
                    /delay 5
                }
                /echo Memming ${SpellToMem} in slot ${gemNum}
                /if (${Stick.Active}) {
                    /stick pause 
                    /MemSpell ${gemNum} "${SpellToMem}"
                    /delay 150 ${Me.Gem[${gemNum}].Name.Equal[${SpellToMem}]} 
                    /stick unpause
                } else {
                    /MemSpell ${gemNum} "${SpellToMem}"
                    /delay 150 ${Me.Gem[${gemNum}].Name.Equal[${SpellToMem}]} 
                }
            }
        } else {
            /echo Could Not find the spell ${SpellToMem} in your spell book.
        }
        /if (${Window[SpellBookWnd].Open}) /windowstate spellbookwnd close
        /if (${DebugCast}) /echo \atDEBUGCAST CastMemSpell ${SpellToMem} ${gemNum} ${ForceIt} ${sentFrom} \agLine#: ${Macro.CurLine}
        /if (${DebugCast}) /echo \atDEBUGCAST CastMemSpell Leave \agLine#: ${Macro.CurLine}
    /return   
|--------------------------------------------------------------------------------------
| SUB: CastInteruptHeals
|--------------------------------------------------------------------------------------   
    Sub CastInteruptHeals(string CIHSpell)
       /if (${DebugCast}) /echo \atDEBUGCAST CastInteruptHeals Enter \agLine#: ${Macro.CurLine}
       /if (!${Int[${Me.Casting.ID}]}) /return
       | Check heal target is not an npc unless spell is detrimenatl like a tap or nuke type heal
       /if (${Target.Type.Equal[npc]} && ${Spell[${CIHSpell}].SpellType.NotEqual[Detrimental]}) {
            /stopcast
            /varset CastResult CAST_CANCELLED
            /echo ${CIHSpell} interrupted. Target is an NPC
            /if (${DebugCast}) /echo \atDEBUGCAST CastInteruptHeals  CheckHP1: ${Target.Type} \agLine#: ${Macro.CurLine}
        }
        | Override default heal interupts if caster MA and has his own healing set. ie pally or sk
       /if (${Target.Type.NotEqual[npc]} && (${Target.PctHPs}==100 || ${Spawn[${Target}].Type.Equal[Corpse]}) && !${CIHSpell.Find[promised]}) { 
            /stopcast
            /varset CastResult CAST_CANCELLED
            /echo ${CIHSpell} interrupted. Target is above required ${SHealPct}% health. ${Target}
            /if (${DebugCast}) /echo \atDEBUGCAST CastInteruptHeals CheckHP2: ${Target.PctHPs} ${SHealPct} \agLine#: ${Macro.CurLine}
       }
       /if (${DebugCast}) /echo \atDEBUGCAST CastInteruptHeals Leave \agLine#: ${Macro.CurLine}
    /return    
|--------------------------------------------------------------------------------------
| SUB: CastInteruptDPS
|--------------------------------------------------------------------------------------
    Sub CastInteruptDPS(string CIDSpell)
        /if (${DebugCast}) /echo \atDEBUGCAST CastInteruptDPS Enter \agLine#: ${Macro.CurLine}
        /if (!${Int[${Me.Casting.ID}]}) /return
        /if (${Target.Type.Equal[pc]}) /return
        /if (${Target.PctHPs}<1 || ${Target.Type.Equal[corpse]} || !${Int[${Target.ID}]}) {
            /stopcast
            /varset CastResult CAST_CANCELLED
            /echo ${CIDSpell} interrupted due to Killing corpses is not required.
            /if (${DebugCast}) /echo \atDEBUGCAST CastInteruptDPSCheckDPS1: ${Target.PctHPs} ${Target.Type} ${Int[${Target.ID}]} \agLine#: ${Macro.CurLine}
        }
        /if (${HealsOn}) {
            /if (${MainAssist.NotEqual[${Me}]} &&  ${Spawn[${MainAssist}].PctHPs}<70 && ${Spawn[${MainAssist} ${MainAssistType}].ID} && ${Spawn[${MainAssist} ${MainAssistType}].Type.NotEqual[corpse]}) {
                /stopcast
                /varset CastResult CAST_CANCELLED
                /echo ${CIDSpell} interrupted due to The Main Assist Needs a Heal.
                /if (${DebugCast}) /echo \atDEBUGCAST CastInteruptDPS CheckDPS2: ${HealsOn}  ${Spawn[${MainAssist}].PctHPs} ${Spawn[${MainAssist} ${MainAssistType}].ID}  ${Spawn[${MainAssist} ${MainAssistType}].Type} \agLine#: ${Macro.CurLine}
            } else /if (${Select[${Role},pettank,petpullertank,hunterpettank]}>0 && ${Me.Pet.ID} && ${Me.Pet.PctHPs}<80) {
                /stopcast
                /varset CastResult CAST_CANCELLED
                /echo ${CIDSpell} interrupted due to my Pet Tank needs a heal.
                /if (${DebugCast}) /echo \atDEBUGCAST CastInteruptDPS CheckDPS3: ${HealsOn}  ${Me.Pet.ID} ${Me.Pet.PctHPs} \agLine#: ${Macro.CurLine}
            }
        }
        /if (${DebugCast}) /echo \atDEBUGCAST CastInteruptDPS Leave \agLine#: ${Macro.CurLine}
    /return
|--------------------------------------------------------------------------------------
| SUB: CastInteruptBuffs
|--------------------------------------------------------------------------------------
    Sub CastInteruptBuffs(string CIBSpell)
        /if (${DebugCast}) /echo \atDEBUGCAST CastInteruptBuffs Leave \agLine#: ${Macro.CurLine}
        /if (!${Me.Casting.ID}) /return
        /if (${Me.Casting.Range}==0 && ${Me.Casting.AERange}==0) /return
        /if ((${Target.ID} && ${Target.PctHPs}<1) || (${Target.Type.Equal[corpse]})) {
            /stopcast
            /varset CastResult CAST_CANCELLED
            /echo ${CIBSpell} interrupted because target dead or not valid.
            /if (${DebugCast}) /echo \atDEBUGCAST CheckBUFFS2: ${Int[${Target.PctHPs}]} ${Target.Type}  ${Int[${Target.ID}]} ${Me.Casting} ${Me.Casting.TargetType} \agLine#: ${Macro.CurLine}
        }
        /if ((${Me.Casting.Range}>0 && ${Target.Distance}>${Me.Casting.Range}) || (${Me.Casting.AERange}>0 && ${Target.Distance}>${Me.Casting.AERange})) {
            /stopcast
            /varset CastResult CAST_CANCELLED
            /echo ${CIBSpell} interrupted because target out of range.
            /if (${DebugCast}) /echo \atDEBUGCAST CheckBUFFS3: ${Int[${Me.Casting.ID}]}  ${Target.Distance} ${Me.Casting.Range} ${Me.Casting.AERange} ${Me.Casting} \agLine#: ${Macro.CurLine}
        }
        /if (${DebugCast}) /echo \atDEBUGCAST CastInteruptBuffs Leave \agLine#: ${Macro.CurLine}
    /return       
|*****************************************************************************************************************************************|    
| -------------------------------------------------------------------------------------
| SUB: Do We Move
| -------------------------------------------------------------------------------------
    Sub DoWeMove(int ForceToCamp, SentFrom)
        /if (!${ReturnToCamp} && !${ForceToCamp}) /return
        /declare StuckCount int local 0 
        /declare X1 int local
        /declare Y1 int local
        /declare scatterDistance int local
        /declare CampYRandom int local
        /declare CampXRandom int local
        /doevents
        /call EndMacroIf
        /declare DWMWPCurrent int local 0
        /declare DWMTimer timer local 30s
        /if (${Target.ID} && ${Target.Type.Equal[npc]}) {
            /varcalc ZDist ${Math.Distance[${Target.Z}:${Me.Z}]}-(${Target.Height}-${Me.Height})
        }
        /declare circleDirection string local
        /if (${Debug}) /echo \atDEBUG DoWeMove: Enter \agLine#: ${Macro.CurLine}
        | - Shuts off ReturnToCamp if a toon moves a big distance defined by CampRadiusExceed ie CoH !${Pulled} || ${Pulling}
            /if (${DebugMove}) /echo \atDEBUG DoWeMove:(ReturnToCamp) My distance from camp is: (${Math.Distance[${CampYLoc},${CampXLoc}]}). \agLine#: ${Macro.CurLine}
            /if (${Math.Distance[${CampYLoc},${CampXLoc}]} > ${CampRadiusExceed} && !${Role.Find[hunter]} && ${ReturnToCamp}==1 && ${CampZone}==${Zone.ID} ) {
                /if (${DebugMove}) /echo \atDEBUG DoWeMove:(ReturnToCamp) CampRadiusExceed turning off ReturnToCamp. \agLine#: ${Macro.CurLine}
                /varset ReturnToCamp 0
                /echo Leashing exceeded distance of ${CampRadiusExceed} turning off ReturnToCamp
                /return
            }
            /if (${Math.Distance[${CampYLoc},${CampXLoc}]} > 12 && ${CampZone}==${Zone.ID}) {
                /if (${DebugMove}) /echo \atDEBUG DoWeMove:(ReturnToCamp) Distance to camp > 10 and no adds in camp. ${Math.Distance[${CampYLoc},${CampXLoc}]} ${CampRadius} ${Medding} \agLine#: ${Macro.CurLine}
                | Prevent puller roles from returning to camphere spot and just pull from where they are if in camp radius.
                /if (${Select[${Role},puller,pullertank,pullerpettank]} && ${Math.Distance[${CampYLoc},${CampXLoc}]}<=${CampRadius} && !${ForceToCamp} && !${Medding}) /return
                /if (${Select[${Role},puller,pullertank,pullerpettank,hunter,hunterpettank]} && ${Math.Distance[${CampYLoc},${CampXLoc}]} > 15) {
                    |---------------------------------------------- MQ2Nav ---------------------------------------------------------------------|
                    /if (${PullMoveUse.Equal[nav]}) {
                        /if (${Math.Distance[${CampYLoc},${CampXLoc}]} > ${CampRadius})  {
                            /if (${DebugMove}) /echo \atDEBUG DoWeMove:(ReturnToCamp) Distance to camp > 15, MQ2Nav return to camp. \agLine#: ${Macro.CurLine}
                            /while (1) {
								/if (${DebugFramework}) /Echo Current Line ${Macro.CurLine}
                                /doevents
                                /if (${IAmDead} || ${Me.Hovering}) {
                                    /if (${Navigation.Active}) /nav stop
                                    /return
                                }
                                /if (!${Me.Mount.ID} && ${Me.Sitting}) /stand
                                /nav locxyz ${CampXLoc} ${CampYLoc} ${CampZLoc}
                                /if (${Me.Mount.ID} && ${Math.Distance[${CampYLoc},${CampXLoc}]} <= 75 ) {
                                    /echo MQ2Nav does not work well with mounts. Dismounting.
                                    /dismount
                                }
                                /while (1) {
									/if (${DebugFramework}) /Echo Current Line ${Macro.CurLine}
                                    /varset X1 ${Int[${Me.X}]}
                                    /varset Y1 ${Int[${Me.Y}]}   
                                    | PullerPetTank - send in pet to attack on my way back to camp if not too far from camp.
                                    /if (${Select[${Role},pullerpettank]} && ${Pulled}) {
                                        /if (${Math.Distance[${Me.Pet.Y},${Me.Pet.X}:${CampYLoc},${CampXLoc}]}<=${PetAttackRange}) {
                                            /call CombatPet
                                        } else {
                                            /pet back off
                                        }
                                    }     
                                    /delay 10
                                    | Check for getting stuck on geometry
                                    /if (!${Me.Stunned} && !${Me.Feigning}) {
                                        /if (${Int[${Me.X}]}==${X1} && ${Int[${Me.Y}]}==${Y1}) {
                                            /varcalc StuckCount (${StuckCount})+1
                                            /if (${StuckCount}>=3) {
                                                /if (${Navigation.Active}) /nav stop
                                                /call Stuck DoWeMove
                                                /varset StuckCount 0
                                                /break
                                            }
                                            }
                                    } else /if (${Me.Stunned}) {
                                        /while (${Me.Stunned}) {
											/if (${DebugFramework}) /Echo Current Line ${Macro.CurLine}
                                            /delay 2
                                        }                                
                                        /break
                                    }
                                    /if (${DebugMove}) /echo \atDEBUG DoWeMove: Distance to camp ${Math.Distance[${CampYLoc},${CampXLoc}]} >= ${CampRadius} Timer: ${DWMTimer} \agLine#: ${Macro.CurLine}
                                    /if (!${Navigation.Active} || !${DWMTimer}) /break
                                }
                                /if (${Math.Distance[${CampYLoc},${CampXLoc}]} < 16) /break
                            }
                        }
                    |---------------------------------------------- MQ2AdvPath ---------------------------------------------------------------------|
                    } else /if (${PullPathWpCount} && ${PullMoveUse.Equal[advpath]}) {
                        /if (${MoveTo.Moving}) /moveto off
                        /play ${PullPath} reverse nodoor smart
                        /if (${DebugMove}) /echo \atDEBUG DoWeMove: /play ${PullPath} reverse nodoor smart \agLine#: ${Macro.CurLine}
                        /while (1) {
							/if (${DebugFramework}) /Echo Current Line ${Macro.CurLine}
                            /doevents
                            /if (${IAmDead} || ${Me.Hovering}) {
                                /if (${PullMoveUse.Equal[advpath]}) {
                                    /if (${AdvPath.State}) /play off
                                }
                                /return
                            }
                            /delay 5
                            /varset DWMWPCurrent ${AdvPath.NextWaypoint}
                            /if (${DebugMove}) /echo \atDEBUG DoWeMove: ReturnToCamp WP#: ${DWMWPCurrent} ${MoveTo.Moving} \agLine#: ${Macro.CurLine}
                            /if (${AdvPath.State}==2 && ${Me.Moving} && ${DWMTimer}<10) /varset DWMTimer 10
                            /if (${DWMWPCurrent}<2 || ${DWMTimer}==0) /break
                        }
                        /if (${AdvPath.State}) /play off
                    } 
                } 
                |------------------------------------------------ MoveTo -----------------------------------------------------------------------|
                /if (${DebugMove}) /echo \atDEBUG DoWeMove: Distance to camp ${Math.Distance[${CampYLoc},${CampXLoc}]} > 15, MQ2MoveUtils return to camp. \agLine#: ${Macro.CurLine}
                /doevents
                /if (!${Me.FeetWet}) /look 0
                /moveto dist 10     
                /if (${ScatterOn}) {
                    | Randomize camp x,y by +- so toons don't always retun to exact same spot and help to look less botted.
                    /varcalc scatterDistance ${Math.Rand[7]}+5
                    /if (${Math.Rand[2]}) {
                        /varcalc CampYRandom ${CampYLoc}-${scatterDistance}
                    } else {
                        /varcalc CampYRandom ${CampYLoc}+${scatterDistance}
                    }  
                    /if (${Math.Rand[2]}) {
                        /varcalc CampXRandom ${CampXLoc}-${scatterDistance}
                    } else {
                        /varcalc CampXRandom ${CampXLoc}+${scatterDistance}
                    }
                } else {
                   /varset CampYRandom ${CampYLoc}
                   /varset CampXRandom ${CampXLoc}
                }                
                /if (${DebugMove}) /echo \atDEBUG DoWeMove: Camp Location Info: ScatterOn: ${ScatterOn} YRandom: ${CampYRandom} XRandom: ${CampXRandom} ${IAmDead} ${Me.Hovering} \agLine#: ${Macro.CurLine}
                /while (1) {
					/if (${DebugFramework}) /Echo Current Line ${Macro.CurLine}
                    /if (${IAmDead} || ${Me.Hovering}) {
                        /moveto off
                        /return
                    }
                    /if (!${Me.Mount.ID} && ${Me.Sitting} && ${Math.Distance[${CampYLoc},${CampXLoc}]} >= 16) /stand
                    /if (!${Me.Moving} || !${MoveTo.Moving}) {
                        /if (${Me.FeetWet}) {
                            /moveto set useback off
                            /moveto loc ${CampYRandom} ${CampXRandom} ${CampZLoc} uw mdist 15
                        } else {
                            /moveto set useback on
                            /moveto loc ${CampYRandom} ${CampXRandom} ${CampZLoc} 
                        }
                    }
                    /if (${Select[${Role},pullerpettank]} && ${Pulled}) {
                        /if (${Math.Distance[${Me.Pet.Y},${Me.Pet.X}:${CampYLoc},${CampXLoc}]}<=${PetAttackRange}) {
                            /call CombatPet
                        } else {
                            /pet back off
                        }
                    }     
                    /delay 10
                    /if ((!${MoveTo.Moving} && !${Me.Moving}) || ${DWMTimer}==0) /break
                    /if (${DebugMove}) /echo \atDEBUG DoWeMove: MoveTo My distance from Camp is: ${Math.Distance[${CampYRandom},${CampXRandom},${CampZLoc}]} ${Me.FeetWet}. \agLine#: ${Macro.CurLine}
                    /if (!${MoveTo.Moving} || ${Math.Distance[${CampYRandom},${CampXRandom},${CampZLoc}]} < 16) /break
                }
                /if (${Me.FeetWet} && ${Math.Distance[${CampYRandom},${CampXRandom},${CampZLoc}]} >= 15) {
                    /varset DWMTimer 20
                    /moveto loc ${CampYRandom} ${CampXRandom} ${CampZLoc} uw mdist 15
                    /while (${Math.Distance[${CampYRandom},${CampXRandom},${CampZLoc}]} > 15 && ${DWMTimer}) {
                        /if (${DebugFramework}) /Echo Current Line ${Macro.CurLine}
						/delay 5
                    }
                    /if (${MoveTo.Moving}) /moveto off
                }
                /delay 20 !${Me.Moving}
                | Move down if Z distance more than 3 due to levitation
                /if (${Target.ID} && ${Select[${Target.Type},npc,corpse]})  /call ZAxisCheck ${ZDist} 3.1
                /if (!${AggroTargetID} && !${CombatStart} || ${Select[${Role},pullertank,puller,pullerpettank]}==0) /face heading ${LookForward}
                /if (!${Me.FeetWet}) /look 0
                /if (${Select[${Role},hunter,hunterpettank]}) /varset ReturnToCamp 0
            }
            /if (${Me.FeetWet} && ${Math.Distance[${CampYLoc},${CampXLoc},${CampZLoc}]} >= 15) {
                /moveto loc ${CampYLoc} ${CampXLoc} ${CampZLoc} uw mdist 15
                /varset DWMTimer 30
                /while (${Math.Distance[${CampYLoc},${CampXLoc},${CampZLoc}]} > 15 && ${DWMTimer}) {
                    /if (${DebugFramework}) /Echo Current Line ${Macro.CurLine}
					/delay 5
                }
                /if (${MoveTo.Moving}) /moveto off
            }
        /if (${Debug}) /echo \atDEBUG DoWeMove: Leave \agLine#: ${Macro.CurLine}
    /return
| -------------------------------------------------------------------------------------
| SUB: Do We Chase
| -------------------------------------------------------------------------------------
    Sub DoWeChase(string SentFrom)
        /if (!${ChaseAssist}) /return
        /if (${Me.Hovering}) /return
        /declare StuckCount int local 0 
        /declare X1 int local
        /declare Y1 int local
        | Stop sticking if mobs are on xtarget
        /if (${ChaseAssist}==1) {
            /if (${SpawnCount[npc xtarhater]} && !${Role.Find[pull]} && ${MainAssist.NotEqual[${Me}]} && ${Spawn[=${WhoToChase}].Distance} < ${CampRadius}) {
                /if (${Stick.Active}) {
                    /if (${DebugMove}) /echo \atDEBUG Not gonna be an idiot and move during fight cause I dont have to.
                    /stick off
                    /moveto off
                    /if (${PullMoveUse.Equal[nav]}) {
                        /if (${Navigation.Active}) /nav stop
                    }
                }
                /return
            }
        }
        /doevents
        /call EndMacroIf
        /declare DWMWPCurrent int local 0
        /declare DWMTimer timer local 0
        /if (${Debug}) /echo \atDEBUG DoWeChase: Enter ${SentFrom} \agLine#: ${Macro.CurLine}
            /if (${DebugMove}) /echo \atDEBUG DoWeChase:(ChaseAssist) My distance from (${WhoToChase}) is: (${Spawn[=${WhoToChase}].Distance}). \agLine#: ${Macro.CurLine}
            /if (${JustZoned}==0 && (${Spawn[=${WhoToChase}].Distance} > ${CampRadiusExceed} && !${Navigation.MeshLoaded}) || (${Math.Calc[${Spawn[=${WhoToChase}].Z}-${Me.Z}]}>100 && ${Math.Calc[${Spawn[=${WhoToChase}].Z}-${Me.Z}]}<100)) {
                /if (${Debug} || ${DebugMove}) /echo \atDEBUG ChaseAssist exceed camp check \agLine#: ${Macro.CurLine}
                /varset ChaseAssist 0
                /echo ChaseAssist distance exceeded: Turning off ChaseAssist
                /call BroadCast ${EQBCOn} r "Hey! I got left behind please run me to " ${WhoToChase}
            }
            /if (${Spawn[=${WhoToChase}].Distance} > ${ChaseDistance}) {
                /if (${Debug} || ${DebugMove}) /echo \atDEBUG ChaseAssist MA distance check \agLine#: ${Macro.CurLine}
                /if (${Navigation.MeshLoaded}) {
                    /if (${Navigation.PathExists[id ${Spawn[=${WhoToChase}].ID}]}) {
                        /nav id ${Spawn[=${WhoToChase}].ID}
                    } else /if (${Spawn[=${WhoToChase}].LineOfSight}) {
                        /moveto id ${Spawn[=${WhoToChase}].ID} uw mdist ${ChaseDistance}
                    } else {
                        /echo Chase Failed due to ${WhoToChase} is not in Line of sight and Navigation couldn't find a path. Will try /Sticking.
                    }
                } else /if (${Spawn[=${WhoToChase}].LineOfSight}) {
                    /moveto id ${Spawn[=${WhoToChase}].ID} uw mdist ${ChaseDistance}
                }
                /delay 10 ${Me.Moving}
                /while (${Me.Moving}) {
                    /if (${DebugFramework}) /Echo Current Line ${Macro.CurLine}
					/if (${Spawn[=${WhoToChase}].Distance3D}<=${ChaseDistance}) {
                        /if (${PullMoveUse.Equal[nav]}) {
                            /if (${Navigation.Active}) /nav stop
                        }
                    }
                    /delay 5
                }
            }
            /if (!${Stick.Active} && !${Navigation.MeshLoaded}) {            
                /if (${Spawn[=${WhoToChase}].Type.Equal[Pet]}) {
                    /target ${Spawn[=${WhoToChase}].Master}
                    /delay 10
                    /if (${Me.FeetWet}) {
                        /stick ${ChaseDistance} id ${Target.ID} loose uw
                    } else {
                        /stick ${ChaseDistance} id ${Target.ID} loose
                    }
                } else /if ( ${Spawn[=${WhoToChase}].Type.Equal[mercenary]}) {
                    /target ${Spawn[=${WhoToChase}].Owner}
                    /delay 10
                    /if (${Me.FeetWet}) {
                        /stick ${ChaseDistance} id ${Target.ID} loose uw
                    } else {
                        /stick ${ChaseDistance} id ${Target.ID} loose
                    }
                } else {
                   /if (${Me.FeetWet}) {
                        /stick ${ChaseDistance} id ${Spawn[=${WhoToChase}].ID} loose uw
                    } else {
                       /stick ${ChaseDistance} id ${Spawn[=${WhoToChase}].ID} loose
                    }
                }
                /delay 10
                /while (${Me.Moving}) {
                    /if (${DebugFramework}) /Echo Current Line ${Macro.CurLine}
					/delay 10
                }
            }
            /while (${ChaseAssist}==3) {
                /if (${DebugFramework}) /Echo Current Line ${Macro.CurLine}
				/delay 10
            }
        /if (${Debug}) /echo \atDEBUG DoWeChase: Leave \agLine#: ${Macro.CurLine}
    /return
|-------------------------------------------------------------------------------------
| SUB: Stuck
| -------------------------------------------------------------------------------------
    Sub Stuck(string SentFrom)
        /declare strafedir string local
        | - We're stuck, back off a second, move left or right (randomly) for 1 second
        /if (${IAmDead}) /return
        /keypress back hold
        /delay 10
        /keypress back
        /if (${Math.Rand[2]}) {
            /varset strafedir STRAFE_LEFT
        } else {
            /varset strafedir STRAFE_RIGHT
        }
        /keypress ${strafedir} hold
        /delay 10
        /keypress ${strafedir}
    /return
| -------------------------------------------------------------------------------------
| SUB: DoWeMed
| -------------------------------------------------------------------------------------
    Sub DoWeMed
        /if (!${MedOn}) /return
        /if (!${MedCombat} && ${AggroTargetID}) /return
        /if (${MedCombat} && !${Medding} && ${AggroTargetID}!=0 && ${AggroTargetID}==${MyTargetID}) /return
        /if (${Debug}) /echo \atDEBUG DoWeMed Enter \agLine#: ${Macro.CurLine}
        /declare Med2On int local 0
        /declare MedForceOn int local 0
        /declare MedStat1 string local ${MedStat}
        /declare j int local 0
        /declare MedFlag int local 0
		
        /if (${Select[${Me.Class.ShortName},BST,BRD,CLR,DRU,ENC,MAG,NEC,PAL,RNG,SHM,SHD,WIZ]}) /varset MedStat Mana
        /if (${Select[${Me.Class.ShortName},BER,MNK,ROG,WAR]}) /varset MedStat Endurance
		
        /if (!${Me.Moving}) {
            /if (${Select[${Me.Class.ShortName},BRD,BST,PAL,RNG,SHD]} && ${Me.Pct${MedStat2}}<${MedStart} && ${Me.Pct${MedStat}}>${MedStart})  {
                /varset MedStat1 ${MedStat}
                /varset MedStat ${MedStat2}
                /varset Med2On 1
            }
            /if ((${Group.MainAssist.ID} && ${Group.MainAssist.Sitting})|| (!${Group.Member[${MainAssist}].Index} && ${Spawn[PC ${MainAssist}].Sitting})) {
                /if (!${MASitTime}) {
                    /varset MASitTime 300            
                } else /if (${MASitTime}<260) {
                   /varset MedForceOn 1
                }
            } else {
                /varset MASitTime 0
            }
            /if (${Me.Pct${MedStat}}<${MedStart}) {
                /varset MedFlag 1
            } else /if (${PullHold}==2 && ${Me.Pct${MedStat}}<98) {
                /varset MedFlag 1
            } else /if (${MedForceOn} && ${Me.Pct${MedStat}}<90 && !${Role.Find[puller]} && !${MedCombat}) {
                /varset MedFlag 1
            } else /if (${MedForceOn} && ${IAmABard} && ${TwistMed}) {
                /varset MedFlag 1
            }
            /if (${MedFlag}) {
                /squelch /target clear
                /varset Medding 1
                /if (${Attacking}) /call CombatReset 0 dowemed
                |/if (${Select[${Role},puller,pullertank,pullerpettank,hunter,hunterpettank]}) /call BroadCast ${EQBCOn} t "PULLER-> My ${MedStat} is ${Me.Pct${MedStat}}% time to med."
                | bards twisting while others fighting negate fast med 
                /if (${IAmABard}) {
                    /if (${AggroTargetID} || ${MedCombat}) {
                        /while (${Me.BardSongPlaying}) {
                            /if (${DebugFramework}) /Echo Current Line ${Macro.CurLine}
							/if (${Twist}) /squelch /twist off
                            /stopsong
                            /delay 10
                        }
                    } else /if (${TwistMed}) {
                        /while (${Me.BardSongPlaying}) {
                            /if (${DebugFramework}) /Echo Current Line ${Macro.CurLine}
							/if (${Twist}) /squelch /twist off
                            /stopsong
                            /delay 10
                        }
                        /squelch /twist ${TwistMed}
                        /delay 10
                        /while (${Window[CastingWindow].Open}) {
                            /if (${DebugFramework}) /Echo Current Line ${Macro.CurLine}
							/delay 5
                        }
                    } else {
                        /squelch /twist ${TwistWhat}
                        /delay 10
                    }
                }
                /if (${Medding}) /echo Medding until ${MedStat} 100% ${Me.Pct${MedStat}} ${MedStart}
                /if (${Me.Pct${MedStat}}<${MedStart}) /call BroadCast ${EQBCOn} t "My ${MedStat} is ${Me.Pct${MedStat}}% time to med."
                /while (1) {
				
                    /if (${DebugFramework}) /Echo Current Line ${Macro.CurLine}
					/doevents
					/call CampfireBack
                    /if (${ChaseAssist}) /call DoWeChase
                    /if (${ReturnToCamp} && ${Math.Distance[${CampYLoc},${CampXLoc}]} > 15) {
                        /call DoWeMove 0 DoWeMed
                    }
                    /if (${MountOn} && !${Me.Mount.ID} && (${Zone.Outdoor} || ${Select[${Zone.Type},1,2,5]})) /call CastMount
                    /if (!${Me.Mount.ID} && ${Me.Standing} && !${Me.Moving}) /sit
                    /if (${Debug}) /echo \atDEBUG ${MedStat} ${MedStat1} ${MedStat2} \agLine#: ${Macro.CurLine}
                    /delay 10
                    /if (!${MedCombat}) {
                        /call WaitSubs
                        /if (${CalledTargetID} && !${Group.Member[${MainAssist}].Index} && ${Spawn[${CalledTargetID}].Type.NotEqual[PC]}) {
                            /target id ${CalledTargetID}
                            /delay 10
                            /xtarget set ${XTSlot} currenttarget
                            /delay 10
                        }
                        /if (${AggroTargetID}) {
                            /if (${Med2On}) /varset MedStat ${MedStat1}
                            /varset Medding 0
                            /if (${IAmABard}) {
                                /while (${Me.BardSongPlaying}) {
                                    /if (${DebugFramework}) /Echo Current Line ${Macro.CurLine}
									/if (${Twist}) /squelch /twist off
                                    /stopsong
                                    /delay 10
                                }
                            }
                            /return
							/if (${Me.XTarget[1].ID} && ${SpawnCount[npc radius ${MeleeDistance} zradius 15 targetable playerstate 4]}) /return
                        }
                    } else {
                        /if (${AutoRezOn}) /call RezCheck all
                    }
                    /if (${MedForceOn} && (!${Group.MainAssist.ID} || !${Group.MainAssist.Sitting})) /varset MedForceOn 0
                    /if (${Me.Pct${MedStat}}==100 && !${MedForceOn}) /break
                }
                | Done Medding
                /if (${Med2On}) /varset MedStat ${MedStat1}
                /varset Medding 0
                /if (${Me.Sitting} && ${Me.Pct${MedStat}}>=95) {
                    /stand
                }
                /if (${IAmABard} && ${TwistMed}) {
                    /while (${Me.BardSongPlaying}) {
                        /if (${DebugFramework}) /Echo Current Line ${Macro.CurLine}
						/if (${Twist}) /squelch /twist off
                        /stopsong
                        /delay 10
                    }
                }
            }
            /if (${Select[${Role},pullerpettank,puller,hunter,hunterpettank]} && ${Me.PctHPs}<=50) {
                /echo Medding to 100% health
				/if (${Attacking}) /call CombatReset 0 dowemed
                /if (!${Me.Mount.ID} && ${Me.Standing} && !${Me.Moving}) /sit
                /while (1) {
					/if (${DebugFramework}) /Echo Current Line ${Macro.CurLine}
                    /doevents
                    /if (${ReturnToCamp} && ${Math.Distance[${CampYLoc},${CampXLoc}]} > 15) {
                        /call DoWeMove 0 dowemed
                    }
                    /delay 5
                    /if (!${MedCombat}) {
                        /call WaitSubs
                        /if (${AggroTargetID}) {
							/if (${Me.XTarget[1].ID} && ${SpawnCount[npc radius ${MeleeDistance} zradius 15 targetable playerstate 4]}) /return
                        }
                    }
                    /if  (${Me.PctHPs}==100) /break
                }
                /if (!${Me.Mount.ID} && ${Me.Sitting}) {
                    /stand
                }
            }
            /if (${Select[${Role},pullerpettank,hunterpettank]} && !${Me.Invis} && (${Me.Pet.PctHPs}<=50 || ${PetForceHealOnMed})) {
                | Check pet is at full health before pulling.  
                /echo Waiting on pet to full health before next pull        
                /if (${Me.Pet.ID} && ${Me.Pet.PctHPs}<100) {                
                    /call NewCast "${Me.Pet.ID}" "Heals"
                }  
            }             
        }
        /if (${Debug}) /echo \atDEBUG DoWeMed Leave \agLine#: ${Macro.CurLine}
    /return
	
	
| -------------------------------------------------------------------------------------
| SUB: CheckBuffs
| -------------------------------------------------------------------------------------
    Sub CheckBuffs(int ForceGroup)
        /if (!${BuffsOn} || ${IAmDead} || ${Me.Hovering} || (${Me.Invis} && ${Me.Class.Name.NotEqual[Rogue]}) || (${ChaseAssist} && ${Me.Moving}) || (${Me.Moving} && ${WhoToChase.Equal[${Me}]})) /return
        /if (${DebugBuffs}) /echo \atDEBUGBUFFS CheckBuffs CheckBuffs: Enter \agLine#: ${Macro.CurLine}
        /declare i                int     local 0
        /declare j                int     local 0
        /declare k                int     local 0
        /declare l                int     local 0
        /declare FullText         string  local 0
        /declare 2ndPart          string  local 0
        /declare 3rdPart          string  local 0
        /declare 4thPart          string  local 0
        /declare 5thPart          string  local 0
        /declare SpellRange       int     local 0
        /declare SpellToCast      string  local null
        /declare MATargetID       int     local 0
        /declare BookSpellTT      string  local 0
        /declare BuffToCheck      string  local null
        /declare CondNo           int     local 0
        /if (${PowerSource.NotEqual[NULL]} && ${Bool[${Me.Inventory[powersource].Name.Length}]} && !${Me.Inventory[powersource].Power} ) {
           /call CheckCursor CheckBuffs0
           /nomodkey /itemnotify "${PowerSource}" leftmouseup
           /delay 5s ${Cursor.ID}
           /if (${Cursor.Name.Equal[${PowerSource}]}) /destroy
           /delay 5s ${Cursor.Equal[Null]}
        }
        |--------- Change to add Zone.Outdoor TLO and specific Zone.Type to stop mount cast spam.
        /if (${MountOn} && !${Me.Mount.ID} && (${Zone.Outdoor} || ${Select[${Zone.Type},1,2,5]}) && ${Me.CombatState.NotEqual[COMBAT]}) /call CastMount
        | Call Buffs Array
        /for i 1 to ${Buffs.Size}
            /doevents
			MOBINCAMP
			
            /if (${AggroTargetID} && ${Spawn[${AggroTargetID}].Distance}<200) /return
            /if (${Buffs[${i}].Find[|0]}) /continue
            /if (${ChaseAssist} && !${CombatStart}) /call DoWeChase
            /if (${UseModHeal}==0 && ${HealsOn}==1) {
				/if (${HealsOn}) /call CheckHealth				
			} else /if (${UseModHeal}==1 && ${HealsOn}==1 && ((${Spawn[${WorstHurt[both,1,200,TRUE]}].Type.NotEqual[Pet]} && ${Spawn[${WorstHurt[both,1,200,TRUE]}].Class.ShortName.NotEqual[Corpse]} && ${Spawn[${WorstHurt[both,1,200,TRUE]}].PctHPs} <= ${Math.Calc[${${Spawn[${WorstHurt[both,1,200,TRUE]}].Class.ShortName}Point}*.${tmpHealOverride}]}) || (${Spawn[${WorstHurt[both,1,200,TRUE]}].Type.Equal[Pet]} && ${Spawn[${WorstHurt[both,1,200,TRUE]}].Class.ShortName.NotEqual[Corpse]} && ${Spawn[${WorstHurt[both,1,200,TRUE]}].PctHPs} <= ${Math.Calc[${PetPoint}*.${tmpHealOverride}]}))) {
				|/echo ${Macro.CurLine}
				/call NewCast ${Spawn[${WorstHurt[both,1,200,TRUE]}].ID} "Heals"
			}
            /if (${AutoRezOn}) /call RezCheck all
            | If Buffs=NULL skip to next buff
            /if (${Buffs[${i}].Equal[null]} || ${Buffs[${i}].Arg[3,|].Equal[0]} || ${Buffs[${i}].Arg[2,|].Equal[0]}) /continue
            | Check for combat and skip redundant subs called in combat routines.
            /if (${DebugBuffs}) /echo \atDEBUGBUFFS CheckBuffs Buff${i}: ${Buffs[${i}]} \agLine#: ${Macro.CurLine}
            | Check for spells with 2 parts such as Exigent Focusing Rk. II,Talisman of Soul's Unity Rk. II - Set Buffs to the buff
            /if (${Buffs[${i}].Arg[2,|].Length}) {
                /varset FullText ${Buffs[${i}]}
                /varset SpellToCast ${Buffs[${i}].Arg[1,|]}
                /varset 2ndPart ${Buffs[${i}].Arg[2,|]}
                /varset 3rdPart ${Buffs[${i}].Arg[3,|]}
                /varset 4thPart ${Buffs[${i}].Arg[4,|]}
                /varset 5thPart ${Buffs[${i}].Arg[5,|]}
                /if (${2ndPart.Equal[Dual]}) {
                    /if (${4thPart.Equal[MA]}) {
                        /varset 2ndPart DualMA
                    } else /if (${4thPart.Equal[melee]}) {
                        /varset 2ndPart DualMelee
                    } else /if (${4thPart.Equal[caster]}) {
                        /varset 2ndPart DualCaster
                    } else /if (${4thPart.Equal[class]}) {
                        /varset 2ndPart DualClass
                    } else /if (${4thPart.Equal[mgb]}) {
                        /varset 2ndPart DualMgb
                    }
                } else /if (${2ndPart.Equal[class]}) {
                    /varset 5thPart ${3rdPart}
                }
            } else {
                /varset FullText ${Buffs[${i}]}
                /varset SpellToCast ${Buffs[${i}]}
                /varset 2ndPart 
                /varset 3rdPart 
                /varset 4thPart 
                /varset 5thPart 
            }
            |/varset SpellRange ${Spell[${SpellToCast}].Range}
            /if (${Me.Subscription.NotEqual[gold]}) {
                /if (${Select[${2ndPart},Dual,DualMA,DualMelee,DualCaster,DualMgb]}==0) {
                    /if (${SpellToCast.Find[ Rk.]}) {
                        /varset BuffToCheck ${SpellToCast.Left[${Math.Calc[${SpellToCast.Find[ Rk.]}-1]}]} 
                    } else {
                        /varset BuffToCheck ${SpellToCast}
                    }
                } else {
                    /if (${3rdPart.Find[ Rk.]}) {
                        /varset BuffToCheck ${3rdPart.Left[${Math.Calc[${3rdPart.Find[ Rk.]}-1]}]} 
                    } else {
                        /varset BuffToCheck ${3rdPart}
                    }
                } 
            } else {
                /if (${Select[${2ndPart},Dual,DualMA,DualMelee,DualCaster,DualMgb]}==0) {
                    /varset BuffToCheck ${SpellToCast}
                } else {
                    /varset BuffToCheck ${3rdPart}
                }
            }
            /if (${DebugBuffs}) /echo \atDEBUGBUFFS CheckBuffs 1st:${SpellToCast} 2nd: ${2ndPart} #rd: ${3rdPart} ${BuffToCheck} 4th: ${4thPart} \agLine#: ${Macro.CurLine}
            /if (${Me.Book[${SpellToCast}]}) {
                /varset BookSpellTT ${Spell[${Me.Book[${Me.Book[${SpellToCast}]}].ID}].TargetType}
            } else {
                /varset BookSpellTT 0
            }
            /if (${Int[${Spell[${SpellToCast}].Range}]}>=${Int[${Spell[${SpellToCast}].AERange}]}) {
                /varset SpellRange ${Spell[${SpellToCast}].Range}
            } else {
                /varset SpellRange ${Spell[${SpellToCast}].AERange}
            }
            |/if ((${BookSpellTT.Find[0]} && ${Spell[${SpellToCast}].TargetType.Find[Group v]}) || ${BookSpellTT.Find[Group v]}) /varset SpellRange ${Spell[${SpellToCast}].AERange}
            |/if (${Spell[${SpellToCast}].TargetType.Find[Group v]}) /varset SpellRange ${Spell[${SpellToCast}].AERange}
            /if (!${SpellRange}) /varset SpellRange 100
            /if (${DebugBuffs}) /echo \atDEBUGBUFFS CheckBuffs ${i} 1st: ${SpellToCast} 2nd: ${2ndPart} FullText: ${Buffs[${i}]} Type: ${Spell[${SpellToCast}].TargetType} ReadBuffsTimer: ${ReadBuffsTimer} IniNextTimer: ${IniNextTimer} \agLine#: ${Macro.CurLine}
            /if (${DebugBuffs}) /echo \atDEBUGBUFFS CheckBuffs Skip if Combat: ${CombatStart}  Aggro: ${AggroTargetID} IDied: ${IAmDead} ReadBTimer: ${ReadBuffsTimer} Invised: ${Me.Invis} \agLine#: ${Macro.CurLine}
            /if ((${Me.CombatState.Equal[COMBAT]} && ${AggroTargetID}) || ${CombatStart}) /return
            /if (${IAmDead} || ${Me.Invis} || ${ReadBuffsTimer}) /return
            | Conditions Check
            |/if (${ConOn} && ${Buffs[${i}].Find[|cond]} && ${If[${Cond[${Buffs[${i}].Mid[${Math.Calc[${Buffs[${i}].Find[|cond]}+5]},3]}]},0,1]}) /continue
            /if (${ConOn} && ${Buffs[${i}].Find[|cond]}) {
                /varset CondNo ${Buffs[${i}].Mid[${Math.Calc[${Buffs[${i}].Find[|cond]}+5]},3]}
            } else {
                /varset CondNo 0
            }
            | Check for Mana/End AA Regen on others
            /if (${DebugBuffs}) /echo DEBUGBUFFS CheckBuffs Start of If Structure. ${SpellToCast} ${2ndPart} ${Spell[${SpellToCast}].Mana} ${Me.CurrentMana} \agLine#: ${Macro.CurLine}
            /varset MacroReturn CAST_NO_RESULT
            /if (${Select[${2ndPart},Endgroup,Managroup]}>0) {
                /if (${Group}) {
                    /if (${2ndPart.Equal[Endgroup]}) {
                        /call RegenOther "${SpellToCast}" Endurance ${3rdPart} 0 ${CondNo}
                    } else /if (${2ndPart.Equal[Managroup]}) {
                        /call RegenOther "${SpellToCast}" Mana ${3rdPart} 0 ${CondNo}
                    }
                    /varset MacroReturn ${Macro.Return}
                    /if (${MacroReturn.Equal[TRUE]}) /varcalc Buff${i}GM0 (${Spell[${SpellToCast}].RecastTime.TotalSeconds})*10
                }
            } else /if (${2ndPart.Equal[mana]}) {
                /if (${Me.PctMana}>${3rdPart}) /continue
                /call CastWhat "${SpellToCast}" ${Me.ID} Buffs 0 ${CondNo}
            | Combat check to skip all buffs but mana regen
            | Check and Cast endurance discs/AAs - 2nd wind, respite, etc
            } else /if (${2ndPart.Equal[End]}) {
                /if (${Me.PctEndurance}<=${3rdPart} && (${Me.CombatAbilityReady[${SpellToCast}]} || ${Me.AltAbilityReady[${SpellToCast}]})) /call CheckEndurance "${SpellToCast}" ${3rdPart} ${4thPart} ${CondNo}
            | Remove buff from |Remove tag
            } else /if (${2ndPart.Equal[Remove]} && ${Me.Buff[${SpellToCast}].ID}) {
                /if (!${CondNo} || ${If[${Cond[${CondNo}]},1,0]}) {
                /echo Removing Buff: ${SpellToCast}
                /removebuff "${SpellToCast}" 
                }
            | If buff cost more mana than I have skip it
            } else /if (${Spell[${SpellToCast}].Mana} && ${Spell[${SpellToCast}].Mana}>${Me.CurrentMana}) {
                /continue
            | Check if aura is up
            } else /if (${2ndPart.Equal[Aura]}) {
                /call CheckAura "${SpellToCast}" ${CondNo}
            | Check for |Once tag and turn buff off is cast is successful
            } else /if (${2ndPart.Equal[Once]}) {
                /call BuffOnce "${SpellToCast}" ${CondNo}
                /if (${Macro.Return.Equal[TRUE]}) {
                    /varset Buffs[${i}] ${SpellToCast}|0
                    /echo Buffing Once with ${SpellToCast}.
                }
            | Summon items ini example Buffs1=The Guardian's Pouch|Summon|Guardian Blade|200
            } else /if (${2ndPart.Equal[Summon]}) {
                /if (${FindItemCount[=${3rdPart}]}<${4thPart}) /call SummonStuff "${SpellToCast}" "${3rdPart}" ${4thPart} ${CondNo}
                /if (${Macro.Return.Equal[CAST_COMPONENTS]}) {
                    /echo You are missing components. Turning off ${SpellToCast}.
                    /varset Buffs[${i}] NULL
                    /varset FullText NULL
                }
            } else /if (${Select[${2ndPart},mgb,dualmgb]}>0 && !${Me.Buff[${BuffToCheck}].ID}) {
                /call MassGroupBuff "${SpellToCast}" ${i} ${CondNo}
            } else /if (${SpellToCast.Find[command:]}) {
                /call TargetTag "${FullText}" 
                /call CastWhat "${SpellToCast}" ${Macro.Return} Buffs 0 ${CondNo}
                /continue
            } 
            /if (${DebugBuffs}) /echo DEBUGBUFFS CheckBuffs End of If Structure. ${2ndPart} \agLine#: ${Macro.CurLine}
            | Everything above is for self/group only can skip to end if 2ndPart is in list below. mana and end are exceptions.
            /if (${Select[${2ndPart},Aura,Mount,Summon,Endgroup,Managroup,Once,Remove,Mana,End,mgb]}) /continue
            /if (${DebugBuffs}) /echo \atDEBUGBUFFS CheckBuffs BuffSlot: !${Int[${Me.Buff[${BuffToCheck}].ID}]} SongSlot: ${Int[${Me.Song[${BuffToCheck}].ID}]} Stacks: ${Spell[${SpellToCast}].Stacks[0]} 2nd Part: ${Select[${2ndPart},Aura,Mount,Summon,Endgroup,Managroup,Once,Remove]}<1 Tar Type: ${Spell[${SpellToCast}].TargetType} \agLine#: ${Macro.CurLine}
            /if (${DebugBuffs}) /echo \atDEBUGBUFFS CheckBuffs Find 0: ${BookSpellTT.Find[0]} Spell TT: ${Spell[${SpellToCast}].TargetType.Find[single]} BookTT: ${BookSpellTT.Find[single]} Medding: ${Medding} MedCombat: ${MedCombat} \agLine#: ${Macro.CurLine}
            | Cast buffs on MA && ${Spell[${Buffs[${i}]}].TargetType.Find[self]}
            /if (${Select[${2ndPart},MA,DualMA]}) {
                /if (${Spawn[=${MainAssist}].Distance}<=${SpellRange} && ${Spawn[=${MainAssist}].ID} && ${Buff${i}GM7}==0) {
                    /if (${DebugBuffs}) /echo \atDEBUGBUFFS Cast buffs with MA tag ${Buffs[${i}]} \agLine#: ${Macro.CurLine}
                    | Check buffs in file to see if MA has buff or its blocked
                    /if (${Ini[framework/${MacroName}_Buffs.ini,${Spawn[${MainAssistType} ${MainAssist}].ID},"Blockedbuffs"].Find[${BuffToCheck}]}) /continue
                    /if (${Ini[framework/${MacroName}_Buffs.ini,${Spawn[${MainAssistType} ${MainAssist}].ID},"Buffs"].Find[${BuffToCheck}]}) /continue
                    | If its a group spell cast on mercs - owner
                    /if (${Spawn[=${MainAssist}].Type.Equal[mercenary]} && ${Spell[${SpellToCast}].TargetType.Find[group v]}) { 
                        /varset MATargetID ${Spawn[=${MainAssist}].Owner.ID}
                    } else /if (${Select[${Role},hunterpettank,pettank,pullerpettank]} ) {
                        /varset MATargetID ${Me.Pet.ID}
                    } else {
                        /varset MATargetID ${Spawn[=${MainAssist}].ID}
                    }
                    /if (${Cursor.ID}) /call CheckCursor CheckBuffs1
                    /if (${DebugBuffs}) /echo \atDEBUGBUFFS CheckBuffs: MA Buff /call CastWhat "${SpellToCast}" ${MATargetID} Buffs 0 ${CondNo} \agLine#: ${Macro.CurLine}
                    /if (${CondNo} && ${If[${Cond[${CondNo}]},0,1]}) /continue
                    /call CastWhat "${SpellToCast}" ${MATargetID} Buffs-nomem 0 ${CondNo}
                    /if (${DebugBuffs}) /echo \atDEBUGBUFFS CheckBuffs: MA Buff MacroReturn: ${Macro.Return} \agLine#: ${Macro.CurLine}
                    /if (${Macro.Return.Equal[CAST_SUCCESS]} || (!${Spawn[${MainAssistType} ${MainAssist} group].ID} && ${Macro.Return.Equal[CAST_TAKEHOLD]})) {
                        /echo Buffing MA >> ${Spawn[=${MainAssist}].CleanName} << with ${SpellToCast}.
                        /varcalc Buff${i}GM7 (${Spell[${BuffToCheck}].Duration.TotalSeconds}*${DurationMod})*10
                        /if (${DebugBuffs}) /echo DEBUGBUFFS CheckBuffs MA Buff Timer ${Buff${i}GM7} \agLine#: ${Macro.CurLine}
                        /varset WriteBuffsTimer 0
                        /call WriteBuffs
                        /continue
                    }
                    /if (${Macro.Return.Equal[CAST_COMPONENTS]}) {
                        /echo You are missing components. Turning off ${SpellToCast}.
                        /varset Buffs[${i}] NULL
                        /varset FullText NULL
                        /continue
                    }
                } else {
                    /continue
                }
            | Check if buff is up and if it stacks with existing buffs
            } else /if (${ForceGroup} || (!${Int[${Me.Buff[${BuffToCheck}].ID}]} && !${Int[${Me.Song[${BuffToCheck}].ID}]} && ${Spell[${SpellToCast}].Stacks[0]})) {
                /if (${DebugBuffs}) /echo \atDEBUGBUFFS CheckBuffs -- 2nd asssigned: ${SpellToCast} TargetType: ${Spell[${SpellToCast}].TargetType} \agLine#: ${Macro.CurLine}
                | If Target.Type=Group then buff self with group buff
                /if ((${BookSpellTT.Find[0]} && ${Spell[${SpellToCast}].TargetType.Find[group v]}) || ${BookSpellTT.Find[group v]}) {
                    /if (${Cursor.ID}) /call CheckCursor CheckBuffs2
                    /call CastWhat "${SpellToCast}" ${Me.ID} Buffs-nomem 0 ${CondNo}
                    /if (${Macro.Return.Equal[CAST_SUCCESS]}) {
                        /echo Buffing >> ${SpellToCast} <<
                        /doevents flush Worn_off
                        /varset WriteBuffsTimer 0
                        /call WriteBuffs
                    }
                    /if (${ForceGroup}) {
                        /if (${DebugFramework}) /Echo Current Line ${Macro.CurLine}
						/while (${Me.SpellInCooldown}) {
                            /delay 5
                        }
                        /continue
                    }
                | If Target.Type=Single then buff each party member with single buff
                } else /if ((${BookSpellTT.Find[0]} && ${Spell[${SpellToCast}].TargetType.Find[single]}) || ${BookSpellTT.Find[single]}) {
                    /if (${Buff${i}GM0}) /varset Buff${i}GM0 0
                    /if (${Group} && ${Me.CurrentMana}>=${Math.Calc[${Spell[${SpellToCast}].Mana}*${Group}]}) {
                        /if (${DebugBuffs}) /echo \atDEBUGBUFFS CheckBuffs Single Type Group Buff \agLine#: ${Macro.CurLine}
                        /for j 0 to ${Group}
                            /if (${DebugBuffs}) /echo \atDEBUGBUFFS CheckBuffs !${Group.Member[${j}].ID} || ${Spawn[${Group.Member[${j}]}].Distance}>=${SpellRange} || ${2ndPart.Equal[Me]} && ${j}>=1 || ${2ndPart.Equal[MA]} && ${Group.Member[${j}].ID}!=${Spawn[${MainAssistType} ${MainAssist}].ID} || ${Buff${i}GM${j}} \agLine#: ${Macro.CurLine}
                            | Check if party member is alive in zone and within spell range and spell timer does not exist
                            /if (!${Group.Member[${j}].ID} || ${Spawn[${Group.Member[${j}]}].Distance}>=${SpellRange} || ${Buff${i}GM${j}}) /continue
                            /if (${2ndPart.Equal[Me]} && ${j}>=1) /continue
                            /if (${DebugBuffs}) /echo \atDEBUGBUFFS CheckBuffs 3 ${2ndPart.Equal[caster]}  ${Select[${Group.Member[${j}].Class.ShortName},CLR,DRU,SHM,BST,ENC,MAG,NEC,PAL,SHD,RNG,WIZ]} ${2ndPart.Equal[Melee]} ${Select[${Group.Member[${j}].Class.ShortName},BRD,BER,BST,MNK,PAL,ROG,RNG,SHD,WAR]} \agLine#: ${Macro.CurLine}
                            /if ((${Select[${2ndPart},caster,DualCaster]}>0 && ${Select[${Group.Member[${j}].Class.ShortName},CLR,DRU,SHM,BST,ENC,MAG,NEC,PAL,SHD,RNG,WIZ]}==0) || (${Select[${2ndPart},Melee,DualMelee]}>0 && ${Select[${Group.Member[${j}].Class.ShortName},BRD,BER,BST,MNK,PAL,ROG,RNG,SHD,WAR]}==0)) /continue
                            /if (${Select[${2ndPart},class,dualclass]}>0 && ${Select[${Group.Member[${j}].Class.ShortName},${5thPart}]}==0) /continue
                            /if (${Select[${2ndPart},MA,Dualma]}>0 && ${Group.Member[${j}].ID}!=${Spawn[${MainAssistType} ${MainAssist}].ID}) /continue
                            /if (${Me.CurrentMana}<${Spell[${SpellToCast}].Mana}) /continue
                            /if (${2ndPart.Equal[!MA]} && ${Group.Member[${j}].ID}==${Spawn[${MainAssistType} ${MainAssist}].ID}) /continue
                            /if (${Cursor.ID}) /call CheckCursor CheckBuffs3
                            /if (${AggroTargetID} && ${Spawn[${AggroTargetID}].Distance}<200) /return
                            /delay 7s ${Me.SpellReady[${SpellToCast}]}
                            /call CastWhat "${SpellToCast}" ${Group.Member[${j}].ID} Buffs-nomem 0 ${CondNo}
                            /if (${Macro.Return.Equal[CAST_SUCCESS]}) {
                                /echo Buffing ${SpellToCast} on ${Group.Member[${j}].CleanName}
                                /varcalc Buff${i}GM${j} (${Spell[${BuffToCheck}].Duration.TotalSeconds}*${DurationMod})*10
                                /doevents flush Worn_off
                                /varset WriteBuffsTimer 0
                                /call WriteBuffs
                            } else /if (${Macro.Return.Equal[CAST_COMPONENTS]}) {
                                /echo You are missing components. Turning off ${SpellToCast}.
                                /varset Buffs[${i}] NULL
                                /varset FullText NULL
                                /continue
                            }
                        /next j
                    } else /if (${Select[${2ndPart},MA,Melee,Caster,DualMA,DualMelee,DualCaster]}==0) {
                        /if (${Cursor.ID}) /call CheckCursor CheckBuffs4
                        /call CastWhat "${SpellToCast}" ${Me.ID} Buffs-nomem 0 ${CondNo}
                        /if (${Macro.Return.Equal[CAST_SUCCESS]}) {
                            /echo Buffing ${SpellToCast} on ${Group.Member[${j}].CleanName}
                            /varcalc Buff${i}GM${j} (${Spell[${BuffToCheck}].Duration.TotalSeconds}*${DurationMod})*10
                            /doevents flush Worn_off
                            /varset WriteBuffsTimer 0
                            /call WriteBuffs
                        } else /if (${Macro.Return.Equal[CAST_COMPONENTS]}) {
                            /echo You are missing components. Turning off ${SpellToCast}.
                            /varset Buffs[${i}] NULL
                            /varset FullText NULL
                            /varset SpellToCast
                            /continue
                        }
                    }
                | If Target.Type=self then buff self
                } else /if ((!${FindItem[=${SpellToCast}].ID} && ${BookSpellTT.Find[0]} && ${Spell[${SpellToCast}].TargetType.Find[self]}) || ${BookSpellTT.Find[self]}) {
                    /if (${DebugBuffs}) /echo \atDEBUGBUFFS CheckBuffs Self Buff \agLine#: ${Macro.CurLine}
                        /call CastWhat "${SpellToCast}" ${Me.ID} Buffs-nomem 0 ${CondNo}
                    /if (${Macro.Return.Equal[CAST_COMPONENTS]}) {
                        /echo You are missing components. Turning off ${SpellToCast}.
                        /varset Buffs[${i}] NULL
                        /varset FullText NULL
                        /delay 10
                        /continue
                    } else /if (${Macro.Return.Equal[CAST_SUCCESS]}) {
                        /echo Casting ${SpellToCast} on me.
                        /delay 10
                    }
                | Check if buff needs pet as target ie Mage's Symbiosis line of mana buffs
                } else /if (${Me.Pet.ID} && (${BookSpellTT.Find[0]} && ${Spell[${SpellToCast}].TargetType.Find[pet]} || ${Select[${Spell[${Spell[${SpellToCast}].ID}].Name.Arg[2,]},Symbiosis,Siphon,Simulacrum]})) {
                    /if (${DebugBuffs}) /echo \atDEBUGBUFFS CheckBuffs Self Buff that targets pet ie mage mana buff line \agLine#: ${Macro.CurLine}
                    /call CastWhat "${SpellToCast}" ${Me.Pet} Buffs 0 ${CondNo}
                }
                | If buff is an item click it
            } else /if (${FindItem[=${SpellToCast}].Spell.Stacks[0]} && !${Int[${Me.Buff[${BuffToCheck}].ID}]} && ${Me.ItemReady[${SpellToCast}]} && ${Select[${2ndPart},Aura,Mount,Mana]}==0) {
                    /if (${DebugBuffs}) /echo \atDEBUGBUFFS CheckBuffs Items \agLine#: ${Macro.CurLine}
                    | Call of the wild ear fix
                    /if (${SpellToCast.Equal[Call of the Wild]}) {
                        /useitem "Call of the Wild"
                        /delay 15
                    } else {
                    /call CastWhat "${SpellToCast}" ${Me.ID} Buffs 0 ${CondNo}
                    }
                    /if (${Macro.Return.Equal[CAST_SUCCESS]}) /echo Clicking > ${SpellToCast} <
            }
            /if (${DebugBuffs}) /echo \atDEBUGBUFFS CheckBuffs  IniBuffCheck 1: Mana,Aura,Mount,Me,Summon,End:${Select[${2ndPart},Mana,Aura,Mount,Me,Summon,End,0]} Item:${FindItemCount[=${SpellToCast}]}>=1 Self:${Spell[${SpellToCast}].TargetType.Find[self]} \agLine#: ${Macro.CurLine}
            | If Buff is a Mana,Aura,Mount,Me,Summon,End, an item, self buff or Spawn ID is me skip ini check because none of these are cast on others
            /if (${Select[${2ndPart},me]}) /continue
            /if ((${FindItemCount[=${SpellToCast}]}>=1 && ${Spell[${SpellToCast}].TargetType.Equal[self]}) || (${FindItemCount[${SpellToCast}]}>=1 && ${Spell[${BuffToCheck}].TargetType.Equal[self]}) || (${BookSpellTT.Find[0]} && ${Spell[${SpellToCast}].TargetType.Find[self]}) || ${BookSpellTT.Find[self]} || ${BookSpellTT.Find[pet]}) /continue
            /if (${Redguides} && !${IniNextTimer} && !${CombatStart}) /call CheckiniBuffs "${SpellToCast}" ${i} ${SpellRange} "${BuffToCheck}" "${2ndPart}" "${3rdPart}" "${4thPart}" "${5thPart}" "${BookSpellTT}" ${CondNo}
            /if (${DebugBuffs}) /echo \atDEBUGBUFFS CheckBuffs reset var ${i} ${Buffs[${i}]} \agLine#: ${Macro.CurLine}
        /next i
        /if (${PowerSource.NotEqual[NULL]} && !${Bool[${Me.Inventory[powersource].Name.Length}]} && ${FindItemCount[=${PowerSource}]}) {
           /nomodkey /itemnotify "${PowerSource}" leftmouseup
           /delay 5s ${Cursor.ID}
           /autoinventory
        }
        /if (!${ReadBuffsTimer} && !${AggroTargetID}) /varset ReadBuffsTimer ${CheckBuffsTimer}s
        /if (${Macro.RunTime}>120 && !${IniNextTimer}) /varset IniNextTimer 30s
        /if (${Me.Gem[${MiscGem}].Name.NotEqual[${ReMemMiscSpell}]} && ${MiscGemRemem}) {
            /varset DontMoveMe 1
            /call CastMemSpell "${ReMemMiscSpell}" ${MiscGem} 0 CheckBuffs
            /varset DontMoveMe 0
        }
        /if (${DebugBuffs}) /echo \atDEBUGBUFFS CheckBuffs Leave \agLine#: ${Macro.CurLine}
    /return
| -------------------------------------------------------------------------------------
| SUB: TargetTag 
| -------------------------------------------------------------------------------------
    Sub TargetTag(TargetTagText)
    /declare TagReturn string local
        /if (${TargetTagText.Find[|pet]}) {
            /varset TagReturn ${Pet.ID}
        } else /if (${TargetTagText.Find[|me]}) {
            /varset TagReturn ${Me.ID}
        } else /if (${TargetTagText.Find[|ma]}) {
            /varset TagReturn ${MainAssistID}
        } else {
            /varset TagReturn 0
        }               
    /return ${TagReturn}
| -------------------------------------------------------------------------------------
| SUB: BuffOnce 
| -------------------------------------------------------------------------------------
    Sub BuffOnce(OnceSpell, int Cond#)
        /if (${Me.Invis}) /return
        /declare OnceResult string local FALSE
        /if (!${Cond#} || ${If[${Cond[${Cond#}]},1,0]}) {
            /call CastWhat "${OnceSpell}" ${Me.ID} BuffOnce 0 0
        /if (${Macro.Return.Equal[CAST_SUCCESS]}) {
            /varset OnceResult TRUE
        }
        }
    /return ${OnceResult}
| -------------------------------------------------------------------------------------
| SUB: CheckAura | Check if aura is up
| -------------------------------------------------------------------------------------
    Sub CheckAura(AuraSpell, int Cond#)
        /if (${Me.Invis}) /return
        /if (${DebugBuffs}) /echo \atDEBUGBUFFS CheckAura Spell: ${AuraSpell} Enter \agLine#: ${Macro.CurLine}
        /declare AuraName string local
        /declare TempAura string local
        /declare AuraResult string local FALSE
        | Strip the Rk II/III out of the spell to check against aura window
        /if (${AuraSpell.Find[ Rk.]}) {
            /varset AuraName ${AuraSpell.Left[${Math.Calc[${AuraSpell.Find[ Rk.]}-1]}]}
        } else {
            /varset AuraName ${AuraSpell}
        }
        /if (${AuraSpell.Find[Disciple's Aura]}) {
        | Correct typo from SOE in monks 55 level aura
            /varset AuraName Disciples Aura
        } else /if (${Me.Class.Name.Equal[cleric]} && ${AuraSpell.Find[Reverent]}) {
            | Cleric exception for Reverent Aura 
            /varset AuraName Reverent Aura
        } else /if ( ${AuraSpell.Find[Mana Reverberation]} || ${AuraSpell.Find[Mana Repercussion]} || ${AuraSpell.Find[Mana Reiteration]}) {
            | Enchanter exception for Mana Recursion Auras
            /varset AuraName Mana Recursion Aura
        } else /if (${AuraSpell.Find[Mana Reiterate]}) {
            | Enchanter exception for Mana Reverberation Aura lv 100
            /varset AuraName Mana Reiterate Aura
        } else /if (${AuraSpell.Find[Mana Reverberation]}) {
            /varset AuraName Mana Rev.
        } else /if (${AuraSpell.Find[Mana Resurgence]}) {
            /varset AuraName Mana Resurgence Aura
        } else /if (${AuraSpell.Find[Mana Repercussion Aura]}) {
            /varset AuraName Mana Rep. Aura
        } else /if (${AuraSpell.Find[Runic Radiance Aura]}) {
            /varset AuraName Runic Rad. Aura
        } else /if (${AuraSpell.Find[Arcane Distillect]}) {
            | Mage exceptions because aura is on pet not in aura window and other fucked up shit
            /varset TempAura Arcane Distillect
        } else /if (${AuraSpell.Find[Earthen Strength]}) {
            /varset TempAura Earthen Strength Effect
        } else /if (${AuraSpell.Find[Rathe's Strength]}) {
            /varset TempAura Rathe's Strength Effect
        }
        | Check if aura is up 4 parts - Mage | Everyone else | 2 auras cleric | 2 auras enchamter
        /if (${Select[${Me.Class.ShortName},CLR,ENC,MAG]}==0 && ${Me.Aura[1].Name.Find[${AuraName}]}) {
            /return ${AuraResult}
        } else /if (${Me.Class.ShortName.Equal[MAG]} && ${Me.Pet.ID} && ${Me.Pet.Distance}<175) {
            /if (${Me.Aura[1].Name.Find[${TempAura}]}) {
                /return ${AuraResult}
            } else /if (${Me.PetBuff[${TempAura}]}) {
                /return ${AuraResult}
            }
        } else /if (${Select[${Me.Class.ShortName},CLR,ENC]} && (${Me.Aura[1].Name.Find[${AuraName}]} || ${Me.Aura[2].Name.Find[${AuraName}]})) {
            /return ${AuraResult}
        }
        /if (${DebugBuffs}) /echo \atDEBUGBUFFS CheckAura Aura \agLine#: ${Macro.CurLine}
        | - Mutant Bards do this
        /if (!${Cond#} || ${If[${Cond[${Cond#}]},1,0]}) {
        /if (${Me.Class.ShortName.Equal[BRD]}) {
            /if (!${Me.Gem[${AuraSpell}]} && ${Me.Book[${AuraSpell}]}) {
                /if (${Cursor.ID}) /call CheckCursor CheckAura
                /if (${Twist}) {
                    /while (${Me.BardSongPlaying}) {
                        /if (${DebugFramework}) /Echo Current Line ${Macro.CurLine}
						/if (${Twist}) /squelch /twist off
                        /stopsong 
                        /delay 10
                    }
                }
                /varset DontMoveMe 1
                /call CastMemSpell "${AuraSpell}" ${MiscGem} 0 CheckAura
                /varset DontMoveMe 0
            }
            /if (${Me.Gem[${AuraSpell}]}) {
                /delay 30
                /twist once ${Me.Gem[${AuraSpell}]}
                /delay 35
                /varset AuraResult TRUE
                /return ${AuraResult}
            }
        }
        | - Normal casting
        /if (${Select[${Me.Class.ShortName},BER,MNK,ROG,WAR]} && ${Me.CurrentEndurance}>500) {
            /disc ${AuraSpell}
            /delay 10
            /while (${Me.Casting.ID}) {
                /if (${DebugFramework}) /Echo Current Line ${Macro.CurLine}
				/delay 5
            }
            /varset AuraResult TRUE
            /return ${AuraResult}
        } else {
            /varset DontMoveMe 1
                /call CastWhat "${AuraSpell}" ${Me.ID} CheckAura 0 0
            /varset DontMoveMe 0
            /if (${Macro.Return.Equal[CAST_SUCCESS]}) {
                /echo Casting Aura >> ${AuraSpell} <<
                /varset AuraResult TRUE
            }
        }
        }
    /return ${AuraResult}
| -------------------------------------------------------------------------------------
| SUB: CheckEndurance
| -------------------------------------------------------------------------------------
    Sub CheckEndurance(ESpell,EPct,EHealth,int Cond#)
        /if (${Me.Invis}) /return
        /declare EndResult string local FALSE
        /if (${DebugBuffs}) /echo \atDEBUGBUFFS CheckAura Enter Spell: ${ESpell} EndPct: ${EPct} HealthPct: ${EHealth} \agLine#: ${Macro.CurLine}
        /if (${EHealth.Equal[null]} || !${EHealth.Length}) /varset EHealth 0
        /if (${DebugBuffs}) /echo DEBUGBUFFS CheckAura Endurance Regen \agLine#: ${Macro.CurLine}
        /if (${Me.Sitting}) /stand
        | /if (${Cursor.ID}) /call CheckCursor CheckEndurance
        /call CastWhat "${ESpell}" ${Me.ID} CheckEndurance 0 ${Cond#}
        /if (${Macro.Return.Equal[CAST_SUCCESS]}) {
            /varset EndResult TRUE
            /echo Casting >> ${ESpell} << for endurance
        }
        /if (${DebugBuffs}) /echo \atDEBUGBUFFS CheckAura Leave \agLine#: ${Macro.CurLine}    
    /return ${EndResult}
| -------------------------------------------------------------------------------------
| SUB: SummonStuff
| -------------------------------------------------------------------------------------    
    Sub SummonStuff(SSpell,SumItem,int SumNum,int Cond#)
        /if (${Me.Invis}) /return
        /if (${FindItemCount[=${SumItem}]}>=${SumNum}) /return 0
        /declare SumResult string local FALSE
        /declare SummonAttempts int local 0
        /declare SummonTimer timer local 0
        /declare CurrentCount int local ${FindItemCount[=${SumItem}]}
        /if (${DebugBuffs}) /echo \atDEBUGBUFFS SummonStuff Enter SSpell: ${SSpell} SumItem: ${SumItem} SumNum: ${SumNum} \agLine#: ${Macro.CurLine}
        /if (${Cond#} && ${If[${Cond[${Cond#}]},0,1]}) /return 0
        /while (${FindItemCount[=${SumItem}]}<${SumNum}) {
            /if (${DebugFramework}) /Echo Current Line ${Macro.CurLine}
			/if (${Me.FreeInventory}==0) {
                /echo No room in inventory skipping summoning >> ${SumItem} <<.
                /break
            }
            | Summon axes for zerkers had to be hard coded because spell is same name as tm item summoned.
            /if (${Select[${Me.Class.ShortName},BER]} && ${SSpell.Find[axe]}) {
                /doevents flush Missing
                /if (${Cursor.ID}) /call CheckCursor SummonStuff
                /docommand /disc ${SSpell}
                /varset SummonTimer 80
                /varset MissingComponent 0
                /while (${SummonTimer} && !${Cursor.ID} && !${MissingComponent}) {
                    /if (${DebugFramework}) /Echo Current Line ${Macro.CurLine}
					/delay 5
                    /if (!${Me.Casting.ID}) /doevents Missing
                }
                /if (${Cursor.ID}) {
                    /varcalc SummonAttempts ${SummonAttempts}+1
                    /varset SumResult CAST_SUCCESS
                } else {
                    /if (!${MissingComponent}) /doevents Missing
                    /if (${MissingComponent}) /varset SumResult CAST_COMPONENTS
                }
            } else {
                | Check if summoning from an item
                /if (${FindItemCount[=${SSpell}]} > 0) {
                    | Check if item is ready to cast
                    /if (${FindItem[=${SSpell}].Timer}!=0) {
                        /if (${DebugBuffs}) /echo \atDEBUGBUFFS ${SSpell} not ready yet skipping \agLine#: ${Macro.CurLine}
                        /varset SumResult CAST_NOT_READY
                        /return ${SumResult}
                    }
                }
                /if (${Cursor.ID}) /call CheckCursor SummonStuff
                /call CastWhat "${SSpell}" ${Me.ID} SummonStuff-nomem 0 0
                /varset SumResult ${Macro.Return}
            }
            /if (${DebugBuffs}) /echo \atDEBUGBUFFS CheckBuffs summon item cast result ${Macro.Return} ${SumResult} \agLine#: ${Macro.CurLine}
            /if (${SumResult.Equal[CAST_SUCCESS]}) {
                /delay 15s ${Cursor.ID}
                /if (${Cursor.ID}) {
                    /echo Summoned  >> ${SumItem} <<
                    /varcalc SummonAttempts ${SummonAttempts}+1
                    /call CheckCursor SummonStuff
                }
                /if (${FindItemCount[=${SumItem}]}==0 && ${SummonAttempts}>0) {
                    /echo Summoning >> ${SumItem} << Failed - Check reagents, timer, etc
                    /echo -- Turning off ${SSpell} - ${SSpell}|Summon|${SumItem}|0
                    /varset SummonAttempts 0
                    /varset SumResult CAST_COMPONENTS
                    /break
                }
            } else /if (${SumResult.Equal[CAST_COMPONENTS]}) {
                /echo You are missing components. Turning Off ${SSpell}.
                /varset SumResult CAST_COMPONENTS
                /break
            } else /if (${SumResult.Equal[CAST_NO_RESULT]}) {
                /break
            }
            /if (${SummonAttempts}>5) /break
        }
        /if (${Cursor.ID}) /call CheckCursor SummonStuff
        /if (${FindItemCount[=${SumItem}]}>${CurrentCount}) /echo I now have ${FindItemCount[=${SumItem}]} of >> ${SumItem} <<
        /if (${DebugBuffs}) /echo \atDEBUGBUFFS SummonStuff Leave ${Me.FreeInventory} ${SumResult} ${SummonAttempts} \agLine#: ${Macro.CurLine}    
    /return ${SumResult}
| -------------------------------------------------------------------------------------
| SUB: CheckIniBuffs
| -------------------------------------------------------------------------------------
    Sub CheckIniBuffs(SpellName, BuffsNum, int BuffRange, BuffName, 2ndPart, 3rdPart, 4thPart, 5thPart, BookTT, int Cond#)
        /if (${DebugBuffs}) /echo \atDEBUGBUFFS CheckIniBuffs Enter ${SpellName} ${BuffsNum} ${BuffRange} ${BuffName} ${2ndPart} ${3rdPart} ${4thPart} ${5thPart} ${BookTT} ${Cond#} \agLine#: ${Macro.CurLine}
        /declare k int local
        /declare l int local
        | Assign var IniIDList all the spawn ids from buff ini file 2345|2195|2391| etc
        /declare IniIDList string local ${Ini[framework/${MacroName}_Buffs.ini]}
        /declare IniIDCount int local ${Math.Calc[${IniIDList.Count[|]}-1]}
        /declare IniBuffCount int local 0
        /declare IniBBuffList string local
        /declare IniBuffList string local
        /declare IniStackCheck[50] string local
        /declare PBTimerID int local
        /declare IniTempBuff string local
        /declare skipFlag int local 0
        | Check Buffs from ini
        /if (${Redguides}) {
            | IniIDCount = number of Char IDs counted in ini file. If 0 skip or Buff is null the the process.
            /if (${IniIDCount}<=0 || ${SpellName.Equal[null]} || (${2ndPart.Equal[Dual]} && ${BuffName.Equal[null]})) /return
            | Start scan of buffs listed on toons in ini file
            /for k 1 to ${IniIDCount}
                /varset skipFlag 0
                /if (${AggroTargetID}) /return
                | If the Spawn ID is not in the zone and not a PC/merc and not me skip to next ID
                /if (!${Spawn[${IniIDList.Arg[${k},|]}].ID} || ${Select[${Spawn[${IniIDList.Arg[${k},|]}].Type},AURA,BANNER,CAMPFIRE,CORPSE,CHEST,ITEM,NPC,TRIGGER,TRAP,TIMER,MOUNT]} || ${IniIDList.Arg[${k},|]}==${Me.ID}) /continue
                | If Buff is a Mana,Aura,Mount,Me,Summon,End, an item, self buff or Spawn ID is me skip because none of these are cast on others
                /if (${DebugBuffs}) /echo \atDEBUGBUFFS CheckINIBuffs  IniBuffCheck 1: Mana,Aura,Mount,Me,Summon,End:${Select[${2ndPart},Mana,Aura,Mount,Me,Summon,End,0]} Item:${FindItemCount[=${SpellName}]}>=1 Self:${Spell[${SpellName}].TargetType.Find[self]} \agLine#: ${Macro.CurLine}
                | Set buff to correct spell to check for with Dual tag
                /if ((${2ndPart.Find[Dual]} && ${Spell[${SpellName}].TargetType.Equal[self]}) || ${Spell[${BuffName}].TargetType.Equal[self]} || ${BookTT.Equal[self]}) /return
                | Check for Group only spells and skip NON group members.
                /if ((${5thPart.Equal[group v1]} || ${Spell[${SpellName}].TargetType.Equal[group v1]}) && ${SpawnCount[id ${IniIDList.Arg[${k},|]} group]}==0) /continue
                | If buff marked MA skipped if spawn ID isn't MA
                /if (${Select[${2ndPart},MA,DualMA]} && ${Spawn[${IniIDList.Arg[${k},|]}].CleanName.NotEqual[${MainAssist}]} || ${2ndPart.Equal[!MA]} && ${Spawn[${IniIDList.Arg[${k},|]}].CleanName.Equal[${MainAssist}]}) /continue
                /if ((${Select[${2ndPart},Caster,DualCaster]}>0 && ${Select[${Spawn[${IniIDList.Arg[${k},|]}].Class.ShortName},CLR,DRU,SHM,BST,ENC,MAG,NEC,PAL,SHD,RNG,WIZ]}==0) || (${Select[${2ndPart},Melee,DualMelee]}>0 && ${Select[${Spawn[${IniIDList.Arg[${k},|]}].Class.ShortName},BRD,BER,BST,MNK,PAL,ROG,RNG,SHD,WAR]}==0)) /continue
                /if (${Select[${2ndPart},class,dualclass]}>0 && ${Select[${Spawn[${IniIDList.Arg[${k},|]}].Class.ShortName},${5thPart}]}==0) /continue
                /if (${DebugBuffs}) /echo \atDEBUGBUFFS CheckINIBuffs  IniBuffCheck 1.1: 2ndPart: ${2ndPart} Class Name: ${Spawn[${IniIDList.Arg[${k},|]}].Class.ShortName} \agLine#: ${Macro.CurLine}
                | Temp variable to store buff name after stripping rk stuff makes it easier to compare
                /if (${BuffName.Find[ Rk.]}) {
                    /varset IniTempBuff ${BuffName.Left[${Math.Calc[${BuffName.Find[ Rk.]}-1]}]}
                } else {
                    /varset IniTempBuff ${BuffName}
                }
                /if (${DebugBuffs}) /echo \atDEBUGBUFFS CheckINIBuffs  IniBuffCheck 2: ${Spawn[${IniIDList.Arg[${k},|]}].Name} ${IniIDList.Arg[${k},|]} ${IniTempBuff} ${BuffName} \agLine#: ${Macro.CurLine}
                | Assign var IniBBuffList blocked buffs list from ini file
                /varset IniBBuffList ${Ini[framework/${MacroName}_Buffs.ini,${IniIDList.Arg[${k},|]},"Blockedbuffs"]}
                | If the current buff is on the blocked buff list skip it.
                /if (${DebugBuffs}) /echo \atDEBUGBUFFS CheckINIBuffs  IniBuffCheck 3: ${IniBBuffList.Find[${IniTempBuff}]} Buff blocked? \agLine#: ${Macro.CurLine}
                /if (${IniBBuffList.Find[${IniTempBuff}]}) /continue
                | Assign var IniBuffList buffs list from ini file
                /varset IniBuffList ${Ini[framework/${MacroName}_Buffs.ini,${IniIDList.Arg[${k},|]},"Buffs"]}
                | If current buff is on the buff list skip it
                /if (${DebugBuffs}) /echo \atDEBUGBUFFS CheckINIBuffs IniBuffCheck 4: ${IniTempBuff} ${IniBuffList.Find[${IniTempBuff}]} \agLine#: ${Macro.CurLine}
                /if (${IniBuffList.Find[${IniTempBuff}]}) /continue
                | Assign buff count
                /varset IniBuffCount ${Math.Calc[${IniBuffList.Count[|]}]}
                | Check if current buff stacks will all existing buffs in list
                /if (${DebugBuffs}) /echo \atDEBUGBUFFS CheckINIBuffs  IniBuffCheck 5: ${Spawn[${IniIDList.Arg[${k},|]}].Name} ${IniBuffCount} BuffsNum ${SpellName} \agLine#: ${Macro.CurLine}
                /for l 1 to ${IniBuffCount}
                    | Fix for stacking issues with Perfected Group Levitation there are a lot
                    /if (${IniBuffList.Arg[${l},|].Find[Group Perfected Levitation]} && !${SpellName.Find[Group Perfected Levitation]}) /continue
                    /if (!${Spell[${IniTempBuff}].RankName.WillStack[${IniBuffList.Arg[${l},|]}]}) {
                        /varset skipFlag 1
                        /if (${DebugBuffs}) /echo \atDEBUGBUFFS CheckINIBuffs IniBuffCheck Stack: ${IniBuffList.Arg[${l},|]} !Stack ${SpellName} ${Select[${Spell[${IniBuffList.Arg[${l},|]}].WillStack[${SpellName}]},TRUE,FALSE,NULL]} \agLine#: ${Macro.CurLine}
                        /break
                    }
                /next l
                /if (!${skipFlag}) { 
                    | varset ini buff timer toon Id spell Id to shorten var and clarity
                    /varset PBTimerID ${IniIDList.Arg[${k},|]}${Spell[${SpellName}].ID}
                    | Define timer for spell i am about to cast
                    /if (!${Defined[IniBuffTimer${PBTimerID}]}) /declare IniBuffTimer${PBTimerID} timer outer 0
                    /if (${DebugBuffs}) /echo \atDEBUGBUFFS CheckINIBuffs IniBuffCheck 6: ${Spawn[${IniIDList.Arg[${k},|]}].Name} Temp:${IniTempBuff} OnList:${IniBuffList.Find[${IniTempBuff}]} Timer:${IniBuffTimer${PBTimerID}} \agLine#: ${Macro.CurLine}
                    | Check if toon is within spell range and cast buff
                    /if (${Spawn[${IniIDList.Arg[${k},|]}].Distance}<=${BuffRange} && !${IniBuffTimer${PBTimerID}}) {
                        /if (${Spell[${SpellName}].TargetType.Equal[self]} && ${Spawn[${IniIDList.Arg[${k},|]}].ID}!=${Me.ID}) {
                            /if (${DebugBuffs}) /echo \atDEBUGBUFFS CheckINIBuffs tried to buff ${Spawn[${IniIDList.Arg[${k},|]}].CleanName} with a self buff
                            /continue
                        }
                        /call CastWhat "${SpellName}" ${IniIDList.Arg[${k},|]} Buffs 0 ${Cond#}
                        /if (${DebugBuffs}) /echo \atDEBUGBUFFS CheckINIBuffs IniBuffCheck 7: /call CastWhat "${SpellName}" ${IniIDList.Arg[${k},|]} Buffs 0 ${Macro.Return} \agLine#: ${Macro.CurLine}
                        /if (${Macro.Return.Equal[CAST_SUCCESS]}) {
                            /echo Buffing >> ${SpellName} << on ${Spawn[${IniIDList.Arg[${k},|]}].CleanName}
                            /varset IniBuffTimer${PBTimerID} 60s
                            /varset IniNextTimer 0
                            /doevents flush Worn_off
                            /varset WriteBuffsTimer 0
                            /call WriteBuffs
                        } else /if (${Macro.Return.Equal[CAST_COMPONENTS]}) {
                            /echo You are missing components. Turning off ${BuffName}.
                            /varset Buffs[${BuffsNum}] NULL
                            /varset SpellName
                            /continue
                        }
                    }
                    /if (${DebugBuffs}) /echo \atDEBUGBUFFS CheckINIBuffs IniBuffCheck 8: IniBuffTimer${PBTimerID}:${IniBuffTimer${PBTimerID}} IniNextTimer:${IniNextTimer} \agLine#: ${Macro.CurLine}
                }
            /next k
        }
        /if (${DebugBuffs}) /echo \atDEBUGBUFFS CheckIniBuffs Leave \agLine#: ${Macro.CurLine}
    /return
| ----------------------------------------------------------------------------
| SUB: RegenOther
| ----------------------------------------------------------------------------
    Sub RegenOther(RGName, Stat, int StatPct, RegonOnClasses, int Cond#)
    | Casting on others during combat will interrupt fast med
    /if (${Medding} && ${MedCombat}) /return FALSE
    /if (${Me.Invis}) /return FALSE
        /if (${DebugBuffs}) /echo \atDEBUGBUFFS RegenOther Enter \agLine#: ${Macro.CurLine} ${RGName} ${Stat} ${StatPct} ${RegonOnClasses} \agLine#: ${Macro.CurLine}
        /declare i int local 
        /declare ROResult string local FALSE
        /if (${RegonOnClasses.Equal[0]} || ${RegonOnClasses.Equal[null]}) {
            /if (${Stat.Equal[endurance]}) {
                /varset RegonOnClasses BER,BST,MNK,PAL,RNG,ROG,SHD,WAR
            } else /if (${Stat.Equal[mana]}) {
                /varset RegonOnClasses BRD,BST,CLR,DRU,ENC,MAG,NEC,PAL,RNG,SHD,SHM,WIZ
            }
        }
        /for i 1 to ${Group}
            /if (${DebugBuffs}) /echo \atDEBUGBUFFS RegenOther Class: ${Group.Member[${i}].Class.ShortName} AggroID: ${AggroTargetID}  GrpMemPct: ${Group.Member[${i}].Current${Stat}}<=${StatPct} GrpMemID: ${Group.Member[${i}].ID}  \agLine#: ${Macro.CurLine}        
            | If bard rallying call aa skip tank or he won't attack
            /if (${RGName.Find[Rallying Call]} && ${Group.Member[${i}].ID}==${Spawn[${MainAssist} ${MainAssistType}].ID}) /continue 
            | Bard Dichotomic uses endurance not mana
            /if  (${RGName.Find[Dichotomic Psalm]} && ${Me.CurrentEndurance}<15000) /continue
            | Dichotomic Psalm & Quiet Miracle do not work on bards
            /if (${Group.Member[${i}].Class.Name.Equal[bard]} && (${RGName.Equal[Dichotomic Psalm]} || ${RGName.Equal[Quiet Miracle]})) /continue
            /if (${Select[${Group.Member[${i}].Class.ShortName},${RegonOnClasses}]} && !${AggroTargetID} && ${Group.Member[${i}].Current${Stat}}<=${StatPct} && ${Group.Member[${i}].Current${Stat}}>=1 && ${Group.Member[${i}].ID}) {            
                /call CastWhat "${RGName}" ${Group.Member[${i}].ID} Regenother 0 ${Cond#}
                /if (${Macro.Return.Equal[CAST_SUCCESS]}) {
                    /echo Casting ${RGName} on ${Group.Member[${i}].CleanName} for ${Stat}.
                    /varset ROResult TRUE
                    /break
                }
            }
        /next i
        /if (${DebugBuffs}) /echo \atDEBUGBUFFS RegenOther Leave ${ROResult} \agLine#: ${Macro.CurLine}
    /return ${ROResult}    
| -------------------------------------------------------------------------------------
| SUB: Target Window Buffs
| -------------------------------------------------------------------------------------     
    Sub TargetWinBuffs(int TWtargetID, Checkbuff, FromSub)
        /if (!${Checkbuff.Length} || ${Spawn[TWtargetID].ID}) /return
        /declare i int local
        /for i 0 to 50
            /if (${Window[TargetWindow].Child[Target_Buff${i}_Button].Tooltip.Find[${Checkbuff}]}) {
                /echo ${Target.CleanName} has ${Checkbuff} skipping to next buff
                /if (${FromSub.Equal[CastWhat]}) /call Interrupt
                /return TRUE 
            }
        /next i
    /return 
| -------------------------------------------------------------------------------------
| SUB: PetStateCheck
| -------------------------------------------------------------------------------------
    Sub PetStateCheck 
        /if (${DebugPet}) /echo Checking Pet State. \agLine#: ${Macro.CurLine}
        /if (${Me.AltAbility[Companion's Suspension]}>0) {    
            /while (!${Me.AltAbilityReady[Companion's Suspension]}) {
				/if (${DebugFramework}) /Echo Current Line ${Macro.CurLine}
                /echo Waiting on Suspend Minion AA to be ready.
                /delay 10
            }
            /alt act ${Me.AltAbility[Companion's Suspension].ID}
            /delay 5s !${Me.Casting.ID}
            /doevents
        } else {
            /echo You do not have the "Companion's Suspension" AA, PetSuspend being turned off.
            /varset PetSuspend 0    
        }
        /if (${Me.Pet.ID}) /varset PetActiveState  1
    /return
| -------------------------------------------------------------------------------------
| SUB: DoPetStuff
| -------------------------------------------------------------------------------------
    Sub DoPetStuff
        /if (!${PetOn} || ${CampZone}!=${Zone.ID} ) /return
        /if (${AggroTargetID} || ${Me.Invis} || ${Me.Hovering}) /return
        /declare PetSummonTimer timer local 60s
        /doevents
        /if (${Debug}) /echo \atDEBUG DoPetStuff Enter \agLine#: ${Macro.CurLine}
        /declare FocusCurrent string local ${InvSlot[${PetFocus.Arg[2,|]}].Item.Name}
        /declare FocusSlot string local ${PetFocus.Arg[2,|]} ${PetFocus.Arg[1,|]}
        /declare FocusPet string local ${PetFocus.Arg[1,|]}
        /declare FocusSwitch int local 0
        /if (${Me.Pet.CleanName.Equal[${Me.Name}`s familiar]}) /pet get lost
        | Swap pet focus in pet cast
        /if (!${Me.Pet.ID} && ${Spell[${PetSpell}].Mana}<=${Me.CurrentMana}) {
            | verbose
            /echo I have no pet. ${Me.Class}s live longer when we have pets.
            /varset PetActiveState 0
            /if (${PetFocus.Arg[1,|].Length} && ${FindItemCount[=${FocusPet}]}) {
                /if (!${Cursor.ID} && ${FocusPet.NotEqual[${FocusCurrent}]}) {
                    /exchange "${FocusPet}" ${FocusSlot}
                    /varset FocusSwitch 1
                    /delay 10
                }
            }
            /doevents
            /delay 3
            | Pet spell mem check - Else try item like mage epic
            /call CastWhat "${PetSpell}" ${Me.ID} DoPetStuff 0 0
            | Summon Pet
            |- If using suspended pet function.
            /if (${PetSuspend}) {
               |- If I have a suspended pet bust him out!
               /if ((${PetTotCount}==1) && (${PetActiveState}==0) && (${PetSuspendState}==1)) {
                   /echo I have a suspended pet, summoning it now!
                   /call PetStateCheck           
               }
               |- If I don't have a suspended or an active pet, make them.
               /if (${PetTotCount}<2 && ${PetSuspendState}==0 && ${PetActiveState}==0 && ${Me.Book[${PetSpell}]} && ${Spell[${PetSpell}].Mana}<=${Me.CurrentMana}) {
                    |:MakeMyPet1
                    /while (1) {
						MOBINCAMP
                        /echo - Making pet now.
                        /echo ARISE ${PetSpell}
                        /call CastWhat "${PetSpell}" ${Me.ID} DoPetStuff 0 0
                        /if (${Macro.Return.Equal[CAST_COMPONENTS]}) {
                            /echo You are missing components to make this pet. Ending macro.
                            /endmacro
                        } 
                        /delay 1s ${Me.Pet.ID}
                        /if (!${PetSummonTimer}) /break
                        /if (!${Me.Pet.ID}) /continue
                        /if (${Me.Pet.ID}) {
                            /echo My pet is now: ${Me.Pet.CleanName} from ${PetSpell}
                            /varset PetActiveState 1
                            /call CheckPetBuffs
                            /if (${PetToysOn}) {
                                /call PetToys ${Me.Pet.CleanName}
                                /if ((${PetSuspendState}==0) && (${PetActiveState}==1)) /varset PetToysDone 0
                                /if ((${PetSuspendState}==1) && (${PetActiveState}==1)) /varset PetToysDone 1
                            }
                        }
                        /call PetStateCheck
                        /if (${PetTotCount}==2 || !${PetSuspend} || !${PetSummonTimer}) /break
                    }
                }
            } else /if (${Me.Book[${PetSpell}]} && ${Spell[${PetSpell}].Mana}<=${Me.CurrentMana}) {
                | Normal pet function for not using suspend pet.
                /while (1) {
                    /echo ARISE ${PetSpell}
                    /call CastWhat "${PetSpell}" ${Me.ID} DoPetStuff 0 0
                    /if (${Macro.Return.Equal[CAST_COMPONENTS]}) {
                        /echo You are missing components to make this pet. Ending macro.
                        /endmacro
                    } 
                    /delay 1s ${Me.Pet.ID}
                    /if (!${PetSummonTimer} || ${Me.Pet.ID}) /break
                }
                /if (${Me.Pet.ID}) {
                    /echo My pet is now: ${Me.Pet.CleanName} from ${PetSpell}
                    /varset PetActiveState 1                
                }
                | Swap pet focus out for regular item
                /if (${FocusSwitch} && !${Cursor.ID}) {
                    /exchange "${FocusCurrent}" ${FocusSlot}
                    /delay 10
                }            
            }
            | Reset PetToysGave in config after pet creation, as well as memory variable so we will pickup if our pet needs toys after death, under new condition checks.
            /ini "${IniFileName}" "Pet" "PetToysGave" ""
            /if (${Me.Pet.ID} && ${PetToysOn}) /varset PetToysGave "NULL"
            /if (${Select[${Role},puller,pullertank,pettank,pullerpettank]} && ${Me.Pet.Distance}<=${CampRadius}) /pet guard
            /if (${Select[${Role},puller,pullertank,pettank,pullerpettank]} && ${Me.Pet.Distance}>${CampRadius}) /pet follow
            /if (${PetHoldOn}) /pet ${PetHold} on      
            /if (${Me.AltAbility[Pet Discipline]}>5) /pet focus on
            /if (!${PetTauntOn} && ${Select[${Role},pettank,pullerpettank]}) /pet taunt on
        }
        /call CheckPetBuffs
        | Pet Toy routines
        | Condition revised to only call PetToys if I do not have my pet name in the PetToysGave string.
        /if (${Me.Pet.ID} && ${PetToysOn} && (!${PetToysGave.Find[${Me.Pet.CleanName}]} || !${PetToysGave.Find[Summoned]})) /call PetToys ${Me.Pet.CleanName}
        | Check to have pet come to owner if owner out of camp too long.
        /if (${Select[${Role},pettank,hunterpettank]} && ${Math.Distance[${Me.Y},${Me.X}:${CampYLoc},${CampXLoc}]}>${CampRadius} && (${Math.Distance[${Me.Pet.Y},${Me.Pet.X}:${CampYLoc},${CampXLoc}]}<=${CampRadius}) && ${Me.Pet.Stance.Equal[GUARD]}) /pet follow
        /if (${Me.Pet.ID} && ${Me.Gem[${MiscGem}].Name.NotEqual[${ReMemMiscSpell}]} && ${MiscGemRemem}) {
            /varset DontMoveMe 1
            /call CastMemSpell "${ReMemMiscSpell}" ${MiscGem} 0 DoPetStuff
            /varset DontMoveMe 0
        }
        /if (${Debug}) /echo \atDEBUG DoPetStuff Leave \agLine#: ${Macro.CurLine}
    /return
| -------------------------------------------------------------------------------------
| SUB: CheckPetBuffs
| -------------------------------------------------------------------------------------
    Sub CheckPetBuffs
        /if (!${Me.Pet.ID}) /return
        /if (!${PetOn}) /return
        /if (!${PetBuffsOn}) /return
        /if (${CombatStart}) /return
        /if (${Pulling}) /return
        /if (${PetBuffCheck}) /return
        /if (${Me.Invis}) /return
        /if (${Debug}) /echo \atDEBUG CheckPetBuffs Enter \agLine#: ${Macro.CurLine}
        /declare PTempBuff string local
        /declare i int local
        /declare j int local
        /declare 1stPart string local 0
        /declare 2ndPart string local 0
        /declare 3rdPart string local 0                
        /declare FoundPetBuff int local 0
        /varset PetBuffCheck 60s
        /for i 1 to ${PetBuffs.Size}
            /doevents
            | Stop pet buffing if aggro detected
            /if (${AggroTargetID}) /return
            /if (${PetBuffs[${i}].Equal[Null]}) /continue
            | Check for pet spells in book to prevent double casting of items
            /if (${Me.Book[${PetBuffs[${i}]}]} || ${Me.AltAbilityReady[${PetBuffs[${i}]}]}) {
                /if (${PetBuffs[${i}].Find[ Rk.]}) {
                    /varset PTempBuff ${PetBuffs[${i}].Left[${Math.Calc[${PetBuffs[${i}].Find[ Rk.]}-1]}]}
                } else {
                    /varset PTempBuff ${PetBuffs[${i}]}
                }
                /if (${Debug}) /echo \atDEBUG CheckPetBuffs ${i} ${Me.PetBuff[${PTempBuff}]} ${PetBuffs[${i}]} ${PTempBuff} \agLine#: ${Macro.CurLine}
                /for j 1 to 50
                    /if (${Me.PetBuff[${j}].Name.Find[${PTempBuff}]}) /varset FoundPetBuff 1
                /next j
                /if (!${FoundPetBuff}) {
                    | Vebrose
                    /call CastWhat "${PetBuffs[${i}]}" ${Me.Pet.ID} Pet-nomem 0 0
                    /delay 20
                    /if (${Macro.Return.Equal[CAST_SUCCESS]}) /echo Buffing ${Me.Pet.CleanName}, my pet, with ${PetBuffs[${i}]}
                    /varset FoundPetBuff 0
                    /continue
                }
            }
            /if (${Debug}) /echo \atDEBUG CheckPetBuffs ${FindItem[=${PetBuffs[${i}]}].Spell} ${Me.PetBuff[${FindItem[=${PetBuffs[${i}]}].Spell}]} \agLine#: ${Macro.CurLine}
            /if (${Me.PetBuff[${FindItem[=${PetBuffs[${i}]}].Spell}]}>0) /continue
            |- Cast item clicky buff (ItemName and PetBuff = DIFFERENT)
            |--- START: Multipart handling for PetBuffs.
            /if (${PetBuffs[${i}].Find[|]}) {            
                /varset 1stPart ${PetBuffs[${i}].Arg[1,|]}
                /varset 3rdPart ${PetBuffs[${i}].Arg[3,|]}
                /varset PTempBuff ${3rdPart}
                |--- START: DUAL Handle for different Effect names versus their Item name
                /if (${Debug}) /echo \atDEBUG CheckPetBuffs - Dual - ${1stPart} - ${3rdPart} \agLine#: ${Macro.CurLine}
                /if (${PetBuffs[${i}].Arg[2,|].Equal[Dual]}) {
                    /if (${FindItem[=${1stPart}].ID}) {
                        /for j 1 to 50
                            /if (${Me.PetBuff[${j}].Name.Find[${PTempBuff}]}) /varset FoundPetBuff 1
                        /next j
                        /if (!${FoundPetBuff}) {
                            |Vebrose
                            /call CastWhat "${1stPart}" ${Me.Pet.ID} Pet 0 0
                            /delay 20
                            /if (${Macro.Return.Equal[CAST_SUCCESS]}) /echo Buffing ${Me.Pet.CleanName}, my pet, with (${3rdPart})
                            /varset FoundPetBuff 0        
                            /continue
                        }
                    }
                }
                |--- END: DUAL Handle for different Effect names versus their Item name                
            }
            |--- END: Multipart handling for PetBuffs.
            |- Cast item clicky buff (ItemName and PetBuff = SAME)
            /if (${FindItem[=${PetBuffs[${i}]}].ID}) {
                /call CastWhat "${PetBuffs[${i}]}" ${Me.Pet.ID} Pet 0 0
            }
            /varset FoundPetBuff 0
        /next i
        /if (${Debug}) /echo \atDEBUG CheckPetBuffs Pet Height: ${Me.Pet.Height} \agLine#: ${Macro.CurLine}
        /if (${Me.Pet.Height}>1.35 && ${PetShrinkOn}) {
            /call CastWhat "${PetShrinkSpell}" ${Me.Pet.ID} Pet 0 0
            /delay 20
        }
        /if (${Target.ID}==${Me.Pet.ID}) /squelch /target clear
        /if (${Debug}) /echo \atDEBUG CheckPetBuffs Leave \agLine#: ${Macro.CurLine}
    /return
| ----------------------------------------------------------------------------
| SUB: Check PetToys - Based on code from el_nene's autobot. Used with permission.
| Autobot is available at www.Macroquest2.com VIP macro section.
| Updated and Revised for KissAssist
| ----------------------------------------------------------------------------
    Sub PetToys(string petName)
        /if (!${Me.Pet.ID}) /return
        /if (${DebugPet}) /echo \atDEBUGPet PetToys Enter \agLine#: ${Macro.CurLine}
        /declare i int local
        /declare j int local
        /declare GrabItem int local 0
        /declare PetToySpell string local 0
        /declare FullText string local
        /declare 2ndPart string local
        /declare 3rdPart string local
        /declare PetToysTemp string local ${Ini[${IniFileName},Pet,PetToysGave]}
        /declare GaveItem int local 1
        /call OpenInvSlot
        /declare petID int local ${Spawn[pet ${petName}].ID}
        /if (${BagNum}==0) {
            /echo You must have an empty Top Inventory slot for Pet Toys to work.
            /varset PetToysOn 0
            /return
        }
        /if (!${InvSlot[pack${BagNum}].Item.Container} && !${Me.FreeInventory}) {
            /echo Inventory is full
            /varset PetToysOn 0
            /return
        }
        | reset if different pet name only on my pet
        /if (!${PetToysTemp.Find[${petName}]} && ${Me.Pet.CleanName.Equal[${petName}]}) {
            /ini "${IniFileName}" "Pet" "PetToysGave" "0"
            /varset PetToysTemp ${Ini[${IniFileName},Pet,PetToysGave]}
        }
        /for i 1 to ${PetToys.Size}
            /if (!${PetToysOn}) /return
            /echo ${PetToys[${i}]}
            /if (${DebugPet}) /echo CHECKING: ${PetToys[${i}]} \agLine#: ${Macro.CurLine}
            /if (${DebugPet}) {
                /echo \atDEBUGPET PetToys 1: ${PetToys[${i}]} \agLine#: ${Macro.CurLine}
                /echo \atDEBUGPET PetToys 2: ${PetToysTemp} \agLine#: ${Macro.CurLine}
                /echo \atDEBUGPET PetToys 3: ${PetToys[${i}].Equal[Null]} || ${PetToysTemp.Find[${petName}]} && ${PetToysTemp.Find[${PetToys[${i}]}]} \agLine#: ${Macro.CurLine}
            }
            | Had to add pet name check else it will always skip giving weapons to OTHER pets.                        
            /if (${DebugPet}) /echo \atDEBUGPET PetToys ${PetToys[${i}].Equal[Null]} || (${Me.Pet.CleanName.Equal[${petName}]} && ${PetToysTemp.Find[${petName}]} && ${PetToysTemp.Find[${PetToys[${i}]}]}) SkipPetToy 1 \agLine#: ${Macro.CurLine}
            /if (${PetToys[${i}].Equal[Null]} || (${Me.Pet.CleanName.Equal[${petName}]} && ${PetToysTemp.Find[${petName}]} && ${PetToysTemp.Find[${PetToys[${i}]}]})) /continue
            | Are we handing weapons to the pet
            /if (${PetToys[${i}].Arg[2,|].Length} && ${PetToys[${i}].Arg[2,|].NotEqual[null]}) {
                /varset FullText ${PetToys[${i}]}
                /varset PetToySpell ${PetToys[${i}].Arg[1,|]}
                /varset 2ndPart ${PetToys[${i}].Arg[2,|]}
                /varset 3rdPart ${PetToys[${i}].Arg[3,|]}
            } else {
                /varset FullText
                /varset PetToySpell ${PetToys[${i}]}
                /varset 2ndPart
                /varset 3rdPart
            }
            /if (${DebugPet}) /echo \atDEBUGPET PetToys ${Me.Pet.CleanName.Equal[${petName}]} && ${2ndPart.Length} && ${PetToysTemp.Find[1]} && ${PetToysTemp.Find[2]} SkipPetToy 2 \agLine#: ${Macro.CurLine}
            /if (${Me.Pet.CleanName.Equal[${petName}]} && ${2ndPart.Length} && ${PetToysTemp.Find[1]} && ${PetToysTemp.Find[2]}) /continue
            | Check if spell level less than 76 because mage pets auto equipped after that.
            /if (${Me.Pet.CleanName.Equal[${petName}]} && ${Spell[${PetToySpell}].Level}>=76 && (${PetToySpell.Find[muzzle]} || ${PetToySpell.Find[visor]} || ${PetToySpell.Find[belt]})) /continue
            | Check for pet toy spells in book to prevent double casting of items
            /if (${Me.Book[${PetToySpell}]}) {
                /call CastWhat "${PetToySpell}" ${Me.ID} Pet-nomem 0 0
                /if (!${PetToysTemp.Find[${petName}]} && ${Me.Pet.CleanName.Equal[${petName}]}) {
                    /ini "${IniFileName}" "Pet" "PetToysGave" "${petName}"
                    /varset PetToysTemp ${Ini[${IniFileName},Pet,PetToysGave]}
                }
                /if (${Macro.Return.Equal[CAST_SUCCESS]}) {
                    /echo Casting pet toy spell >> ${PetToySpell} <<
                }

                /delay 15s ${Cursor.ID}
                /if (!${Cursor.ID}) /return
                | Check if spell has summoned a bag or folded pack
                /if (${Cursor.Container} || ${Cursor.Name.Find[Folded]}) {
                    | If item is in Inv Slot exchange it with bag on cursor
                    /if (${InvSlot[pack${i}].Item.ID}) /nomodkey /itemnotify pack${BagNum} leftmouseup
                    /while (1) {
                        /if (${DebugFramework}) /Echo Current Line ${Macro.CurLine}
						/delay 2s ${Cursor.ID}
                        | Drop bag or item into inventory
                        /autoinventory
                        /delay 1s
                        | Drop exchanged item into inventory after bag is dropped
                        /if (${Cursor.ID}) /autoinventory
                        | If folded pack right click to convert to phantom satchel
                        /if (${InvSlot[pack${BagNum}].Item.Name.Find[folded]}) {
                            /nomodkey /itemnotify pack${BagNum} rightmouseup
                            /echo Opening ${InvSlot[pack${BagNum}].Item.Name}
                            /delay 3s
                        } else {
                            /break
                        }
                    }
                }
                /if (${InvSlot[pack${BagNum}].Item.Container} && (${InvSlot[pack${BagNum}].Item.Name.Find[Phantom Satchel]} || ${InvSlot[pack${BagNum}].Item.Name.Find[Pouch of Quellious]})) {
                    | Open the bag
                    /nomodkey /itemnotify pack${BagNum} rightmouseup
                    /delay 10
                    /if (${DebugPet}) /echo \atDEBUGPET PetToys ${i} ${PetToySpell} ${2ndPart} ${3rdPart} \agLine#: ${Macro.CurLine}
                    | Condition revised to allow for pet weapons to be given to other people's pets.
                    /if (((${Me.Pet.CleanName.Equal[${petName}]} && !${PetToysTemp.Find[${2ndPart}1]}) && ${2ndPart.Length} && ${FindItemCount[=${2ndPart}]}) || (!${Me.Pet.CleanName.Equal[${petName}]} && ${2ndPart.Length} && ${FindItemCount[=${2ndPart}]})) {
                        /call GiveTo "${2ndPart}" ${petID}
                        /varset PetToysTemp ${PetToysTemp}|${PetToySpell}:${2ndPart}1
                        /if (${Me.Pet.CleanName.Equal[${petName}]}) /ini "${IniFileName}" "Pet" "PetToysGave" "${PetToysTemp}"
                    }
                    | Condition revised to allow for pet weapons to be given to other people's pets.
                    /if (((${Me.Pet.CleanName.Equal[${petName}]} && !${PetToysTemp.Find[${3rdPart}2]}) && ${3rdPart.Length} && ${FindItemCount[=${3rdPart}]}) || (!${Me.Pet.CleanName.Equal[${petName}]} && ${3rdPart.Length} && ${FindItemCount[=${3rdPart}]})) {                  
                        /call GiveTo "${3rdPart}" ${petID}
                        /varset PetToysTemp ${PetToysTemp}|${PetToySpell}:${3rdPart}2
                        /if (${Me.Pet.CleanName.Equal[${petName}]}) /ini "${IniFileName}" "Pet" "PetToysGave" "${PetToysTemp}"
                    }
                    /if (!${2ndPart.Length}) {
                        /for j 0 to ${InvSlot[pack${BagNum}].Item.Container}
                            /if (${InvSlot[pack${BagNum}].Item.Item[${j}].ID} && ${InvSlot[pack${BagNum}].Item.Item[${j}].Name.Length}) {
                                /call GiveTo "${InvSlot[pack${BagNum}].Item.Item[${j}].Name}" ${petID}
                            }
                            /delay 10
                        /next j
                        /if (${j}>=8 && !${PetToysTemp.Find[${PetToySpell}]} && ${Me.Pet.CleanName.Equal[${petName}]}) {
                            /varset PetToysTemp ${PetToysTemp}|${PetToySpell}
                            /ini "${IniFileName}" "Pet" "PetToysGave" "${PetToysTemp}"
                        }
                    }
                }
                /if (${Cursor.Name.Find[Summoned:]}) {
                    /if (${2ndPart.Length} && !${PetToysTemp.Find[1]}) { 
                        /varset PetToysTemp ${PetToysTemp}|${PetToySpell}:${2ndPart}1
                    } else /if (${2ndPart.Length} && ${PetToysTemp.Find[1]} ) {
                        /varset PetToysTemp ${PetToysTemp}|${PetToySpell}:${2ndPart}2
                    } else /if (!${2ndPart.Length} && !${PetToysTemp.Find[${PetToySpell}]}) {
                        /varset PetToysTemp ${PetToysTemp}|${PetToySpell}:${Cursor.Name}
                    }
                    /call GiveTo "${Cursor.Name}" ${petID}
                    /if (${Me.Pet.CleanName.Equal[${petName}]}) /ini "${IniFileName}" "Pet" "PetToysGave" "${PetToysTemp}"
                    /varset GaveItem 0
                }
                /if (${InvSlot[pack${BagNum}].Item.Name.Find[Phantom Satchel]} || ${InvSlot[pack${BagNum}].Item.Name.Find[Pouch of Quellious]}) /call DestroyBag
            }
        /next i
        | MUST reset PetToysGave after cycle complete in order to stop calling PetToys all the time.
        /varset PetToysGave ${PetToysTemp}
        /if (${Window[InventoryWindow].Open} && !${GaveItem}) /keypress inventory
        /varset PetToysDone 1
        /if (${DebugPet}) /echo \atDEBUGPET PetToys Leave \agLine#: ${Macro.CurLine}
    /return
| ----------------------------------------------------------------------------
| SUB: Check OpenInvSlot - Based on code from el_nene's autobot. Used with permission.
| Autobot is available at www.Macroquest2.com VIP macro section.
| Updated and Revised for KissAssist
| ----------------------------------------------------------------------------
    Sub OpenInvSlot
        /if (${DebugBuffs}) /echo \atDEBUGBUFFS OpenInvSlot Enter \agLine#: ${Macro.CurLine}
        /if (${BagNum}) /return
        /declare i int local
        /varset BagNum 0
        /for i 1 to 10
            /if (${InvSlot[pack${i}].Item.Container}) /continue
            /if (!${InvSlot[pack${i}].Item.Container} || ${InvSlot[pack${i}].Item.ID}==0) {
                | Must have at least 2 inv slots open in order to swap bags and items
                /if (${Me.FreeInventory}>=2) /varset BagNum ${i}
            }    
            /if (${BagNum}) {
                /echo Pet Toys: Inventory slot ${i} is empty using that one.
                /delay .5
                /return
            }
        /next i
        /if (${DebugBuffs}) /echo \atDEBUGBUFFS OpenInvSlot Leave  \agLine#: ${Macro.CurLine}
    /return
| ----------------------------------------------------------------------------
| SUB: Check DestroyBag - Based on code from el_nene's autobot. Used with permission.
| Autobot is available at www.Macroquest2.com VIP macro section.
| Updated and Revised for KissAssist
| ----------------------------------------------------------------------------
    Sub DestroyBag
        /if (${DebugBuffs}) /echo \atDEBUGBUFFS DestroyBag Enter  \agLine#: ${Macro.CurLine}
        /declare j int local
        | Make sure bag has no items other than summoned in it before deleting.
        /if (${InvSlot[pack${BagNum}].Item.Items}) {
            /for j 0 to ${InvSlot[pack${BagNum}].Item.Container}
                /if (!${InvSlot[pack${BagNum}].Item.Item[${j}].NoRent} && ${InvSlot[pack${BagNum}].Item.Item[${j}].Name.Length}) {
                    /echo Bag has non summoned item(s) in it. Aborting delete. Pet Toys Off
                    /varset PetToysOn 0
                    /return
                }
            /next j
        }
        /if (${InvSlot[pack${BagNum}].Item.Name.Find[Phantom Satchel]} || ${InvSlot[pack${BagNum}].Item.Name.Find[Pouch of Quellious]}) {
            /nomodkey /itemnotify pack${BagNum} leftmouseup
            /delay 5s ${Cursor.ID}
            /if (${Cursor.Name.Find[Phantom Satchel]} || ${Cursor.Name.Find[Pouch of Quellious]}) /destroy
            /delay 20 !${Cursor.ID}
        }
        /if (${DebugBuffs}) /echo \atDEBUGBUFFS Leave \agLine#: ${Macro.CurLine}
    /return
| ----------------------------------------------------------------------------
| SUB: Check GiveTo - Based on code from el_nene's autobot. Used with permission.
| Autobot is available at www.Macroquest2.com VIP macro section.
| Updated and Revised for KissAssist
| ----------------------------------------------------------------------------
    Sub GiveTo(string GItem, int GTarget)
        /if (${DebugBuffs}) /echo \atDEBUGBUFFS GiveTo Enter \agLine#: ${Macro.CurLine}
        /declare ItemSummoned int local 0
        /if (${Target.ID}!=${GTarget}) {
            /target id ${GTarget}
            /delay 2s ${Target.ID}==${GTarget}
        }
        /if (${Target.Distance}>10 && ${Target.Distance}<=${CampRadius}) {
            /moveto id ${Target.ID}
            /delay 50 ${MoveTo.Stopped}
        }
        /if (!${Cursor.ID} && ${FindItemCount[=${GItem}]}>0) {
            /shift /itemnotify "${GItem}" leftmouseup
            /delay 20 ${Cursor.ID}
        }
        /while (${Cursor.ID} && ${Cursor.NoRent}) {
            /if (${DebugFramework}) /Echo Current Line ${Macro.CurLine}
			/if (${Cursor.ID}==${FindItem[=${GItem}].ID}) {
                /varset ItemSummoned 1
                /nomodkey /click left target
            }
            /delay 10
        }
        /delay 30 ${Window[GiveWnd].Open}
        /if (${ItemSummoned} && ${Window[GiveWnd].Open}) {
            /notify GiveWnd GVW_Give_Button leftmouseup
            /echo Giving ${GItem} to ${Target.CleanName}
        } else {
            /echo Item is NOT SUMMONED canceling trade
            /notify GiveWnd GVW_Cancel_Button leftmouseup
        }
        /delay 15 
        | New pet patch gives back item if pet has equipped. Delete item from cursor.
        /if (${Cursor.ID} && (${Cursor.NoRent} || ${Cursor.Name.Find[muzzle]} || ${Cursor.Name.Find[visor]} || ${Cursor.Name.Find[belt]}) && ${Cursor.ID}==${FindItem[=${GItem}].ID}) {
            /while (${Cursor.ID}) {
                /if (${DebugFramework}) /Echo Current Line ${Macro.CurLine}
				/destroy
                /delay 10
            }
        }
        /delay 200 !${Window[GiveWnd].Open}
        /if (${DebugBuffs}) /echo \atDEBUGBUFFS GiveTo Leave \agLine#: ${Macro.CurLine}
    /return
| ----------------------------------------------------------------------------
| SUB: Check Plugin
| ----------------------------------------------------------------------------
    Sub CheckPlugin(string pluginname)
        /declare WaitTimer1 timer local 50
        /if (${Debug}) /echo \atDEBUG CheckPlugin: Enter \agLine#: ${Macro.CurLine}
        /if (!${Bool[${Plugin[${pluginname}]}]}) {
            /squelch /plugin ${pluginname}
            /echo ${pluginname} not detected! This macro requires it! Loading ...
            /while (${WaitTimer1} && !${Bool[${Plugin[${pluginname}]}]}) {
                /if (${DebugFramework}) /Echo Current Line ${Macro.CurLine}
				/delay 5
            }
        }
        /if (${Debug}) /echo \atDEBUG CheckPlugin: Leave \agLine#: ${Macro.CurLine}
    /return
| ----------------------------------------------------------------------------
| SUB: Load Ini
| ----------------------------------------------------------------------------
    Sub LoadIni(string sectionName, string varName, string varType, string varValue, string varArray, string FileName)
        /if (${Debug}) {
            /delay 2
            /echo \atDEBUG Sub Loadini S:${sectionName} V1:${varName} V2:${varType} V3:${varValue} V4:${varArray}  \agLine#: ${Macro.CurLine}
        }
        /declare rkTemp                 string      local 
        /declare UtilInt                int         local        0 
        /declare FileName1              string      local        ${FileName}
        | Assign ini name to default ini if not defined
        /if (${FileName1.Length}==0  || ${FileName1.Equal[NULL]}) {
            /varset FileName1 ${IniFileName}
        }
        | Check if ini value is asking for an array ie buff1 to buff20
        /if (${Bool[${varArray}]}) {
            /if (${${varArray}.Size}>0) {
                /declare i int local
                /for i 1 to ${${varArray}.Size}
                    /if (${sectionName.NotEqual[KConditions]}) {
                        /if (!${Ini[${FileName1},${sectionName},${varArray}${i}].Length}) /ini "${FileName1}" "${sectionName}" "${varArray}${i}" "${varValue}"
                        /if (${Ini[${FileName1},${sectionName},${varArray}${i}].Length}) /varset ${varArray}[${i}] ${Ini[${FileName1},${sectionName},${varArray}${i}]}
                        /if (${${varArray}[${i}].NotEqual[null]}) {
                            | find out if there is a Rank and fix spell name.
                            /if (${varType.Equal[string]} && ${Int[${${varArray}[${i}].Left[1]}]}==0) {
                                    /call SpellRankCheck "${${varArray}[${i}]}"
                                /varset ${varArray}[${i}] ${Macro.Return}
                            }
                            | code to fix the Heal PCT for those zones Crypt of Sul, that knock your HPs down to 
                                /if (${Int[${${varArray}[${i}].Arg[2,|].Left[1]}]}>0) {
                                /if (${sectionName.Equal[Heals]}) {
                                    /if (${${varArray}[${i}].Arg[3,|].Find[rez]}) {
                                        /varcalc UtilInt ${i}+100
                                        /varset ${varArray}[${i}] ${${varArray}[${i}].Replace[|${${varArray}[${i}].Arg[2,|]},|${UtilInt}]}
                                    } else /if (${Select[${Zone.ID},795,796]}) {
                                    /varcalc UtilInt ${Int[${${varArray}[${i}].Arg[2,|]}]}*.7
                                    /varset ${varArray}[${i}] ${${varArray}[${i}].Replace[|${${varArray}[${i}].Arg[2,|]},|${UtilInt}]}
                                }
                                } else /if (${sectionName.Equal[DPS]} && ${${varArray}[${i}].Arg[3,|].Equal[debuffall]}) {
                                /varcalc UtilInt ${Int[${${varArray}[${i}].Arg[2,|]}]}+100
                                /varset ${varArray}[${i}] ${${varArray}[${i}].Replace[|${${varArray}[${i}].Arg[2,|]},|${UtilInt}]}
                            }
                        }
                        }
                    } else {
                        /if (!${Ini[${FileName1},${sectionName},${varArray}${i}].Length}) {
                            /ini "${FileName1}" "${sectionName}" "${varArray}${i}" "${varValue}"
                        } else {
                            /varset ${varArray}[${i}]  ${Ini[${FileName1},${sectionName},${varArray}${i},NULL,noparse]}
                            /if (${Debug}) /echo ${varArray}[${i}]  ${Ini[${FileName1},${sectionName},${varArray}${i},NULL,noparse]}
                        }
                    }
                    /if (${Debug}) /echo  \atDEBUG Loadini ${i} - ${varArray}[${i}] - ${${varArray}[${i}]} \agLine#: ${Macro.CurLine}
                /next i
                /return
            }
        } else {
            /if (!${Defined[${varName}]} && ${Select[${varType},string,float,int]}>0) /declare ${varName} ${varType} outer 0
                /if (!${Ini[${FileName1},${sectionName},${varName}].Length}) {
                    /if (${varValue.Length}) {
                        /ini "${FileName1}" "${sectionName}" "${varName}" "${varValue}"
                        /varset ${varName} ${varValue}
                        /if (${Debug}) /echo \atDEBUG Sub Loadini /varset ${varName} ${varValue} \agLine#: ${Macro.CurLine}
                    }
                } else {
                    /varset ${varName} ${Ini[${FileName1},${sectionName},${varName}]}
                }
                /if (${FileName1.Equal[${IniFileName}]}) {
                    /varset rkTemp ${${varName}}
                    | find out if there is a Rank and fix spell name.
                    /if (${varType.Equal[string]} && ${Int[${rkTemp.Left[1]}]}==0 && !${varName.Find[Help]}) {
                        /call SpellRankCheck "${${varName}}"
                        /if (${Macro.Return.NotEqual[null]}) /varset ${varName} ${Macro.Return}
                    }
                }
            /if (${Debug}) /echo \atDEBUG Sub LoadIni: ${varName} - ${${varName}} \agLine#: ${Macro.CurLine}
            /varset rkTemp 
        }
        /if (${Debug}) /echo \atDEBUG Sub LoadIni: Leave \agLine#: ${Macro.CurLine}
    /return
| ----------------------------------------------------------------------------
| SUB: End Mac If
| ----------------------------------------------------------------------------
    Sub EndMacroIf
        /if (${Debug}) /echo \atDEBUG EndMacroIf: Enter \agLine#: ${Macro.CurLine}
        | I died wait for rez loop
        /while (${Me.Hovering}) {
            /if (${DebugFramework}) /Echo Current Line ${Macro.CurLine}
			/delay 5
        }
        /while (${CampZone}!=${Zone.ID} && ${RezAcceptOn.Arg[1,|].Equal[1]} && ${IAmDead} && ${Me.ID}) {
            /if (${DebugFramework}) /Echo Current Line ${Macro.CurLine}
			/if (${EverQuest.GameState.Equal[CHARSELECT]}) /endmac
            /if (${Attacking}) /call CombatReset 0 endmacroif
            /delay 10
            /if (${ClickBacktoCamp}) /call CampfireBack
            /if (${CampOnDeath}) /call DoICamp
        }
        /if (${RezAcceptOn.Arg[1,|].Equal[0]} && ${CampZone} != ${Zone.ID}) {
            /if (${CampOnDeath}) /call DoICamp
            /if (${IAmDead}) {
                /while (${Me.BardSongPlaying}) {
                    /if (${DebugFramework}) /Echo Current Line ${Macro.CurLine}
					/if (${Twist}) /squelch /twist off
                    /stopsong
                    /delay 10
                }
                /endmac
            }
        }
        /if (${Debug}) /echo \atDEBUG EndMacroIf: Leave \agLine#: ${Macro.CurLine}
    /return
| ----------------------------------------------------------------------------
| SUB: Do I Camp
| ----------------------------------------------------------------------------
    Sub DoICamp
        /if (!${CampOnDeath}) /return
        /if (!${CampOnDeathTimer} && ${CampZone} != ${Zone.ID} && ${Me.Buff[Revival Sickness].ID}) {
            /echo I am dead and not where I am suppose to be. Time to camp out.
            /if (${IAmABard}) {
                /while (${Me.BardSongPlaying}) {
                    /if (${DebugFramework}) /Echo Current Line ${Macro.CurLine}
					/if (${Twist}) /squelch /twist off
                    /stopsong
                    /delay 10
                }
            }
            /docommand /camp desktop
            /delay 40s
            /endmac
        }
    /return
| ----------------------------------------------------------------------------
| SUB: Do Bard Stuff
| ----------------------------------------------------------------------------
    Sub DoBardStuff
        /if (${Me.Class.Name.NotEqual[Bard]}) /return
        /doevent TwistOff
        /if (!${Twist}) {
            /varset Twisting 0
            /varset DPSTwisting 0
            /if (${Me.BardSongPlaying} && ${Me.Casting.ID} && !${Window[CastingWindow].Open}) /stopsong
        }
        /if (!${BardStartTwist} && !${Me.Invis} && !${TwistHold}) {
            /while (${Me.BardSongPlaying}) {
                /if (${DebugFramework}) /Echo Current Line ${Macro.CurLine}
				/if (${Twist}) /squelch /twist off
                /stopsong
                /delay 10
            }
            /if (${TwistWhat.Length} && ${TwistWhat.Find[order]}==0) /squelch /twist ${TwistWhat}
            /varset BardStartTwist 1
            /return
        } else /if (${Me.Invis} || ${TwistHold}) {
            /if (${Twist} || (${Medding} && ${MedCombat} && ${AggroTargetID})) {
                /while (${Me.BardSongPlaying}) {
                    /if (${DebugFramework}) /Echo Current Line ${Macro.CurLine}
					/if (${Twist}) /squelch /twist off
                    /stopsong
                    /delay 10
                }
            }
            /return
        }
        /if (${Debug}) /echo \atDEBUG DoBardStuff: Enter \agLine#: ${Macro.CurLine}
        /if (${MeleeTwistOn} && ${CombatStart} && (!${DPSTwisting} || (${DPSTwisting} && !${Twist}))) {
            /if (!${DPSTwisting} && ${MeleeTwistWhat.NotEqual[Continuous]}) /echo == Starting melee twist
            /varset DPSTwisting 1
            /varset Twisting 0
            /if (${MeleeTwistWhat.Equal[Continuous]}) {
                /if (${Twist}) {
                    /echo == Continuing normal twist for melee
                    /return
                } else {
                    /squelch /twist ${TwistWhat}
                }
            } else {
                /squelch /twist ${MeleeTwistWhat}
            }
        } else /if (${TwistOn} && !${CombatStart} && !${Twisting}) {
            /varset DPSTwisting 0
            /varset Twisting 1
            /if (${MeleeTwistWhat.Equal[Continuous]} && ${Twist} && ${Twist.Current}!=${TwistMed}) {
                    /echo == Continuing normal twist
                    /return
            } else {
                /squelch /twist ${TwistWhat}
                /echo == Starting normal twist
            }
        } else /if (!${TwistOn} && !${CombatStart} && ${Twist}) {
            /while (${Me.BardSongPlaying}) {
                /if (${DebugFramework}) /Echo Current Line ${Macro.CurLine}
				/if (${Twist}) /squelch /twist off
                /stopsong
                /delay 10
            }
        }
        /if (${Debug}) /echo \atDEBUG DoBardStuff: Leave \agLine#: ${Macro.CurLine}
    /return
| ----------------------------------------------------------------------------
| SUB: GroupEscape
| ----------------------------------------------------------------------------
    Sub GroupEscape
        /if (!${GroupEscapeOn}) /return
        /if (${Debug}) /echo \atDEBUG GroupEscape Enter \agLine#: ${Macro.CurLine}
        |- If (in combat) or (Have AgroID) AND (MA is not present) or (a corpse).
        /if ((${Me.CombatState.Equal[COMBAT]} || ${AggroTargetID}) && (!${Spawn[=${MainAssist}].ID} || ${Spawn[=${MainAssist}].Type.Equal[Corpse]})) {
            /if (${Debug}) /echo \atDEBUG GroupEscape: CombatState:${Me.CombatState.Equal[COMBAT]} AggroTargetID:${AggroTargetID} MA Dead:!${Spawn[=${MainAssist}].ID}|${Spawn[=${MainAssist}].Type.Equal[Corpse]} \agLine#: ${Macro.CurLine}
            /echo + The MA is dead and I'm in combat, activating Group Escape!
            /if (${Select[${Me.Class.ShortName},WIZ,DRU]}) {
                |-- Druid AA or Spell group evac casting.
                /if (${Select[${Me.Class.ShortName},DRU]}) {
                    |- Drop Divine Barrier if it is up so we can exodus group!
                    /removebuff "Divine Barrier"
                    /if (${Me.AltAbilityReady[Exodus]}) {
                        /call CastWhat "Exodus" ${Me.ID} GroupEscape 1
                    } else /if (${Me.Book[Succor]}) {
                        /call CastWhat "Succor" ${Me.ID} GroupEscape 1
                    }
                }
                |-- Wizard AA or Spell group evac casting.
                /if (${Select[${Me.Class.ShortName},WIZ]}) {
                    /if (${Me.AltAbilityReady[Exodus]}) {
                        /call CastWhat "Exodus" ${Me.ID} GroupEscape 1
                    } else /if (${Me.Book[Evacuate]}) {
                        /call CastWhat "Evacuate" ${Me.ID} GroupEscape 1
                    }
                }                
            }            
        }
        /if (${Debug}) /echo \atDEBUG GroupEscape Leave \agLine#: ${Macro.CurLine}
    /return    


| -------------------------------------------------------------------------------------
| SUB: Rez Check
| -------------------------------------------------------------------------------------
    Sub RezWithCheck(string RWCWho)
        /declare RezWithS string local notready
        /declare xx int local 0
        /if (${DebugHeal}) /echo \amDEBUGHEALS RezWithCheck Enter \agLine#: ${Macro.CurLine}
        /for xx 1 to 3
            /call CastReady "${AutoRez[${xx}].Arg[1,|]}" rezwithcheck
            /if (${Bool[${Macro.Return}]}) {
                /if (${RWCWho.NotEqual[status]}) {
                    /if (!${ConOn} || !${AutoRez[${xx}].Find[|cond]} || ${If[${Cond[${AutoRez[${xx}].Mid[${Math.Calc[${AutoRez[${xx}].Find[|cond]}+5]},3]}]},1,0]}) {
                        /varset RezWithS ${AutoRez[${xx}].Arg[1,|]}
                        /break
                    }
                } else {
                    /varset RezWithS ${AutoRez[${xx}].Arg[1,|]}
                    /break
                }
            }
        /next xx
        /if (${DebugHeal}) /echo \amDEBUGHEALS RezWithCheck Leave ${RezWithS} \agLine#: ${Macro.CurLine}
    /return ${RezWithS}
| -------------------------------------------------------------------------------------
| SUB: Rez Check
| -------------------------------------------------------------------------------------
    Sub RezCheck(string RCWho)
        | Don't rez if AutoRezOn=0.  AutoRezOn=1 dmzone not instanced like pok, hovering, invis and no aggro, AutoRezOn=2 and aggro(rez after combat setting)
        /if (!${AutoRezOn}) /return
        /if (${DMZ} && ${Me.InInstance}==FALSE) /return
        /if (${Me.Hovering}) /return
        /if (${Me.Invis} && !${AggroTargetID}) /return
        /if (${AutoRezOn}==2 && ${AggroTargetID}) /return
        /if (${DebugHeal}) /echo \amDEBUGHEALS RezCheck Enter \agLine#: ${Macro.CurLine}
        /declare i int local
        /declare j int local
        /declare CorpseCount int local
        /declare RezMeID int local 
        /declare RezID int local
        /declare RezRadius int local 150
        /declare RezXTarget int local 0
        /declare RezCheck1 string local null
        /declare RezCheckID int local 0
        /declare RezCheckTries int local 0
        /declare RezWith string local notready
        /declare RezWait timer local 0
        /call RezWithCheck status 0
        /varset RezWith ${Macro.Return}
        /if (${RezWith.Equal[notready]}) {
            /if (${DebugHeal}) /echo \amDEBUGHEALS RezCheck RezWith Not Ready. \agLine#: ${Macro.CurLine}
            /return
        }
        | Does mainassist have a corpse
        /varset RezID ${Spawn[pccorpse ${MainAssist} radius ${RezRadius} zradius 50].ID}
        /if (${RezID}) {
            /call RezWithCheck MA
            /varset RezWith ${Macro.Return}
            /if (${RezWith.NotEqual[notready]}) {
                /if (!${Defined[OOCRezTimer${RezID}]}) /declare OOCRezTimer${RezID} timer outer 0
                /if (${OOCRezTimer${RezID}}==0) {
                    /target id ${RezID}
                    /delay 10 ${Target.ID}
                    /if (${Target.Distance}>${CampRadius}) /corpse
                    /delay 10
                    /call CastWhat "${RezWith}" ${Target.ID} RezCheck 1
                    /if (${Macro.Return.Equal[CAST_SUCCESS]}) {
                        /call BroadCast ${EQBCOn} o "REZZING MA =>> ${MainAssist} <<="
                        /varset OOCRezTimer${RezID} 3m
                    }
                }
            }
            /if (${RCWho.Equal[ma]}) /return
        }
        | Do I have a Corpse
        /varset RezMeID ${Spawn[pccorpse ${Me} radius ${RezRadius} zradius 50].ID}
        /if (${RezMeID}) {
            /call RezWithCheck ME
            /varset RezWith ${Macro.Return}
            /if (${RezWith.NotEqual[notready]}) {
            /varset CorpseCount ${SpawnCount[pccorpse ${Me} radius ${RezRadius} zradius 50]}
            /if (!${Defined[OOCRezTimer${RezMeID}]}) /declare OOCRezTimer${RezMeID} timer outer 0
                /if (${OOCRezTimer${RezMeID}}==0) {
                /target id ${RezMeID}
                /delay 10 ${Target.ID}
                /if (${Target.Distance}>${CampRadius}) /corpse
                /delay 10
                /call CastWhat "${RezWith}" ${Target.ID} RezCheck 1
                /if (${Macro.Return.Equal[CAST_SUCCESS]}) {
                    /call BroadCast ${EQBCOn} o "REZZING ME =>> ${Me} <<="
                    /varset OOCRezTimer${RezMeID} 3m
                    /varset RezWait 20
                    /while (${CorpseCount}==${SpawnCount[pccorpse ${Me} radius ${RezRadius} zradius 50]} && ${RezWait}) {
                        /if (${DebugFramework}) /Echo Current Line ${Macro.CurLine}
						/delay 5
                    }
                    /if (${SpawnCount[pccorpse ${Me} radius ${RezRadius} zradius 50]}==0 && ${MountOn} && !${Me.Mount.ID} && ${Me.CombatState.NotEqual[COMBAT]} && (${Zone.Outdoor} || ${Select[${Zone.Type},1,2,5]})) /call CastMount
                }
            }
        }
            /if (${RCWho.Equal[me]}) /return
        }
        | Does Group Member have a corpse?
        /for i 1 to 5
            /call RezWithCheck group
            /if (${DebugHeal}) /echo \amDEBUGHEALS RezCheck ${BattleRezTimer${i}}==0 && ${Spawn[${Group.Member[${i}].CleanName} pccorpse].Distance}<${RezRadius} ${Spawn[${Group.Member[${i}].CleanName} pccorpse].Deity.ID} ${RezWith} \agLine#: ${Macro.CurLine}
            /varset RezWith ${Macro.Return}
            /if (${RezWith.NotEqual[notready]}) {
                /if (${Group.Member[${i}].CleanName.Equal[${MainAssist}]}) /continue 
            /if (!${Spawn[${Group.Member[${i}].CleanName} pccorpse].ID} || (${RezWith.Find[Call of]} && ${Group.Member[${i}].OtherZone}==FALSE)) /continue
            | Check for group member corpses and battle rez
            /if (${BattleRezTimer${i}}==0 && ${Spawn[${Group.Member[${i}].CleanName} pccorpse].Distance}<${RezRadius}) {
                /squelch /tar id ${Spawn[${Group.Member[${i}].CleanName} pccorpse].ID}
                /delay 10 ${Target.ID}
                /if (${Target.Distance}<100) {
                    /if (${Target.Distance}>${CampRadius} && !${Target.CleanName.Find[${MainAssist}]}) /corpse
                    /delay 10
                    /call CastWhat "${RezWith}" ${Target.ID} RezCheck 1
                    /if (${Macro.Return.Equal[CAST_SUCCESS]}) {
                        /call BroadCast ${EQBCOn} o "BATTLE REZZED =>> ${Group.Member[${i}]} <<="
                        /varset BattleRezTimer${i} 3m
                        /squelch /target clear
                        /if (${RezWith.Find[Call of]}) /varset BattleRezTimer${i} 6m
                    } else {
                        /if (${Group.Member[${i}].Name.NotEqual[${MainAssist}]}) /varset BattleRezTimer${i} 1m
                    }
                }
            }
            }
        /next i
        | Out of Combat Rez | 
        | Rez Guild, Fellowship and XTarget members.
        /varset CorpseCount ${SpawnCount[pccorpse radius ${RezRadius} zradius 50]}
        /if (${CorpseCount}>0 && !${CombatStart}) {
            /for j 1 to ${CorpseCount}
                /call RezWithCheck XTARGET
                /varset RezWith ${Macro.Return}
                /if (${RezWith.Equal[notready]}) /return
                /varset RezID ${NearestSpawn[${j},pccorpse radius ${RezRadius} zradius 50].ID}
                /if (${XTarHeal}) {
                    /for i 1 to ${XSlotTotal}
                        /if (${XTarToHeal[${i}]}==0) /continue
                        /if (${Me.XTarget[${XTarToHeal[${i}]}].ID} && ${Me.XTarget[${XTarToHeal[${i}]}].Type.Equal[corpse]} && ${Me.XTarget[${XTarToHeal[${i}]}].ID}==${RezID}) {
                            /if (${DebugHeal}) /echo \amDEBUGHEALS CRezheck:  -- XTarget Corpse Found: ${i} ${Me.XTarget[${XTarToHeal[${i}]}].Name} \agLine#: ${Macro.CurLine}
                            /varset RezXTarget ${Me.XTarget[${XTarToHeal[${i}]}].ID}
                        }
                        /if (${RezXTarget}) /break
                    /next i
                }
                /if (${Spawn[${RezID}].Type.Equal[corpse]}) {
                    /if (!${Defined[OOCRezTimer${RezID}]}) /declare OOCRezTimer${RezID} timer outer 0
                    /if (${DebugHeal}) /echo \amDEBUGHEALS RezCheck ${OOCRezTimer${RezID}} ${Spawn[${RezID}].Guild.Equal[${Me.Guild}]} ${Spawn[${Me.Fellowship.Member[${Spawn[${RezID}].CleanName.Left[-9]}]} pccorpse].ID} ${RezXTarget}  \agLine#: ${Macro.CurLine}
                    /if (${OOCRezTimer${RezID}}==0 && (${Spawn[${RezID}].Guild.Equal[${Me.Guild}]} || ${Spawn[${Me.Fellowship.Member[${Spawn[${RezID}].CleanName.Left[-9]}]} pccorpse].ID} || ${RezXTarget}==${RezID})) {
                        | If call of wild and toon in zone skip
                        /if (${RezWith.Find[Call of]} && ${Spawn[pc ${Spawn[${RezID}].CleanName.Left[-9]}].ID}) /continue
                        /target id ${RezID}
                        /delay 10 ${Target.ID}==${RezID}
                        /if (${Target.Distance}<=${RezRadius}) {
                            /call CastWhat "${RezWith}" ${Target.ID} RezCheck 1
                            /if (${Macro.Return.Equal[CAST_SUCCESS]}) {
                                /call BroadCast ${EQBCOn} o "Rezzing =>> ${Target.CleanName} <<="
                                /varset OOCRezTimer${RezID} 5m
                                /squelch /target clear
                            }
                        }
                    }
                }
            /next j
        }
        /if (${AutoRezAll}) {
            /varset CorpseCount ${SpawnCount[pccorpse radius ${RezRadius} zradius 50]}
            /if (${CorpseCount}>0 && !${CombatStart}) {
                /for j 1 to ${CorpseCount}
                    /call RezWithCheck rezall
                    /varset RezWith ${Macro.Return}
                    /if (${RezWith.Equal[notready]}) /return
                    /varset RezID ${NearestSpawn[${j},pccorpse radius ${RezRadius} zradius 50].ID}
                    /if (${Spawn[${RezID}].Type.Equal[corpse]}) {
                        /if (!${Defined[OOCRezTimer${RezID}]}) /declare OOCRezTimer${RezID} timer outer 0
                        /if (${OOCRezTimer${RezID}}==0) {
                            /if (${CorpseRezCheck.Find[${RezID}:]}) {
                                /varset i 1
                                /while (${CorpseRezCheck.Arg[${i},|].NotEqual[null]}) {
                                    /if (${DebugFramework}) /Echo Current Line ${Macro.CurLine}
									/if (${CorpseRezCheck.Arg[${i},|].Find[${RezID}:]}) {
                                        /varset RezCheck1 ${CorpseRezCheck.Arg[${i},|]}
                                        /varset RezCheckID ${RezCheck1.Arg[1,:]}
                                        /varset RezCheckTries ${RezCheck1.Arg[2,:]}
                                    }
                                    /varcalc i ${i}+1
                                }
                            } else {
                                /varset RezCheck1 null
                                /varset RezCheckID ${RezID}
                                /varset RezCheckTries 0
                            }
                            /if (${RezCheckTries}<3) {
                                /target id ${RezID}
                                /delay 10 ${Target.ID}==${RezID}
                                /if (${Target.Distance}<=${RezRadius}) {
                                    /call CastWhat "${RezWith}" ${Target.ID} RezCheck 1
                                    /if (${Macro.Return.Equal[CAST_SUCCESS]}) {
                                        /varcalc RezCheckTries ${RezCheckTries}+1
                                        /call BroadCast ${EQBCOn} o "Rezzing =>> ${Target.CleanName} for the ${RezCheckTries} Time<<="
                                        /varset OOCRezTimer${RezID} 3m
                                        /if (${RezCheck1.NotEqual[null]}) {
                                            /varset CorpseRezCheck ${CorpseRezCheck.Replace[${RezCheck1}|,${RezCheckID}:${RezCheckTries}|]}
                                        } else {
                                            /varset CorpseRezCheck ${RezCheckID}:${RezCheckTries}|${CorpseRezCheck}
                                        }
                                        /squelch /target clear
                                    }
                                }
                            }
                        }
                    }
                /next j
            } else /if (!${CombatStart}) {
                /varset i 1
                /while (${CorpseRezCheck.Arg[${i},|].NotEqual[null]}) {
					/if (${DebugFramework}) /Echo Current Line ${Macro.CurLine}
                    /varset RezCheck1 ${CorpseRezCheck.Arg[${i},|]}
                    /varset RezCheckID ${RezCheck1.Arg[1,:]}
                    /varset RezCheckTries ${RezCheck1.Arg[2,:]}
                    /if (${Spawn[id ${RezCheckID}].ID}==0 || (${Spawn[id ${RezCheckID}].ID} && ${Spawn[id ${RezCheckID}].Type.NotEqual[corpse]})) {
                        /varset CorpseRezCheck ${CorpseRezCheck.Replace[${RezCheck1}|,]}
                        /if (${Defined[OOCRezTimer${RezCheckID}]}) /deletevar OOCRezTimer${RezCheckID}
                    } else {
                        /varcalc i ${i}+1
                    }
                }
            }
        }
        /if (${DebugHeal}) /echo \amDEBUGHEALS RezCheck Leave \agLine#: ${Macro.CurLine}
    /return
| -------------------------------------------------------------------------------------
| SUB: MassGroupBuff
| -------------------------------------------------------------------------------------
    Sub MassGroupBuff(SpellToCast1,int i1, int Cond#)
        /if (!${SpellToCast1.Length} || ${i1}==0) /return 0
        /if (!${Spell[${SpellToCast1}].TargetType.Find[Group v]} || ${Spell[${SpellToCast1}].TargetType.Equal[Group v1]}) {
            /varset Buffs[${i1}] null
            /echo Spell ${SpellToCast1} cannot be MGB'd. Setting to null.
            /return 0
        } else /if (${Me.AltAbility[Tranquil Blessings]}==0) {
            /varset Buffs[${i1}] null
            /echo You don't have Tranquil Blessings AA. Setting ${SpellToCast1} to null.
            /return 0
        }
        /if (${Select[${Me.CombatState},active,resting]}==0) {
            /echo Your Not Resting. Will Have to Wait to cast MGB.
        } else /if (${Me.AltAbilityReady[Tranquil Blessings]} && ${Me.CurrentMana}>=${Math.Calc[${Spell[${SpellToCast1}].Mana}*2]}) {
            /if (!${Cond#} || ${If[${Cond[${Cond#}]},1,0]}) {
                /call CastWhat "Tranquil Blessings" ${Me.ID} Buffs-nomem 0 0
            /if (${Macro.Return.Equal[CAST_SUCCESS]}) {
                /echo Casting Tranquil Blessings for MGB of ${SpellToCast1}
                    /call CastWhat "${SpellToCast1}" ${Me.ID} Buffs-nomem 0 0
                /if (${Macro.Return.Equal[CAST_SUCCESS]}) {
                    /echo MGB of ${SpellToCast1} Successful.
                }
            }
        }
        }
    /return
| -------------------------------------------------------------------------------------
| SUB: Loot Stuff
| -------------------------------------------------------------------------------------
    Sub LootStuff
        /if (!${LootOn} || (!${Me.UseAdvancedLooting} && ${AggroTargetID}) || (${MainAssist.Equal[${Me}]} && ${AggroTargetID}) || (${DMZ} && ${Me.InInstance}==FALSE) || ${Me.Invis}) /return
        /if (${Debug}) /echo \atDEBUG LootStuff: Enter \agLine#: ${Macro.CurLine}
        /if (${Me.FreeInventory}==0) {
            /echo Inventory is full. Looting OFF
            /varset LootOn 0
            /return
        }
        /doevents
        /if (${Me.UseAdvancedLooting}) {
            /if (${Bool[${Plugin[MQ2AutoLoot]}]}) {
                /if (${AutoLoot.Active}) /return
            }
            /call UseAdvLoot
        } else {
            /call LootMobs
        }
        /call DoWeMove 0 lootstuff
        /if (${Debug}) /echo \atDEBUG LootStuff: Leave \agLine#: ${Macro.CurLine}
    /return
| -------------------------------------------------------------------------------------
|   Sub MobRadar
| -------------------------------------------------------------------------------------
    Sub MobRadar(int CountRadius,string calledfrom)
        /if ((${DMZ} && ${Me.InInstance}==FALSE)) /return
        /if (${Debug}) /echo \atDEBUG MobRadar ${CountRadius} Enter (${calledfrom}) \agLine#: ${Macro.CurLine}
        /declare NMob int local
        /declare i int local
        /varset MobCount ${SpawnCount[npc targetable los radius ${CountRadius} zradius 50 noalert 3]}
        /if (${MobCount}>0) {
            /for i 1 to ${MobCount}
                /varset NMob ${NearestSpawn[${i},npc targetable los radius ${CountRadius} zradius 50 noalert 3].ID}
                /if (${i}>13) /break
                /if (${NMob} && (${Spawn[${NMob}].Type.Equal[Corpse]} || !${Spawn[${NMob}].ID})) /call RemoveFromArray AddsArray ${Select[${NMob},${AddsArray[1,1]},${AddsArray[2,1]},${AddsArray[3,1]},${AddsArray[4,1]},${AddsArray[5,1]},${AddsArray[6,1]},${AddsArray[7,1]},${AddsArray[8,1]},${AddsArray[9,1]},${AddsArray[10,1]},${AddsArray[11,1]},${AddsArray[12,1]},${AddsArray[13,1]}]}
                /if (${Select[${NMob},${AddsArray[1,1]},${AddsArray[2,1]},${AddsArray[3,1]},${AddsArray[4,1]},${AddsArray[5,1]},${AddsArray[6,1]},${AddsArray[7,1]},${AddsArray[8,1]},${AddsArray[9,1]},${AddsArray[10,1]},${AddsArray[11,1]},${AddsArray[12,1]},${AddsArray[13,1]}]}==0) /call AddToArray AddsArray ${NMob}
           /next i
        }
        | Check if NPC Pet is on Xtarget
        /if (!${MobCount} && ${Me.XTarget[${XTSlot}].ID}) {
            /if (${Debug}) /echo \atDEBUG MobRadar MobCount=0 but Mob on Xtarget Setting Mobcount to 1 \agLine#: ${Macro.CurLine}
            /varset MobCount 1  
        }    
        /if (${Debug}) /echo \atDEBUG MobRadar Leave ${MobCount} \agLine#: ${Macro.CurLine}
    /return
| -------------------------------------------------------------------------------------
|   Sub MezRadar
| -------------------------------------------------------------------------------------
    Sub MezRadar
        /if ((${DMZ} && ${Me.InInstance}==FALSE)) /return
        /if (${DebugMez}) /echo \atDEBUG MezRadar Enter \agLine#: ${Macro.CurLine}
        /declare NMMob int local 0
        /declare i int local
        /varset MezMobCount 0
        /varset MezMobAECount 0
        /varset MezAEClosest 0
        /for i 1 to 13
            /if (${DebugMez}) /echo \atDEBUG MezRadar:  ${i} ${Me.XTarget[${i}].ID} && ${Me.XTarget[${i}].TargetType.Equal[Auto Hater]} && ${Me.XTarget[${i}].Type.Equal[NPC]} \agLine#: ${Macro.CurLine}
            /if (${Me.XTarget[${i}].ID} && ${Me.XTarget[${i}].TargetType.Equal[Auto Hater]} && ${Me.XTarget[${i}].Type.Equal[NPC]}) {
                /varset NMMob ${Me.XTarget[${i}].ID}
                /varcalc MezMobCount ${MezMobCount}+1 
                | Setup closest mob for AE mez target necros can't aemez
                /if (${Select[${Me.Class.ShortName},BRD,ENC]}) {
                    /if (!${MezAEClosest} && ${Spawn[${NMMob}].Distance}<=${MezRadius}) /varset MezAEClosest ${NMMob}
                    /if (${MezAEClosest} && ${Spawn[${NMMob}].Distance}<${Spawn[${MezAEClosest}].Distance} && ${Spawn[${NMMob}].Distance}<=${MezRadius}) /varset MezAEClosest ${NMMob}
                    /if (${Spawn[${NMMob}].Distance}<=${MezRadius}) /varcalc MezMobAECount ${MezMobAECount}+1 
                }
                /if (${DebugMez}) /echo \atDEBUG MezRadar: MezMobCount ${MezMobCount} ${NMMob} \agLine#: ${Macro.CurLine}
                /if (${NMMob} && (${Spawn[${NMMob}].Type.Equal[Corpse]} || !${Spawn[${NMMob}].ID} || ${Spawn[${NMMob}].Distance}>${MezRadius})) /call RemoveFromArray MezArray ${Select[${NMMob},${MezArray[1,1]},${MezArray[2,1]},${MezArray[3,1]},${MezArray[4,1]},${MezArray[5,1]},${MezArray[6,1]},${MezArray[7,1]},${MezArray[8,1]},${MezArray[9,1]},${MezArray[10,1]},${MezArray[11,1]},${MezArray[12,1]},${MezArray[13,1]}]}
                /if (${MezMobCount}>0 && ${Select[${NMMob},${MezArray[1,1]},${MezArray[2,1]},${MezArray[3,1]},${MezArray[4,1]},${MezArray[5,1]},${MezArray[6,1]},${MezArray[7,1]},${MezArray[8,1]},${MezArray[9,1]},${MezArray[10,1]},${MezArray[11,1]},${MezArray[12,1]},${MezArray[13,1]}]}==0) {
                    /if (${DebugMez}) /echo \atDEBUG MezRadar: ADDING -> Name: ${Spawn[${NMMob}].Name} ID: ${NMMob} to mezlist \agLine#: ${Macro.CurLine}
                    /call AddToArray MezArray ${NMMob} 
                }
                /varset NMMob 0
            }
        /next i
        /if (${DebugMez}) /delay 5
       /if (${DebugMez}) /echo \atDEBUG MezRadar: MezMobCount: ${MezMobCount} Leave \agLine#: ${Macro.CurLine}
    /return
| -------------------------------------------------------------------------------------
| SUB: Add to Array
| -------------------------------------------------------------------------------------
    Sub AddToArray(ArrayName, int AddMobID)
    /if (!${AddMobID}) /return
        /if (${Debug}) /echo \atDEBUG AddToArray ${AddMobID} Enter \agLine#: ${Macro.CurLine}
        /declare i int local
        /for i 1 to 13
            /if (${${ArrayName}[${i},1].Equal[NULL]}) {
                /varset ${ArrayName}[${i},1] ${Spawn[${AddMobID}].ID}
                /varset ${ArrayName}[${i},2] ${Spawn[${AddMobID}].Level}
                /varset ${ArrayName}[${i},3] ${Spawn[${AddMobID}].CleanName}
                /if (${Debug}) /echo ARRAY Assign >> ${${ArrayName}[${i},3]} << to ${ArrayName}${i}. \agLine#: ${Macro.CurLine}
                /return
            }
        /next i
        /if (${Debug}) /echo \atDEBUG AddToArray Leave \agLine#: ${Macro.CurLine}
    /return
| -------------------------------------------------------------------------------------
| SUB: Remove From Array
| -------------------------------------------------------------------------------------
    Sub RemoveFromArray(RArrayName, int ArNum)
        /if (${${RArrayName}[${ArNum},1].Equal[NULL]}) /return
        /if (${ArNum}<1 || ${ArNum}>${${RArrayName}.Size}) /return
        /if (${Debug}) /echo \atDEBUG RemoveFromArray ${ArNum} Enter \agLine#: ${Macro.CurLine}
        /if (${Debug}) /echo \atDEBUG ARRAY Remove >> ${${RArrayName}[${ArNum},3]} << from ${RArrayName}${ArNum}. \agLine#: ${Macro.CurLine}
        /varset ${RArrayName}[${ArNum},1] NULL
        /varset ${RArrayName}[${ArNum},2] NULL
        /varset ${RArrayName}[${ArNum},3] NULL
        /if (${MezOn} && ${ArNum}<=13) {
            /varset MezCount[${ArNum}] 0
            /varset MezTimer${ArNum} 0
        }
        /if (${Debug}) /echo \atDEBUG RemoveFromArray Leave \agLine#: ${Macro.CurLine}
    /return
| -------------------------------------------------------------------------------------
| SUB: Do Mez Stuff
| -------------------------------------------------------------------------------------
    Sub DoMezStuff(string SentFrom)
            /if (${EventByPass}!=2) {
                /varset EventByPass 1
                /varset GoMByPass 1
                /doevents
                /varset EventByPass 0
                /varset GoMByPass 0
            }
            /varset GoMByPass 0

        /if (!${MezOn} || ${Me.Hovering} ||(!${MyTargetID} && ${Spawn[=${MainAssist}].ID} && ${Spawn[=${MainAssist}].Type.NotEqual[Mercenary]}) || ${DMZ} && ${Me.InInstance}==FALSE) /return
        /if (${DebugMez}) /echo \atDEBUGMEZ DoMezStuff: Enter ${SentFrom} \agLine#: ${Macro.CurLine}
        /declare i int local 0
        /declare j int local 0
        /declare skipFlag int local 0
        | Reset skip mez on health setting if tank dies to 1%
        /if (!${Spawn[=${MainAssist}].ID}) /varset MezStopHPs 1
        /call MezRadar
        /if (${DebugMez}) /echo DoMezStuff MezMobCount ${MezMobCount} \agLine#: ${Macro.CurLine}
        /if (${MezMobCount}<2 && ${Spawn[=${MainAssist}].ID}) {
            /if (${DebugMez}) /echo MezMobCount was ${MezMobCount} (so less than 2) & ${MainAssist} is alive so we return \agLine#: ${Macro.CurLine}
            /return
        }
        | Necros can't AE mez. But you don't need to check it twice.
        /if (${Select[${MezOn},1,3]} && ${MezAECount}>0 && ${MezMobAECount}>=${MezAECount} && ${MezAETimer}==0 && ${Select[${Me.Class.ShortName},BRD,ENC]})  {
            /if (${DebugMez}) /echo I'm about to AEMez \agLine#: ${Macro.CurLine}
            /if (${SpawnCount[npc xtarhater loc ${Spawn[id ${MezAEClosest}].X} ${Spawn[id ${MezAEClosest}].Y} radius ${Spell[${MezAESpell}].AERange}]}>=${SpawnCount[npc loc ${Spawn[id ${MezAEClosest}].X} ${Spawn[id ${MezAEClosest}].Y} radius ${Spell[${MezAESpell}].AERange}]})  /call MezMobsAE ${MezAEClosest}
        }
        /for i 1 to 13
            /varset skipFlag 0
            | Every Mez test conditon is listed seperately for clarity
            /if (${DebugMez}) /echo we are in the mezcondition loop i is: ${i} \agLine#: ${Macro.CurLine}
            | Test -> Is my single mez spell ready
            /if (!${Me.SpellReady[${MezSpell}]} && !${IAmABard}) {
                /if (${MezOn}!=2) {
                    /if (${DebugMez}) /echo ${MezSpell} not ready, goto return \agLine#: ${Macro.CurLine}
                    /return
                }
                /while (!${Me.SpellReady[${MezSpell}]}) {
					/if (${DebugFramework}) /Echo Current Line ${Macro.CurLine}
                    /delay 2
                }
            }
            | Test -> array not empty,
            /if (${MezArray[${i},1].Equal[NULL]}) {
                /if (${DebugMez}) /echo ${i}  MezArray[${i},1] was equal to NULL, Skip \agLine#: ${Macro.CurLine}
                /continue
            }
            | Test -> Target is dead
            /if (${MezArray[${i},3].Find[corpse]} ||  !${Spawn[${MezArray[${i},1]}].ID} || ${Spawn[${MezArray[${i},1]}].Type.Equal[corpse]}) {
                /if (${DebugMez}) /echo ${i}  ${MezArray[${i},3]} is dead, Skip \agLine#: ${Macro.CurLine}
                /varset MezArray[${i},1] NULL
                /continue
            }
            | Is mob in MezRadius distance
            /if (${Spawn[${MezArray[${i},1]}].Distance}>=${MezRadius}) {
                /if (${DebugMez}) /echo ${i}  Mob distance is greater than MezRadius: ${Spawn[${MezArray[${i},1]}].Distance} ${MezRadius} Skip \agLine#: ${Macro.CurLine}
                /varset MezArray[${i},1] NULL
                /continue
            }
            | Test -> is target MA's current Target
            /if (${Spawn[${MezArray[${i},1]}].ID}==${MyTargetID} && ${Spawn[=${MainAssist}].ID}) {
                /if (${DebugMez}) /echo ${Spawn[${MezArray[${i},1]}].Name} had the same ID(${Spawn[${MezArray[${i},1]}].ID}) as MyTargetID(${MyTargetID}) & ${MainAssist}(${Spawn[=${MainAssist}].ID}), Skip \agLine#: ${Macro.CurLine}
                /varset MezArray[${i},1] NULL
                /continue
            }
            | Test -> is  MA's a merc skip 1st target so he attackes it.
            /if (${AggroTargetID} && !${MyTargetID} && ${Spawn[=${MainAssist}].ID} && ${Spawn[=${MainAssist}].Type.Equal[Mercenary]}) {
                /if (${DebugMez}) /echo AggroTargetID = ${AggroTargetID}  MyTargetID = ${MyTargetID} & Spawn[=MainAssist].ID = ${Spawn[=${MainAssist}].ID} & Spawn[=MainAssist].Type.Equal[Mercenary] was true, Skip \agLine#: ${Macro.CurLine}
                /varset MezArray[${i},1] NULL
                /continue
            }
             | Test -> is taget above mez hps threshold
            /if (${Spawn[${MezArray[${i},1]}].PctHPs}<${MezStopHPs}) {
                /if (${DebugMez}) /echo Spawn[MezArray[${i},1]].PctHPs(${Spawn[${MezArray[${i},1]}].PctHPs}) was less than MezStopHPs(${MezStopHPs}), Skip \agLine#: ${Macro.CurLine}
                /varset MezArray[${i},1] NULL
                /continue
            }
             | Test -> is target within levels defined in ini file
            /if (${MezArray[${i},2]}>${MezMaxLevel} || ${MezArray[${i},2]}<${MezMinLevel}) {
                /if (${DebugMez}) /echo MezArray[${i},2](${MezArray[${i},2]}) was greater than MezMaxLevel(${MezMaxLevel}) OR less than MezMinLevel(${MezMinLevel}), Skip \agLine#: ${Macro.CurLine}
                /varset MezArray[${i},1] NULL
                /continue
            }
             | Test -> is the target in line of sight
            /if (!${Spawn[${MezArray[${i},1]}].LineOfSight}) {
                /if (${DebugMez}) /echo I dont have LineOfSight to Spawn[MezArray[${i},1]](${Spawn[${MezArray[${i},1]}].Name} ID:${Spawn[${MezArray[${i},1]}].ID}), Skip \agLine#: ${Macro.CurLine}
                /continue
            }
             | Test -> I am a bard and if the player is dumb enough to have me tank then don't mez.
            /if (${IAmABard} && ${MainAssist.Equal[${Me}]} && ${MyTargetID} && ${AggroTargetID} && ${MezArray[${i},1].Equal[${MyTargetID}]}) {
                /if (${DebugMez}) /echo im a bard and stuff, Skip \agLine#: ${Macro.CurLine}
                /continue
            }
             | Test -> is target a giant unmezzable
            /if (${Spawn[${MezArray[${i},1]}].Body.Name.Equal[Giant]}) {
                /if (${DebugMez}) /echo Spawn[MezArray[${i},1]] (${Spawn[${MezArray[${i},1]}].Name} ID:${MezArray[${i},1]}) is a giant, Skip \agLine#: ${Macro.CurLine}
                /continue
            }
             | Test -> is target on my mez immune list
            /if (${Alert[4].Size}) {
                /for j 0 to ${Alert[4].Size}
                    /if (${Alert[4].List[${j}].Name.Equal[${MezArray[${i},3]}]} && ${Alert[4].List[${j}].Name.Length}) {
                        /if (${MMTimer${i}}==0) /call BroadCast ${EQBCOn} g "MEZ Immune Detected -> ${MezArray[${i},3]} <- ID:${MezArray[${i},1]}"
                        /varset MMTimer${i} 1m
                        /if (${DebugMez}) /echo ${Spawn[${MezArray[${i},1]}].Name} ID:${MezArray[${i},1]} is immune, Skip \agLine#: ${Macro.CurLine}
                        /varset skipFlag 1
                        /break
                    }
                /next j
                /if (${skipFlag}) {
                    /varset MezArray[${i},1] NULL
                    /continue
                }
            }
            | Test -> Do i have enough mana to cast the spell 
            /if (${Me.CurrentMana}<${Spell[${MezSpell}].Mana}) {
                /if (${DebugMez}) /echo i didnt have enough mana to cast ${MezSpell}, Skip \agLine#: ${Macro.CurLine}
                /continue
            }
            | Test -> Do i have a mez timer on the mob?
            /if (${MezTimer${i}} > 0) {
                /if (${DebugMez}) /echo MezTimer${i}(${MezTimer${i}}) was greater than 0 , Skip \agLine#: ${Macro.CurLine}
                /continue
            }
            | Stop mezzing last mob because pets and mercs won't attack it.
            /if (${MezMobCount}<=1 && ${Spawn[=${MainAssist}].ID} && (${Spawn[=${MainAssist}].Type.Equal[Mercenary]} || ${Spawn[=${MainAssist}].Type.Equal[Pet]})) {
                /if (${DebugMez}) /echo MezMobCount(${MezMobCount}) was less or equal to 1 & ( MainAssist(${MainAssist}) was a Mercenary OR a Pet ), Skip \agLine#: ${Macro.CurLine}
                /continue
            }
            /if (${Spawn[${MainAssist} ${MainAssistType} group].ID} && ${Select[${MezArray[${i},1]},${Me.XTarget[1].ID},${Me.XTarget[2].ID},${Me.XTarget[3].ID},${Me.XTarget[4].ID},${Me.XTarget[5].ID},${Me.XTarget[6].ID},${Me.XTarget[7].ID},${Me.XTarget[8].ID},${Me.XTarget[9].ID},${Me.XTarget[10].ID},${Me.XTarget[11].ID},${Me.XTarget[12].ID},${Me.XTarget[13].ID}]}==0) {
                /if (${DebugMez}) /echo If tank is alive and mob not on xtarget Skip \agLine#: ${Macro.CurLine}
                /continue
            }
            /if (${MezImmuneIDs.Find[|${MezArray[${i},1]}]}) {
                /if (${DebugMez}) /echo Mez Immune Mob Detected: ${MezArray[${i},3]} Skip \agLine#: ${Macro.CurLine}
                /varset MezArray[${i},1] NULL
                /continue
            }
            /if (${DebugMez}) /echo \atDEBUGMEZ MezTimer${i} ${MezTimer${i}} ${Spawn[${MezArray[${i},1]}].ID} ${i} \agLine#: ${Macro.CurLine}
            /if (${Select[${MezOn},1,2]}) {
                /if (${DebugMez}) /echo im gonna singlemez ${MezArray[${i},1]} \agLine#: ${Macro.CurLine}
                /call MezMobs ${MezArray[${i},1]} ${i}
            }
        /next i
        |/if (${MeleeTwistOn} && ${CombatStart} && ${IAmABard} && (!${Target.ID}) || (${Target.ID}!=${MyTargetID})) /call CombatTargetCheck
        |/if (${Spawn[${SpawnSearchType} id ${MyTargetID}].Distance}<${MeleeDistance} && ${MeleeTwistOn} && ${CombatStart} && ${IAmABard} && (!${Target.ID}) || (${Target.ID}!=${MyTargetID})) /call FindTarget
		/if (${DebugMez}) /echo \atDEBUGMEZ DoMezStuff: Leave \agLine#: ${Macro.CurLine}
    /return
| -------------------------------------------------------------------------------------
| SUB: Mez Mobs AE
| -------------------------------------------------------------------------------------
    Sub MezMobsAE(int AEMezID)
        | Bard AE mez code
        /declare i int local 1
        /declare WasChasing int local 0
        /if (${IAmABard}) {
            /squelch /twist once ${Me.Gem[${MezAESpell}]}
            /call BroadCast ${EQBCOn} g "MEZZING-> AE Mezzing Now - ${MezAESpell} "
            /delay 35
            /varset MezAETimer 300
        }
        | Enchanter AE mez code
        /if (${Me.Class.Name.Equal[Enchanter]}) {
            /if (${ChaseAssist}) {
                /varset ChaseAssist 0
                /varset WasChasing 1
                /squelch /stick off
                /moveto off
                /if (${PullMoveUse.Equal[nav]}) {
                    /if (${Navigation.Active}) /nav stop
                }
                /delay 30 !${Me.Moving}
            }
            /echo I AM AE MEZZING ${MezAESpell}
            /call CastWhat "${MezAESpell}" ${AEMezID} Mez 0
            /echo I JUST CAST AE MEZ ${MezAESpell}
            /delay 10 ${Me.SpellReady[${MezAESpell}]}
            /varset MezAETimer ${Spell[${MezAESpell}].Duration.TotalSeconds}s
            /if (${DebugMez}) /echo \atDEBUGMEZ TIMER SET ${MezAETimer} \agLine#: ${Macro.CurLine}
            /call BroadCast ${EQBCOn} g "AE MEZZING-> ${MezAESpell} "
            /if (${WasChasing}) /varset ChaseAssist 1
        }
        | Reset all mez timers to 0 after AE Mez
        /for i 1 to 30
            /varset MezTimer${i} 0
        /next i
    /return
| -------------------------------------------------------------------------------------
| SUB: Mez Mobs
| -------------------------------------------------------------------------------------
    Sub MezMobs(int MobID, int TimerNum)
        /if (${DebugMez}) /echo \atDEBUGMEZ MezMobs Enter MobID:${MobID} Timer#:${TimerNum} \agLine#: ${Macro.CurLine}
        /declare MezFail int local 0
        /declare MezTry int local 1
        /declare ReMez int local 0
        /if (${Me.Combat}) {
                /attack off
                /delay 25 !${Me.Combat}
        }
        /squelch /target id ${MobID}
        /delay 20 ${Target.ID}==${MobID} && ${Target.BuffsPopulated}==TRUE
        /if (${Target.ID}==${MobID}) {
            /if (${Int[${Target.Mezzed.ID}]} && ${Target.Mezzed.Name.Equal[${MezSpell}]} && !${IAmABard}) {
                /if (${DebugMez}) /echo DEBUGMEZ MezTimer${TimerNum} ${MezTimer${TimerNum}} Target Info: ${Target.Mezzed.ID} ${Target.Mezzed.Name} ${Target.BuffDuration[${Target.Mezzed.Name}].TotalSeconds} Line#: ${Macro.CurLine}
                    /if (${Target.BuffDuration[${Target.Mezzed.Name}].TotalSeconds}>${Math.Calc[(${Spell[${MezSpell}].Duration.TotalSeconds}+${MezMod})*.10]}) {
                        /varcalc MezCount[${TimerNum}] 1
                        /varcalc MezTimer${TimerNum} (${Target.BuffDuration[${Target.Mezzed.Name}].TotalSeconds}*10)*.85
                        /return
                    }            
                }
            /if (${MezCount[${TimerNum}]}<1) {
                /call BroadCast ${EQBCOn} g "MEZZING-> ${Spawn[${MobID}].CleanName} <- ID:${MobID}"
            } else {
                /call BroadCast ${EQBCOn} g "ReMEZZING-> ${Spawn[${MobID}].CleanName} <- ID:${MobID}"
                /varset ReMez 1
            }
            | Chanter mez code
            /if (${Me.Class.Name.Equal[Enchanter]}) {
                /while (1) {
					/if (${DebugFramework}) /Echo Current Line ${Macro.CurLine}
                    /call CastWhat "${MezSpell}" ${MobID} Mez 0
                    /varcalc MezFail ${MezFail}+1
                    /if (${Macro.Return.Equal[CAST_SUCCESS]}) {
                        /if (!${ReMez})  /call BroadCast ${EQBCOn} g "JUST MEZZED -> ${MezSpell} on ${Spawn[${MobID}].CleanName}:${MobID}"
                        /if (${ReMez})  /call BroadCast ${EQBCOn} g "JUST REMEZZED -> ${MezSpell} on ${Spawn[${MobID}].CleanName}:${MobID}"
                        /varcalc MezCount[${TimerNum}] ${MezCount[${TimerNum}]}+1
                        /varcalc MezTimer${TimerNum} ((${Spell[${MezSpell}].Duration.TotalSeconds}+${MezMod})*10)*.90
                        /if (${DebugMez}) /echo DEBUGMEZ MezTimer${TimerNum} ${MezTimer${TimerNum}} \agLine#: ${Macro.CurLine}
                    } else /if (${Macro.Return.Equal[CAST_RESIST]} && ${MezFail}<2) {
                        /call BroadCast ${EQBCOn} g "MEZ Resisted -> ${Spawn[${MobID}].CleanName} <- ID:${MobID}"
                        /continue
                    } else /if (${Macro.Return.Equal[CAST_IMMUNE]}) {
                        /if (!${MezImmuneIDs.Find[|${Target.ID}]}) /call AddMezImmune ${Target.ID}
                    }
                    /break
                }
            | Bard mez code
            } else /if (${IAmABard}) {
                /squelch /twist once ${Me.Gem[${MezSpell}]}
                /delay 35
                    /squelch /target clear
                    /varcalc MezCount[${TimerNum}] ${MezCount[${TimerNum}]}+1
                    /varset MezTimer${TimerNum} 110
            | Necro mez code
            } else /if (${Me.Class.Name.Equal[Necromancer]}) {
                /while (1) {
					/if (${DebugFramework}) /Echo Current Line ${Macro.CurLine}
                    /call CastWhat "${MezSpell}" ${MobID} Mez 0
                    /varcalc MezFail ${MezFail}+1
                    /if (${Macro.Return.Equal[CAST_SUCCESS]}) {
                        /varcalc MezCount[${TimerNum}] ${MezCount[${TimerNum}]}+1
                        /varcalc MezTimer${TimerNum} ((${Spell[${MezSpell}].Duration.TotalSeconds}+${MezMod})*10)*.95
                        /if (${DebugMez}) /echo \atDEBUGMEZ MezMobs MezTimer${TimerNum} ${MezTimer${TimerNum}} \agLine#: ${Macro.CurLine}
                        | Necro flag to release from mez loop since spell has 6 sec refresh.
                    } else /if (${Macro.Return.Equal[CAST_RESIST]} && ${MezFail}<2) {
                    /call BroadCast ${EQBCOn} g "MEZ Resisted -> ${Spawn[${MobID}].CleanName} <- ID:${MobID}"
                    /continue
                    } else /if (${Macro.Return.Equal[CAST_IMMUNE]}) {
                        /if (!${MezImmuneIDs.Find[|${Target.ID}]}) /call AddMezImmune ${Target.ID}
                    }
                    /break
                }
            }
            /varset MezTry 0
        }
        /if (${DebugMez}) /echo \atDEBUGMEZ MezMobs Leave \agLine#: ${Macro.CurLine}
    /return 
| -------------------------------------------------------------------------------------
| SUB: Do Debuff Stuff
| -------------------------------------------------------------------------------------
    Sub DoDebuffStuff(int FirstMobID)
        /doevents
        /if (!${DebuffAllOn} || !${DebuffCount} || ${Window[RespawnWnd].Open} || (${DMZ} && ${Me.InInstance}==FALSE) || (!${MyTargetID} && ${Spawn[=${MainAssist}].ID} && ${Spawn[=${MainAssist}].Type.NotEqual[Mercenary]})) /return
        /if (${DPSPaused}) {
            /if (${DebugCombat}) /echo DoDebuffStuff: Return from CombatCast cause DPSPaused is ${DPSPaused} \agLine#: ${Macro.CurLine}
            /return
        }
        /if (${DebugCombat}) /echo \atDEBUGDEBUFF DoDebuffStuff: Enter \agLine#: ${Macro.CurLine}
        /declare i               int      local 0
        /declare j               int      local 0
        /declare k               int      local 0
        /declare DebuffTargetID  int      local 0
        /declare DebuffText      string   local
        /if (${IAmABard} && ${MainAssist.Equal[${Me}]} && ${MyTargetID} && ${AggroTargetID}) {
            /if (${DebugCombat}) /echo im a bard and stuff so im getting out of here. Returning \agLine#: ${Macro.CurLine}
            /return
        }
        /call MobRadar ${MeleeDistance} DoDebuffStuff
        /for i 1 to ${DebuffCount}
            /if (${DBOList${i}.Length}) {
                /varset k 1
                /if (!${DBOTimer${i}}) {
                    | Reset the list with only the current DPS mob ID. So you won't try and debuff the mob again.
                    /varset DBOList${i} |${MyTargetID}
                } else {
                    |Remove mobs from list that are dead or over 200 units away.
                    /while (${DBOList${i}.Arg[${k},|].Length}) {
						/if (${DebugFramework}) /Echo Current Line ${Macro.CurLine}
                        /if (!${Spawn[${DBOList${i}.Arg[${k},|]}].ID} || ${Spawn[${DBOList${i}.Arg[${k},|]}].Distance}>200 || ${Spawn[${DBOList${i}.Arg[${k},|]}].Type.Equal[Corpse]}) {
                            /varset DBOList${i} ${DBOList${i}.Replace[|${DBOList${i}.Arg[${k},|]},]}
                        } else {
                            /varcalc k ${k}+1
                        }
                    }
                }
            }
        /next i
        | For Mobs
        /if (${DebugCombat}) /echo MobCount was ${MobCount} MainAssist: ${MainAssist} FirstMobID: ${FirstMobID} MyTargetID: ${MyTargetID} \agLine#: ${Macro.CurLine}
        /if (${Spawn[${FirstMobID}].Type.Equal[npc]} || (${Spawn[${FirstMobID}].Type.Equal[pet]} && ${Spawn[${FirstMobID}].Master.Type.NotEqual[pc]})) /call DebuffCast "${FirstMobID}" 1
        /for j 1 to 13
            |--- only call code for GroupEscape kick off.
            /varset DebuffTargetID ${MyTargetID}
            /if (${GroupEscapeOn} && ${Select[${Me.Class.ShortName},WIZ,DRU]} && (${Raid.Members}==0)) /call GroupEscape
            /if (${DPSPaused}) {
                /if (${DebugCombat}) /echo \atDEBUGCOMBAT DoDebuffStuff: Return from CombatCast cause DPSPaused is ${DPSPaused} \agLine#: ${Macro.CurLine}
                /return
            }
            /if (!${Me.XTarget[${j}].ID} || (${Me.XTarget[${j}].ID}==${FirstMobID})) /continue
            | Every Debuff test conditon is listed seperately because Maskoi forgets why he does anything.
            /if (${DebugCombat}) /echo \atDEBUGCOMBAT DoDebuffStuff: we are in the debuffcondition loop j is: ${j} \agLine#: ${Macro.CurLine}
            | Is Xtarget type not of type auto hater
            /if (${Me.XTarget[${j}].TargetType.NotEqual[Auto Hater]} || ${Spawn[${Me.XTarget[${j}].ID}].Type.Equal[Corpse]}) {
                /if (${DebugCombat}) /echo XTarget Type: ${Me.XTarget[${j}].TargetType} Spawn Type: ${Spawn[${Me.XTarget[${j}].ID}].Type}  \agLine#: ${Macro.CurLine}
                /continue
            }
            | Is mob in spell Radius distance
            /if (${Spawn[${Me.XTarget[${j}].ID}].Distance}>=${MeleeDistance}) {
                /if (${DebugMez}) /echo \atDEBUGCOMBAT DoDebuffStuff: ${j}  Mob distance is greater than MeleeDistance: ${Spawn[${Me.XTarget[${j}].ID}].Distance}  \agLine#: ${Macro.CurLine}
                /continue
            }
            | Test -> is the target in line of sight
            /if (!${Spawn[${Me.XTarget[${j}].ID}].LineOfSight}) {
                /if (${DebugCombat}) /echo \atDEBUGCOMBAT DoDebuffStuff: I dont have LineOfSight to Spawn[${Me.XTarget[${j}].ID}] ${Spawn[${Me.XTarget[${j}].ID}].Name} so im going to Skip Mob \agLine#: ${Macro.CurLine}
                /continue
            }
            /if (${Spawn[${Me.XTarget[${j}].ID}].Type.Equal[pc]} || (${Spawn[${Me.XTarget[${j}].ID}].Type.Equal[pet]} && ${Spawn[${Me.XTarget[${j}].ID}].Master.Type.Equal[pc]})) {
                /if (${DebugCombat}) /echo \atDEBUGCOMBAT DoDebuffStuff: Target is a PC or Pet of a PC. Skipping. \agLine#: ${Macro.CurLine}
                /continue
            }
            /varset DebuffTargetID ${Me.XTarget[${j}].ID}
            /if (${DebugCombat}) /echo \atDEBUGCOMBAT DoDebuffStuff Target: ${DebuffTargetID}=${Target.ID} DebuffAllOn: ${DebuffAllOn} J: ${j} \agLine#: ${Macro.CurLine}
            /if (${Me.Combat} && (${MainAssist.NotEqual[${Me}]} || ${DebuffTargetID}!=${Target.ID})) {
                /attack off
                /delay 10 !${Me.Combat}
            }
            | ****************  For Spells  *****************************
            /if (${DebuffAllOn}==2) {
                /call DebuffCast "${DebuffTargetID}" 1 
            } else {
                /call DebuffCast "${DebuffTargetID}" 0
            }
            /if (${DebugCombat}) /echo \atDEBUGCOMBAT DoDebuffStuff 4.0 \agLine#: ${Macro.CurLine}
            | Reset values if 3rd value in dps for All
            | ************ Next Mob ***************
        /next j
        /varset DebuffTargetID ${MyTargetID}
        /if (${Target.ID}!=${MyTargetID}) {
            /if (${Spawn[${MyTargetID}].Type.NotEqual[Corpse]}) {
                /target id ${MyTargetID}
                /delay 1s ${Target.ID}==${MyTargetID}
            }
        }
        /if (${DebugCombat}) /echo \atDEBUGDEBUFF DoDebuffStuff: Leave \agLine#: ${Macro.CurLine}
    /return
|--------------------------------------------------------------------------------
| SUB: DebuffCast
| -------------------------------------------------------------------------------------
    Sub DebuffCast(int DebuffTargetID, int FWait)
        /declare ActionReady     int      local 0
        /declare c               int      local 0
        /declare CastCount       int      local 0
        /declare CastRange       int      local 0
        /declare DebuffText      string   local
        /declare echoTimer       timer    local 0
        /declare f               int      local 0
        /declare g               int      local 0
        /declare i               int      local 0
        /declare Tag1            string   local
        /declare Tag2            string   local 
        /declare TempTimer       timer    local 0
        | ****************  For Spells  *****************************
        /if (${DebugCombat}) /echo DebuffCast Enter. \agLine#: ${Macro.CurLine}
        | g  - is control variable for remaining in loop while checking for mobs to debuff and spell is ready to cast.
        | c  - is to tell if the current mob is NOT on the Debuffed List or the debufftimer has runout. c=1 mob needs debuff, c=0 Mob can be skipped
        | f  - is a flag that is changed if we find a mob to debuff, but the current Spell or AA is not ready for casting, f=1 Spells/AA's were ready, f=0 Spell/AA not ready.
        | i  - is the index of the debuff to cast.
        | !${c} This mob has all debuffs, !${f} There is a debuff that was not ready for this mob.
        /while (1) {
			/if (${DebugFramework}) /Echo Current Line ${Macro.CurLine}
            /varset TempTimer 70
            /varset g 1
            /while (${g} && ${TempTimer}) {
                /if (${DebugFramework}) /Echo Current Line ${Macro.CurLine}
				/varset c 0
                /varset f 1
                /if (${i}==${DebuffCount}) {
                    | We should wait for spell ready. Debuffing is more important.
                    /if (${FWait}) {
                        /varset i 0
                        | We have tried every debuff even after waiting, so we need to leave.
                        /if (${CastCount}==${DebuffCount}) /varset f 0
                    } else {
                        | We checked every debuff, and I am not waiting any longer. DPS is more important
                        /varset f 0
                    }
                }
                /while (${f} && ${i}<${DebuffCount}) {
                    /if (${DebugFramework}) /Echo Current Line ${Macro.CurLine}
					/varset ActionReady 0
                    /varcalc i ${i}+1
                    /varset DebuffText ${DPS[${i}].Arg[1,|]}
                    /if (${Int[${Spell[${DebuffText}].Range}]}>=${Int[${Spell[${DebuffText}].AERange}]}) {
                        /varset CastRange ${Spell[${DebuffText}].Range}
                    } else {
                        /varset CastRange ${Spell[${DebuffText}].AERange}
                    }
                    /if (${DebugCombat}) /echo ${DebuffText} ${DPS[${i}].Length} ${DebuffText.NotEqual[null]} ${DBOList${i}.Find[|${DebuffTargetID}]} ${DBOTimer${i}} ${i} ${DebuffCount} ${TempTimer} \agLine#: ${Macro.CurLine}                 
                    |If mob not on list or debuff timer expired then increment counter of mobs needing debuff.
                    /if (${DPS[${i}].Length} && ${DebuffText.NotEqual[null]} && (!${DBOList${i}.Find[|${DebuffTargetID}]} || ${DBOTimer${i}}==0)) {
                        /varset c 1
                        | is spell or AA ready to cast? If ready set flag to drop out of loop.
                        /if (${Select[TRUE,${Me.SpellReady[${DebuffText}]},${Me.AltAbilityReady[${DebuffText}]},${Me.ItemReady[=${DebuffText}]}]}) {
                            /varset f 0
                        } else {
                            /if (${DBOTimer${i}} && ${SpawnCount[xtarhater]}>1) {
                            /if (${FWait} && !${echoTimer}) {
                                    /varset ActionReady ${Select[TRUE,${Bool[${Me.Book[${DebuffText}]}]},${Bool[${Me.AltAbility[${DebuffText}]}]},${Bool[${FindItem[=${DebuffText}].ID}]}]}
                                | This is a spell.
                                    /if (${ActionReady}==1) {
                                    /if (${Me.SpellInCooldown}) {
                                        /if (${Int[${Me.Gem[${DebuffText}]}]}) {
                                            /if (!${Me.GemTimer[${DebuffText}]}) {
                                                /echo Waiting on Spell Global Cool Down To Cast ${DebuffText}
                                                /varset echoTimer 3s
                                            }
                                        }
                                    } else /if (${Int[${Me.Gem[${DebuffText}]}]} && ${Me.GemTimer[${DebuffText}]}) {
                                        /echo Waiting on Spell: ${DebuffText} to Refresh. Time Remaining: ${Me.GemTimer[${DebuffText}].TotalSeconds} Seconds.
                                        /varset echoTimer ${Me.GemTimer[${DebuffText}]}
                                    }
                                    | This is an AltAbility
                                    } else /if (${ActionReady}==2) {
                                    /if (${Math.Calc[${Me.AltAbilityTimer[${DebuffText}].TotalSeconds}*10]}<=${TempTimer} && ) {
                                        /echo Waiting on AltAbility To Cast ${DebuffText}
                                        /varset echoTimer ${TempTimer}
                                    } else {
                                        /echo Skipping AltAbility. Wait time is to long for ${DebuffText}
                                        /if (${DBOTimer${i}}==0) /varcalc DBOTimer${i} ${Me.AltAbilityTimer[${DebuffText}].TotalSeconds}*10
                                    }
                                    | This is an Item
                                    } else /if (${ActionReady}==3) {
                                    /if (${Math.Calc[${FindItem[=${DebuffText}].TimerReady}*10]}<=${TempTimer}) {
                                        /echo Waiting on Item To Cast ${DebuffText}
                                        /varset echoTimer ${TempTimer}
                                    } else {
                                        /echo Skipping Item. Wait time is to long for ${DebuffText}
                                        /if (${DBOTimer${i}}==0) /varcalc DBOTimer${i} ${FindItem[=${DebuffText}].TimerReady}*10
                                    }                          
                                }
                            }
                            }
                            /if (${MezOn}) /doevents MezBroke
                            /if (${UseModHeal}==0 && ${HealsOn}==1) {
								/if (${HealsOn}) /call CheckHealth				
							} else /if (${UseModHeal}==1 && ${HealsOn}==1 && ((${Spawn[${WorstHurt[both,1,200,TRUE]}].Type.NotEqual[Pet]} && ${Spawn[${WorstHurt[both,1,200,TRUE]}].Class.ShortName.NotEqual[Corpse]} && ${Spawn[${WorstHurt[both,1,200,TRUE]}].PctHPs} <= ${Math.Calc[${${Spawn[${WorstHurt[both,1,200,TRUE]}].Class.ShortName}Point}*.${tmpHealOverride}]}) || (${Spawn[${WorstHurt[both,1,200,TRUE]}].Type.Equal[Pet]} && ${Spawn[${WorstHurt[both,1,200,TRUE]}].Class.ShortName.NotEqual[Corpse]} && ${Spawn[${WorstHurt[both,1,200,TRUE]}].PctHPs} <= ${Math.Calc[${PetPoint}*.${tmpHealOverride}]}))) {
								/echo ${Macro.CurLine}
								/call NewCast ${Spawn[${WorstHurt[both,1,200,TRUE]}].ID} "Heals"
							}
                        }
                    }
                }
                /if (${DebugCombat}) /echo ${c} ${f}  ${FWait} \agLine#: ${Macro.CurLine}
                /if (!${c} || !${f} || (${f} && !${FWait})) /varset g 0 
            }
            /if (${DebugCombat}) /echo \atDEBUGCOMBAT DebuffCast 0 DebuffTargetID: ${DebuffTargetID} ${i} C: ${c} F: ${f} FWait: ${FWait} \agLine#: ${Macro.CurLine}
            /if (${MezOn}) /varset MezBroke 0
            /varset GoMByPass 1
            /doevents
            /varset GoMByPass 0
            /if (${DPSPaused}) {
                /if (${DebugCombat}) /echo DebuffCast: Return from DebuffCast cause DPSPaused is ${DPSPaused} \agLine#: ${Macro.CurLine}
                /return
            }
            /if (!${c} || ${g} || (${f} && !${FWait})) {
                /if (${DebugCombat}) /echo DebuffCast Exit. \agLine#: ${Macro.CurLine}
                /return
            }
            /if (${DebugCombat}) /echo \atDEBUGCOMBAT DebuffCast 1 DebuffTargetID: ${DebuffTargetID} ${i} Find: ${DBOList${i}.Find[|${DebuffTargetID}]} Timer: ${DBOTimer${i}} List: ${DBOList${i}} \agLine#: ${Macro.CurLine}
            /if (${GroupEscapeOn} && ${Select[${Me.Class.ShortName},WIZ,DRU]} && (${Raid.Members}==0)) /call GroupEscape
            /if (${MezOn} && !${MezBroke}) {
                /call DoMezStuff DebuffCast
            }
            /varset TempTimer 0
            /varset Tag1 ${DPS[${i}].Arg[4,|]}
            /varset Tag2 ${DPS[${i}].Arg[5,|]}
            /if (${Tag1.Equal[always]}) /varset Tag2 always
            | Test -> Do i have enough mana to cast the spell 
            /if (${Me.CurrentMana}<${Spell[${DebuffText}].Mana}) {
                /if (${DebugCombat}) /echo \atDEBUGCOMBAT DebuffCast: i didnt have enough mana to cast ${DebuffText} so im going to Skip Cast \agLine#: ${Macro.CurLine}
                /varcalc CastCount ${CastCount}+1
                /continue
            }
            /if (${Spawn[${DebuffTargetID}].Type.Equal[Corpse]} || ${Int[${Spawn[${DebuffTargetID}].ID}]}==0) /return
            /if (${Target.ID}!=${DebuffTargetID}) {
                /squelch /target clear
                /delay 10 ${Target.ID}==0
                /target id ${DebuffTargetID}
                /delay 20 ${Target.ID}==${DebuffTargetID} && ${Target.BuffsPopulated}==TRUE
            }
            /if (${DebugCombat}) /echo \atDEBUGCOMBAT DebuffCast: Debuff: ${DebuffText} TargetID: ${Target.ID} DebuffTargetID: ${DebuffTargetID} : ${Target.Buff[${DebuffText}].ID} ${Target.Buff[${DebuffText}].Caster} ${Me.SpellInCooldown} ${Tag1} ${Tag2} ${Target.BuffsPopulated} \agLine#: ${Macro.CurLine}
            /while (1) {
                /if (${DebugFramework}) /Echo Current Line ${Macro.CurLine}
				| Check Target for Buffs
                /if (${Target.BuffCount}) {
                    | Does the Target have the debuff I am about to cast
                    /if (${Target.Buff[${DebuffText}].ID}) {
                        /if (${Target.Buff[${DebuffText}].Caster.Equal[${Me.CleanName}]} || (${Target.Buff[${DebuffText}].Caster.NotEqual[${Me.CleanName}]} && ${Tag2.NotEqual[always]})) {
                            /varcalc TempTimer ${Target.BuffDuration[${DebuffText}].TotalSeconds}*10
                        }
                    }
                    | If timer didn't get set above then check this
                    /if (${TempTimer}==0) {          
                        | Does the mob have one of the following debuffs if so lets skip casting
                        /if (${Tag1.Equal[strip]} && (${Int[${Target.Beneficial.ID}]}==0 || ${Int[${Target.Beneficial.ID}]}==38728 || ${Int[${Target.Beneficial.ID}]}==38727)) {
                            /varset TempTimer 70
                        } else /if (${Tag2.NotEqual[always]}) {
                            /if (${Tag1.Equal[slow]} && ${Target.Slowed.ID}) {
                                /varcalc TempTimer ${Target.BuffDuration[${Target.Slowed.Name}].TotalSeconds}*10
                            } else /if (${Tag1.Equal[tash]} && ${Target.Tashed.ID}) {
                                /varcalc TempTimer ${Target.BuffDuration[${Target.Tashed.Name}].TotalSeconds}*10
                            } else /if (${Tag1.Equal[malo]} && ${Target.Maloed.ID}) {
                                /varcalc TempTimer ${Target.BuffDuration[${Target.Maloed.Name}].TotalSeconds}*10
                            } else /if (${Tag1.Equal[crip]} && ${Target.Crippled.ID}) {
                                /varcalc TempTimer ${Target.BuffDuration[${Target.Crippled.Name}].TotalSeconds}*10
                            } else /if (${Tag1.Equal[snare]} && ${Target.Snared.ID}) {
                                /varcalc TempTimer ${Target.BuffDuration[${Target.Snared.Name}].TotalSeconds}*10
                            }
                        }
                    }
                    /if (${TempTimer}) {
                        /if (!${DBOList${i}.Find[|${DebuffTargetID}]}) /varset DBOList${i} ${DBOList${i}}|${DebuffTargetID}
                        /break
                    } 
                    /if (${DebugCombat}) /echo \atDEBUGCOMBAT DebuffCast: DebuffTargetID: ${DebuffTargetID} Slowed: ${Target.Slowed.ID} Tashed: ${Target.Tashed.ID} Maloed: ${Target.Maloed.ID} Crippled:${Target.Crippled.ID} Tag1: ${Tag1} Tag2: ${Tag2} TempTimer: ${TempTimer} \agLine#: ${Macro.CurLine}
                }
                /if (${UseModHeal}==0 && ${HealsOn}==1) {
					/if (${HealsOn}) /call CheckHealth				
				} else /if (${UseModHeal}==1 && ${HealsOn}==1 && ((${Spawn[${WorstHurt[both,1,200,TRUE]}].Type.NotEqual[Pet]} && ${Spawn[${WorstHurt[both,1,200,TRUE]}].Class.ShortName.NotEqual[Corpse]} && ${Spawn[${WorstHurt[both,1,200,TRUE]}].PctHPs} <= ${Math.Calc[${${Spawn[${WorstHurt[both,1,200,TRUE]}].Class.ShortName}Point}*.${tmpHealOverride}]}) || (${Spawn[${WorstHurt[both,1,200,TRUE]}].Type.Equal[Pet]} && ${Spawn[${WorstHurt[both,1,200,TRUE]}].Class.ShortName.NotEqual[Corpse]} && ${Spawn[${WorstHurt[both,1,200,TRUE]}].PctHPs} <= ${Math.Calc[${PetPoint}*.${tmpHealOverride}]}))) {
					/echo ${Macro.CurLine}
					/call NewCast ${Spawn[${WorstHurt[both,1,200,TRUE]}].ID} "Heals"
				}
                | Wait here for a sec, your spell bar may still be in global cool down.
                /if (${Me.SpellInCooldown}) {
                    /delay 10
                }
                | When you get here you won't want to cast Eradicate Magic if the mob has NO Beneficial Buffs
                /if (${Tag1.Equal[strip]} && (${Int[${Target.Beneficial.ID}]}==0 || ${Int[${Target.Mezzed.ID}]})) {
                    /if (!${DBOList${i}.Find[|${DebuffTargetID}]}) /varset DBOList${i} ${DBOList${i}}|${DebuffTargetID}
                    /varset TempTimer 70
                    /break
                }
                | Conditional Check Added.
                /if (${ConOn} && ${DPS[${i}].Find[|cond]} && ${If[${Cond[${DPS[${i}].Mid[${Math.Calc[${DPS[${i}].Find[|cond]}+5]},3]}]},0,1]})  /break
                | Everything is ready, lets debuff this mob
                /call CastWhat "${DebuffText}" ${DebuffTargetID} DebuffCast 0 0
                /if (${DebugCombat}) /echo \atDEBUGCOMBAT DebuffCast: Return From CastWhat: ${Macro.Return} \agLine#: ${Macro.CurLine}
                /if (${Macro.Return.Equal[CAST_RESIST]}) {
                    /echo ** ${DebuffText} on >> ${Spawn[${DebuffTargetID}].CleanName} << - RESISTED
                } else /if (${Macro.Return.Equal[CAST_TAKEHOLD]}) {
                    /echo ** ${DebuffText} on >> ${Spawn[${DebuffTargetID}].CleanName} << - DID NOT TAKE HOLD
                    /varset TempTimer 3m
                } else /if (${Macro.Return.Equal[CAST_IMMUNE]}) {
                    /echo ** ${Spawn[${DebuffTargetID}].CleanName} is IMMUNE to - ${DebuffText}
                    /if (!${DBOList${i}.Find[|${DebuffTargetID}]}) /varset DBOList${i} ${DBOList${i}}|${DebuffTargetID}
                    /varset TempTimer 3m
                } else /if (${Macro.Return.Equal[CAST_SUCCESS]}) {
                    /echo ** Debuffing: ==> ${DebuffText} on >> ${Spawn[${DebuffTargetID}].CleanName} << DebuffTargetID: ${DebuffTargetID} Target: ${Target.ID} DBOList: ${DBOList${i}}
                    /if (!${DBOList${i}.Find[|${DebuffTargetID}]}) /varset DBOList${i} ${DBOList${i}}|${DebuffTargetID}
                    | Timers for items    
                    /if (${FindItemCount[=${DebuffText}]}) {
                        /varcalc TempTimer ${FindItem[=${DebuffText}].Spell.Duration.TotalSeconds}*10
                        | Timers for AltAbilities
                    } else /if (${Me.AltAbility[${DebuffText}]}) {
                        /varcalc TempTimer ${Me.AltAbility[${DebuffText}].Spell.Duration.TotalSeconds}*10
                        | Timers for spells
                    } else /if (${Me.Book[${DebuffText}]}) {
                        | - Custom timer for counterbias
                        /if (${Me.Class.Name.Equal[Shaman]} && ${DebuffText.Find[counterbias]}) {
                            /varset TempTimer 1.5m
                            | Custom timer for Chanter suffocation
                        } else /if (${Me.Class.Name.Equal[enchanter]} && ${DebuffText.Find[suffocation]}) {
                            /varset TempTimer 1m
                            | Custom timer for Beastlord Feralgia Timer
                        } else /if (${Me.Class.Name.Equal[Beastlord]} && ${DebuffText.Find[feralgia]}) {
                            /varset TempTimer 1.5m
                            | Regular spells
                        } else /if (${Spell[${DebuffText}].Duration}>0) {
                            /varcalc TempTimer ${Spell[${DebuffText}].Duration.TotalSeconds}*10
                            | Spells with no timers assign DPS interval
                        } else {
                            /varset TempTimer ${DPSInterval}s
                        }
                        | AA and disc timers
                    } else /if (${Spell[${DebuffText}].Duration}>0) {
                        /varcalc TempTimer ${Spell[${DebuffText}].Duration.TotalSeconds}*10
                        | AA and disc with no timers assign DPS interval
                    } else {
                        /varset TempTimer ${DPSInterval}s
                    }
                }
                /break
            }
            | Check Debuff Timer not set and the Temp Timer has been set.
            | You only want to set the DBOTimer for the first mob you get the Debuff to land on. Don't need a timer for every mob.
            /if (!${DBOTimer${i}} && ${TempTimer}) {
                /varcalc DBOTimer${i} ${TempTimer}*.95
            }
            | ************ Next Spell ***********
            /varcalc CastCount ${CastCount}+1
            /if (${DebugCombat}) /echo \atDEBUGCOMBAT DebuffCast 2 DebuffTargetID: ${DebuffTargetID} ${i} Find: ${DBOList${i}.Find[|${DebuffTargetID}]} Timer: ${DBOTimer${i}} List: ${DBOList${i}} ${CastCount} \agLine#: ${Macro.CurLine}
        }
        /if (${DebugCombat}) /echo DebuffCast leave. \agLine#: ${Macro.CurLine}
    /return
| -------------------------------------------------------------------------------------
| SUB: Event MezBroke
| -------------------------------------------------------------------------------------
    Sub Event_MezBroke(meztext,mezmob,mezbreaker)
        /if (${DebugMez}) /echo \atDEBUGMEZ event mezbroke Enter \agLine#: ${Macro.CurLine}
		/popup  >>${Spawn[${mezbreaker}].CleanName} << has awakened -> ${mezmob}<-
        /if (!${MezOn}) /return
        | Get out of here. DoMezStuff triggered this call after being called from here. See Below.
        /if (${EventByPass}==2) /return
        /if (${Spawn[${mezbreaker}].CleanName.Equal[${MainAssist}]}) {
            /assist ${MainAssist}
            /delay 1s ${Me.AssistComplete}==TRUE
            /if (${Target.ID}!=${MyTargetID}) /varset MyTargetID ${Target.ID}
            /if (!${Group.Member[${MainAssist}].Index} && ${Me.XTarget[${XTSlot}].ID}!=${Target.ID} && ${Target.Type.NotEqual[PC]}) /xtarget set ${XTSlot} currenttarget
            /return
        }
        /if (${Spawn[${MainAssist}].Type.Equal[pet]} && ${Spawn[${MainAssist}].Master.CleanName.Equal[${mezbreaker}]}) /return
        /declare i int local
        /call BroadCast ${EQBCOn} g ">>  ${Spawn[${mezbreaker}].CleanName} << has awakened -> ${mezmob}<-"
        /for i 1 to 30
            /if (${MezArray[${i},3].Equal[${mezmob}]}) {
                /echo Resetting Mez Timer ${mezmob} ID: ${MezArray[${i},1]}
                /varset MezTimer${i} 0
            }
        /next i
        /doevents flush MezBroke
        | Get Out of here and return back to DoMezStuff. This event was triggered by DoMezStuff.
            /if (${EventByPass}==1) /return
            /varset GoMByPass 1
            /varset EventByPass 2
        |/call FindTarget 7
		|/call CombatTargetCheck
            /call DoMezStuff Event_MezBroke
            /varset EventByPass 0
            /varset GoMByPass 0
            | Set MezOn = 2 to let us know that the event was triggered. Will be set back to 1 in other location
            /varset MezBroke 1
        /if (${DebugMez}) /echo \atDEBUGMEZ event mezbroke Leave \agLine#: ${Macro.CurLine}
    /return
| -------------------------------------------------------------------------------------
| SUB: Event MezImmune
| -------------------------------------------------------------------------------------
    Sub Event_MezImmune(int MezID)
        /if (${Select[${Me.Class.ShortName},Brd,Enc,Nec]}==0) /return
        | Assign temp var MezImmune list
        /declare ImmuneAdd string local ${MezImmune}
        | If mezimmune default text with the word null in it assign var spawn clean name
        /if (${ImmuneAdd.Find[null]}) {
            /varset ImmuneAdd ${Spawn[${MezID}].CleanName}
        } else {
            /varset ImmuneAdd ${ImmuneAdd},${Spawn[${MezID}].CleanName}
        }
        /if (!${MezImmune.Find[${Spawn[${MezID}].CleanName}]}) /ini "${InfoFileName}" "${Zone}${If[${Me.InInstance},_I,]}" "MezImmune" "${ImmuneAdd}"
        /call BroadCast ${EQBCOn} g "MEZ Immune -> ${Spawn[${MezID}].CleanName} <- ID:${MezID} Adding to MezImmune list."
        | Reassign mezimmune var the new list
        /varset MezImmune ${ImmuneAdd}
    /return
| -------------------------------------------------------------------------------------
| SUB: AddMezImmune
| -------------------------------------------------------------------------------------
    Sub AddMezImmune(int MezID)
        /if (${Select[${Me.Class.ShortName},Brd,Enc,Nec]}==0) /return
        /if (${MezImmuneIDs.Find[|${MezID}]}) /return
        /varset MezImmuneIDs ${MezImmuneIDs}|${MezID} 
        /call BroadCast ${EQBCOn} g "MEZ Immune -> ${Spawn[${MezID}].CleanName} <- ID:${MezID} Skipping."
    /return
| -------------------------------------------------------------------------------------
| SUB: Bind AddMezImmune
| -------------------------------------------------------------------------------------
    Sub Bind_AddMezImmune(MTImmune)
        /if (!${MTImmune.Length} || ${MTImmune.Find[null]} || ${Spawn[${MTImmune}].ID}==${Me.ID} ) {
            /echo No NPCs detected. Nothing added to list.
            /return
        }
        | Assign temp var MezImmune list
        /declare MezImmuneAdd string local ${MezImmune}
        | If MezImmune default text with the word null in it assign var spawn clean name
        /if (${MezImmuneAdd.Find[null]} && ${MezImmune.Find[null]}) {
            /varset MezImmuneAdd ${Spawn[${MTImmune}].CleanName}
        } else {
            /varset MezImmuneAdd ${MezImmune},${Spawn[${MTImmune}].CleanName}
        }
        | Remove's corpse if closest match is a mob corpse
        /if (${MezImmuneAdd.Right[-10].Find[corpse]}) /varset MezImmuneAdd ${MezImmuneAdd.Right[-8]}
        /if (${MezImmune.Find[${Spawn[${MTImmune}].CleanName}]}) {
            /echo >> ${Spawn[${MTImmune}].CleanName} << already on Mez Immune List.
            /return
        }
        /if (${Spawn[${MTImmune}].CleanName.Equal[null]}) {
            /echo No Mob with ${MTImmune} in Name detected.
            /return
        }
        /if (!${MezImmune.Find[${Spawn[${MTImmune}].CleanName}]}) {
            /ini "${InfoFileName}" "${ZoneName}" "MezImmune" "${MezImmuneAdd}"
            /echo MezImmune -> ${Spawn[${MTImmune}].CleanName} <- Adding to Mez Immune  list.
        }
        | Reassign MezImmune var the new list
        /varset MezImmune ${MezImmuneAdd}
    /return    
| -------------------------------------------------------------------------------------
| SUB: Bind AddToIgnore
| -------------------------------------------------------------------------------------
    Sub Bind_AddToIgnore(MTIgnore, int byID)
        | Take the targeted mob as a parameter for mob to ignore.
        /if (!${Defined[MTIgnore]}) /declare MTIgnore string local ${Target.CleanName}
        
        /if (!${byID}) {
            /if (${MTIgnore.Equal[null]} || !${Spawn[${MTIgnore}].Type.Equal[NPC]} || ${Spawn[${MTIgnore}].CleanName.Equal[null]}) {
                /echo No NPCs named (${MTIgnore}) detected. Nothing added to list. ${byID}
                /return
            }
            | Assign temp var   list
            /declare IgnoreAdd string local ${MobsToIgnore}
            | If MobsToIgnore default text with the word null in it assign var spawn clean name
            /if (${IgnoreAdd.Find[null]}) {
                /varset IgnoreAdd ${Spawn[${MTIgnore}].CleanName}
            } else {
                /varset IgnoreAdd ${IgnoreAdd},${Spawn[${MTIgnore}].CleanName}
            }  
            | Remove's corpse if closest match is a mob corpse
            /if (${IgnoreAdd.Right[-10].Find[corpse]}) /varset IgnoreAdd ${IgnoreAdd.Right[-8]}
            /if (${MobsToIgnore.Find[${Spawn[${MTIgnore}].CleanName}]}) {
                /echo >> ${Spawn[${MTIgnore}].CleanName} << already on Ignore List.
                /return
            }
            /ini "${InfoFileName}" "${ZoneName}" "MobsToIgnore" "${IgnoreAdd}"
            /echo AddToIgnore -> ${Spawn[${MTIgnore}].CleanName} <- Adding to Ignore list.
            | Reassign MobsToIgnore var the new list
            /varset MobsToIgnore ${IgnoreAdd}
        } else {
            /if (${MTIgnore.Equal[null]} || !${Spawn[id ${MTIgnore}].Type.Equal[NPC]} || ${Spawn[id ${MTIgnore}].CleanName.Equal[null]}) {
                /echo No NPCs with ID: (${MTIgnore}) detected. Nothing added to list. ${byID}
                /return
            }
            /if (${Int[${MTIgnore}]}>0 && !${MobsToIgnoreByID.Find[${MTIgnore}|]}) {
                /varset MobsToIgnoreByID ${MTIgnore}|${MobsToIgnoreByID}
            }
        }
    /return
| -------------------------------------------------------------------------------------
| SUB: Bind AddToPull
| -------------------------------------------------------------------------------------
    Sub Bind_AddToPull(MTPull)
        /if (!${MTPull.Length} || ${MTPull.Find[null]} || ${Spawn[${MTPull}].ID}==${Me.ID} ) {
            /echo No NPCs detected. Nothing added to list.
            /return
        }
        | Assign temp var MobsToPull list
        /declare PullAdd string local ${MobsToPull}
        | If MobsToPull default text with the word null in it assign var spawn clean name
        /if (${PullAdd.Find[all]}) {
            /varset PullAdd ${Spawn[${MTPull}].CleanName}
        } else {
            /varset PullAdd ${PullAdd},${Spawn[${MTPull}].CleanName}
        }
        | Remove's corpse if closest match is a mob corpse
        /if (${PullAdd.Right[-10].Find[corpse]}) /varset PullAdd ${PullAdd.Right[-8]}
        /if (${MobsToPull.Find[${Spawn[${MTPull}].CleanName}]}) {
            /echo >> ${Spawn[${MTPull}].CleanName} << already on Pull List.
            /return
        }
        /if (${Spawn[${MTPull}].CleanName.Equal[null]}) {
            /echo ERROR: No Mob with ${MTPull} in Name detected.
            /return
        }
        /if (!${MobsToPull.Find[${Spawn[${MTPull}].CleanName}]}) {
            /ini "${InfoFileName}" "${ZoneName}" "MobsToPull" "${PullAdd}"
            /echo AddToPull-> ${Spawn[${MTPull}].CleanName} <- Adding to Pull list.
        }
        | Reassign MobsToPull var the new list
        /varset MobsToPull ${PullAdd}
    /return
| ----------------------------------------------------------------------------
| SUB: Add a friend to mq2posse list
| ----------------------------------------------------------------------------
    Sub Bind_AddAFriend
        /declare AFriend string local ${Target.CleanName}
        /if (!${Target.ID} || ${Spawn[${Target.ID}].Type.NotEqual[pc]} || ${Target.ID}==${Me.ID}) {
            /echo --ADDFRIEND: Target a PC to add your Posse list.
            /return
        }
        /docommand /posse add ${AFriend}
        /docommand /posse save
        /docommand /posse load
    /return    
| -------------------------------------------------------------------------------------
| SUB: Bind_ToggleVariable  Check whenever the player is changing any variable via /echo
| -------------------------------------------------------------------------------------
    Sub Bind_ToggleVariable(string Command, string Command2, string Command3)
        /if (${Debug}) /echo ${Command} ${Defined[${Command}]} ${Command2} ${Command3}
        /declare i int local
        /declare OnOff local
        | Toggle Variables & Set Variables
        /if (${Defined[${Command}]}) {
            /if (${Debug}) /echo ${Command}:${${Command}} ${Defined[${Command}]} ${Command2} ${Command3}
            /if (${Select[${Command2},0,1,on,off]}) {
                /if (${Select[${Command2},0,off]}) {
                    /varset ${Command} 0
                    /varset OnOff Off
                    /if (${Debug}) /echo ${OnOff} 1
                } else /if (${Select[${Command2},1,on]}) {
                    /varset ${Command} 1
                    /varset OnOff On
                    /if (${Debug}) /echo ${OnOff} 2
                } 
            } else /if (${${Command}}) {
                /varset ${Command} 0
                /varset OnOff Off
                /if (${Debug}) /echo ${OnOff} 3
                /if (!${ChaseAssist} && ${Stick.Active})  /squelch /stick off
            } else {
                /varset ${Command} 1
                /varset OnOff On
                /if (${Debug}) /echo ${OnOff} 4
            }
            /if (${Command.Equal[ChaseAssist]}) {
                /if (${OnOff.Equal[on]}) {
                    /if (${Command3.NotEqual[null]} && ${Command3.Length}>0 && ${WhoToChase.NotEqual[${Command3}]}) {
                        /varset WhoToChase ${Command3}
                        /echo I Will Now Chase ${WhoToChase}
                    }
                    /if (${ReturnToCamp}) /varset ReturnToCamp 0
                } else {
                    /if (${Stick.Active}) /squelch /stick off
                }
            }
            | Turn on return to camp & set new y,x coord
            /if (${Command.Equal[ReturnToCamp]} && ${OnOff.Equal[on]}) {
                /varset CampXLoc ${Me.X}
                /varset CampYLoc ${Me.Y}
                /varset CampZLoc ${Me.FloorZ}
                /varset LookForward ${Me.Heading.DegreesCCW}
                | Turn off ChaseAssit if on
                /if (${ChaseAssist}) {
                    /varset ChaseAssist 0
                    /ini "${IniFileName}" "General" "ChaseAssist" "0"
                    /if (${Stick.Active}) /squelch /stick off
                    /echo >> ChaseAssist Off
                }
                /if (${CampZone}!=${Zone.ID}) /varset CampZone ${Zone.ID}
                /echo >> New camp set ${Me.Y}, ${Me.X}
            }
            /if (${Command.Find[Debug]}) {
                /if (${EverQuest.CurrentUI.NotEqual[Default]}) {
                    /echo You are using a Custom UI. Please switch to Default UI before Posting.
                }
            }
            /if (${Command.Equal[AutoRezAll]}) {
                /if (${OnOff.Equal[off]}) {
                    /varset CorpseRezCheck null
                    /echo No longer Rezing Everyone.
                } else {
                    /echo Now Rezing Everyone.
                }
            }
            /if (${Debug}) /echo ${Command} ${Command2} ${Command3}
            /echo >> Setting: (${Command}) to (${If[${Select[${OnOff},on,1]}>0,On,Off]})
        } else /if (${Command.Equal[waithere]}) {
            /varset ChaseAssist 0
            /varset ReturnToCamp 0
            /if (${Stick.Active}) /squelch /stick off
        }
    /return
| -------------------------------------------------------------------------------------
| SUB: DoMiscStuff
| -------------------------------------------------------------------------------------
    Sub DoMiscStuff
        /if (!${ChainPull} && (${CombatStart} || ${AggroTargetID})) /return
        /if (${Debug}) /echo \atDEBUG DoMiscStuff Enter \agLine#: ${Macro.CurLine}
        /if (${Window[alertwnd].Open}) /nomodkey /notify alertwnd ALW_Close_Button leftmouseup
        | Accept trades
        /if (${Window[TradeWnd].Open} && ${Window[TradeWnd].HisTradeReady} && !${Cursor.ID}) /notify TradeWnd TRDW_Trade_Button leftmouseup
        | Accept group invite
        /if (${Window[GroupWindow].Child[GW_FollowButton]} && ${AcceptInvitesOn}) /invite
        | Ditch wizards familiar
        /if (${Me.Pet.CleanName.Equal[${Me.Name}`s familiar]} && ${Me.Class.ShortName.Equal[Wiz]}) /pet get lost
        | Drop random items on cursor like drive by mod rods into inventory after 30s min
        /if (${Cursor.ID} && !${CursorIDTimer}) {
            /varset CursorIDTimer 20s
            /if (${Me.FreeInventory}) {
                /echo ${Cursor.Name} is stuck on my cursor. Dropping it into inventory in 15s.
                /timed 150 /autoinventory
            } else /if (!${Me.FreeInventory}) {
                /echo HEY YOUR INVENTORY IS FULL!
            }
        }
        /if (${PullPause.NotEqual[0]} && !${PullHold} && !${PullWaitTimer2}) {
           /varset PullWaitTimer1 ${PullPause.Arg[1,"|"]}m
           /varset PullWaitTimer2 ${PullPause.Arg[2,"|"]}m
        }
        /if (${PullPause.NotEqual[0]} && !${PullWaitTimer1}) {
            /if (!${PullHold}) {
                /echo Pausing Pulls for ${PullPause.Arg[2,"|"]} Minutes. 
                /if (${ReturnToCamp}) /call DoWeMove 1 DoMiscStuff
                /varset PullHold 2
                /varset PullWaitTimer1 ${PullPause.Arg[2,"|"]}m
            } else /if (${PullHold}==2) {
                /echo Resetting Pull Timer for ${PullPause.Arg[1,"|"]} Minutes. 
                /varset PullHold 0
                /varset PullWaitTimer1 ${PullPause.Arg[1,"|"]}m
                /varset PullWaitTimer2 ${PullPause.Arg[2,"|"]}m
            }
        }
        /if (${Debug}) /echo \atDEBUG DoMiscStuff Leave \agLine#: ${Macro.CurLine}
    /return
| -------------------------------------------------------------------------------------
| SUB: Can I do Stuff  - Check if invis moving ducked etc
| -------------------------------------------------------------------------------------
    Sub CanIDoStuff
    /if ((${CombatStart} || ${AggroTargetID} || ${Me.CombatState.NotEqual[COMBAT]})) /return
    /if (${Debug}) /echo \atDEBUG CanIDoStuff Enter \agLine#: ${Macro.CurLine}
    /declare DoLoop int local 1
	|/if (${IAmDead} && ${CampZone}==${Zone.ID} && (${Me.Buff[Resurrection Sickness].ID} || ${SpawnCount[pccorpse ${Me}]}==0) ) {
    /if (${IAmDead} && ${CampZone}==${Zone.ID} && ${Me.Buff[Resurrection Sickness].ID}) ) {
        /varset IAmDead 0
        /if (${IAmABard}) {
            /while (${Me.BardSongPlaying}) {
                /if (${DebugFramework}) /Echo Current Line ${Macro.CurLine}
				/if (${Twist}) /squelch /twist off
                /stopsong
                /delay 5
            }
            /varset Twisting 0
            /varset DPSTwisting 0
        }
    }
    | Turn off twist while invis
    /if (${Me.Invis} && ${IAmABard} && ${Twist}) {
        /while (${Me.BardSongPlaying}) {
            /if (${DebugFramework}) /Echo Current Line ${Macro.CurLine}
			/if (${Twist}) /squelch /twist off
            /stopsong
            /delay 5
        }
    }
    | Assign Master looter    
    /if (${Select[${Me},${Group.Leader}]}==1) /call AssignLooter
    /while (${DoLoop}) {
        /if (${DebugFramework}) /Echo Current Line ${Macro.CurLine}
		/doevents
        /call WriteDebuffs
        /call RogueStuff
        /delay 2
        /call EndMacroIf
        /if (${Debug} && ${Me.Invis}) /echo You are invisible. 
        /if (${Me.Moving} || ${Me.State.Equal[feign]} || (${ChaseAssist}==0 && ${AggroTargetID}==0 && ${Me.Invis} && ${Me.Class.Name.NotEqual[Rogue]}) || ${Me.Stunned} || ${Me.Ducking}  || (${Me.State.Equal[BIND]} && !${Window[LootWnd].Open})) /continue
        /if (${Window[MerchantWnd]} || ${Window[GiveWnd]} || ${Window[SpellBookWnd]} || ${Window[BigBankWnd]} || ${Window[BankWnd]} || ${Window[GuildBankWnd]}  || ${Window[TributeMasterWnd]} || ${Window[GuildTributeMasterWnd]}) /continue
        /varset DoLoop 0
    }
    /if (${Debug}) /echo \atDEBUG CanIDoStuff Leave \agLine#: ${Macro.CurLine}
    /return
| -------------------------------------------------------------------------------------
| SUB: Mercs Do What
| -------------------------------------------------------------------------------------
    Sub MercsDoWhat
        /if (!${MercOn}) /return
        /if (${Group.Member[1].Owner.Name.Equal[${Me}]}) /varset MyMerc ${Group.Member[1].Name}
        /if (${Debug}) /echo \atDEBUG MercsDoWhat Enter \agLine#: ${Macro.CurLine}
        /if (${Mercenary.State.Equal[Active]}) /varset MercInGroup 1
        | Revive the merc if dead and previously detected in group
        /if (${MercInGroup} && ${Window[MMGW_ManageWnd].Child[MMGW_SuspendButton].Enabled} && ${Mercenary.State.Equal[DEAD]}) /notify MMGW_ManageWnd MMGW_SuspendButton LeftMouseUp
        /if (${MercAssistAt}>=${Spawn[${MyTargetID}].PctHPs} && ${Mercenary.State.Equal[Active]} && !${MercAssisting} && (${CombatStart} || ${Select[${Role},Puller]} && ${Pulled})) {
            /mercassist
            /if (${DebugCombat}) /echo \atDEBUGCOMBAT MercsDoWhat ${Spawn[${MyTargetID}].CleanName} %:${Spawn[${MyTargetID}].PctHPs} ID:${Spawn[${MyTargetID}].ID} \agLine#: ${Macro.CurLine}
            /varset MercAssisting 1
        }
        /if (${Debug}) /echo \atDEBUG MercsDoWhat Enter \agLine#: ${Macro.CurLine}
    /return
| -------------------------------------------------------------------------------------
| Sub Assign Main Assist
| -------------------------------------------------------------------------------------
    Sub AssignMainAssist    
        /if (${Debug}) /echo \atDEBUG AssignMainAssist Enter \agLine#: ${Macro.CurLine}
        /declare i int local    
        /varset MainAssist ${Target.CleanName}
        /varset MainAssistType ${Target.Type}
        /varset MainAssistClass ${Target.Class.ShortName}
        /if (${Debug}) /echo \atDEBUG AssignMainAssist Leave \agLine#: ${Macro.CurLine}
    /return
| -------------------------------------------------------------------------------------
| Sub Check Roles
| -------------------------------------------------------------------------------------
    Sub CheckRoles(int specialK)
        /if (${Debug}) /echo \atDEBUG CheckRoles Enter \agLine#: ${Macro.CurLine}
        /if (${Select[${Role},assist,offtank]}) {
            /if (${Debug}) /echo \atDEBUG Looks like I am ${Role}ing. \agLine#: ${Macro.CurLine}
            /if (${UseMQ2Melee}) {
                /squelch /melee aggro=0
                /stick mod 0
            } else {
                /if (${MeleeOn} || ${DPSOn}) {
                    /if (${DStickHow.Equal[auto]}) {
                        /varset StickHow snaproll
                        /stick mod 0
                    } else {
                        /varset StickHow ${DStickHow}
                        /stick mod 0
                    }
                } else {
                    /varset StickHow 0
                }
            }
        } else /if (${Role.Equal[tank]}) {
            /if (${Debug}) /echo \atDEBUG Looks like I am Main Tank. Wish me luck. \agLine#: ${Macro.CurLine}
            /varset MainAssist ${Me}
            /varset AssistAt 100
            /if (${UseMQ2Melee}) {
                /squelch /melee aggro=1
            } else {
                /if (${DStickHow.Equal[auto]}) {
                    /varset StickHow snaproll front moveback
                    /stick mod -2
                } else {
                    /varset StickHow ${DStickHow}
                    /stick mod -2
                }
            }
        } else /if (${Role.Equal[puller]}) {
            /if (${DebugPull}) /echo \atDEBUGPULL role puller \agLine#: ${Macro.CurLine}
            /if (${DebugPull}) /echo \atDEBUGPULL Looks like I am Puller. \agLine#: ${Macro.CurLine}
            /if (${UseMQ2Melee}) {
                /squelch /melee aggro=0
            } else {
                /if (${DStickHow.Equal[auto]}) {
                    /varset StickHow snaproll
                    /stick mod 0
                } else {
                    /varset StickHow ${DStickHow}
                    /stick mod 0
                }
            }
            /varset ReturnToCamp 1
            /varset ChaseAssist 0
            /varcalc CampRadiusExceed ${MaxRadius}+200
            /if (${Pet.ID} && ${Me.Pet.Distance}<=${CampRadius}) /pet guard
            /if (${Pet.ID} && ${Me.Pet.Distance}>${CampRadius}) /pet follow        
        } else /if (${Role.Equal[pullertank]}) {
            /if (${DebugPull}) /echo \atDEBUGPULL role pullertank \agLine#: ${Macro.CurLine}
            /if (${DebugPull}) /echo \atDEBUGPULL Looks like I am Puller and Tank. \agLine#: ${Macro.CurLine}
            /varset MainAssist ${Me}
            /if (${UseMQ2Melee}) /squelch /melee aggro=1
            /varset AssistAt 100
            /if (${DStickHow.Equal[auto]}) {
                /varset StickHow snaproll front moveback
                /stick mod -2
            }
            /varset ReturnToCamp 1
            /varset ChaseAssist 0
            /varcalc CampRadiusExceed ${MaxRadius}+200
            /if (${Pet.ID} && ${Me.Pet.Distance}<=${CampRadius}) /pet guard
            /if (${Pet.ID} && ${Me.Pet.Distance}>${CampRadius}) /pet follow            
        } else /if (${Select[${Role},hunter]}) {
            /if (${DebugPull})  /echo \atDEBUGPULL role hunter \agLine#: ${Macro.CurLine}
            /if (${DebugPull})  /echo \atDEBUGPULL Looks like I am Hunting. \agLine#: ${Macro.CurLine}
            /varset MainAssist ${Me}
            /if (${UseMQ2Melee}) /squelch /melee aggro=1
            /varset AssistAt 100
            /if (${StickHow.Equal[auto]}) {
                /varset StickHow moveback
                /stick mod -2
            }
            /varcalc CampRadiusExceed ${MaxRadius}+200
            /varset ReturnToCamp 0
            /if (${Pet.ID}) /pet follow
        } else /if (${Role.Equal[hunterpettank]}) {
            /if (${DebugPull}) /echo \atDEBUGPULL role hunterpettank \agLine#: ${Macro.CurLine}
            /if (${DebugPull}) /echo \atDEBUGPULL Looks like I am Hunting and my pet is tanking. \agLine#: ${Macro.CurLine}
            /varset MainAssist ${Me}
            /if (${UseMQ2Melee}) /squelch /melee aggro=0
            /varset AssistAt 100
            /varset PetTanking 1
            /varset PetAttackRange ${PetAttackDistance}            
            /varset ReturnToCamp 0
            /varset ChaseAssist 0
            /varset MountOn 0
            /if (${Pet.ID}) /pet follow
        } else /if (${Select[${Role},petassist]}) {
            /if (${DebugPull}) /echo \atDEBUGPULL role petassist \agLine#: ${Macro.CurLine}
            /if (${DebugPull}) /echo \atDEBUGPULL Looks like I am assisting a pet. \agLine#: ${Macro.CurLine}
            /if (${UseMQ2Melee}) /squelch /melee aggro=0
            /varset MeleeOn 0
        } else /if (${Select[${Role},pettank]}) {
            /if (${DebugPull}) /echo \atDEBUGPULL role pettank \agLine#: ${Macro.CurLine}
            /if (${DebugPull}) /echo \atDEBUGPULL Looks like my pet is tanking. \agLine#: ${Macro.CurLine}   
            /if (${UseMQ2Melee}) /squelch /melee aggro=0
            /varset MainAssist ${Me}
            /varset AssistAt 100
            /varset PetTanking 1
            /varset PetAttackRange ${PetAttackDistance}
            /varset MountOn 0
            /varcalc CampRadiusExceed ${MaxRadius}+200
            /while (${Me.Pet.ID} && !${PetTauntOn}) {
                /if (${DebugFramework}) /Echo Current Line ${Macro.CurLine}
				/pet taunt on
                /delay 10
                /doevents PTaunt
            }
            /if (${Math.Distance[${Me.Pet.Y},${Me.Pet.X}:${CampYLoc},${CampXLoc}]}<=${CampRadius}) /pet guard
            /if (${Math.Distance[${Me.Pet.Y},${Me.Pet.X}:${CampYLoc},${CampXLoc}]}>${CampRadius}) /pet follow            
            |- Function to determine pet active state and suspended pet state if enabled.
            /if (${PetSuspend} && ${specialK}) /call PetStateCheck                        
        } else /if (${Select[${Role},pullerpettank]}) {
            /if (${DebugPull}) /echo \atDEBUGPULL role pullerpettank \agLine#: ${Macro.CurLine}
            /if (${DebugPull}) /echo \atDEBUGPULL Looks like I am pulling and my pet is tanking. \agLine#: ${Macro.CurLine}
            /if (${UseMQ2Melee}) /squelch /melee aggro=0
            /varset MainAssist ${Me}
            /varset AssistAt 100
            /varset MeleeOn 0
            /varset PetTanking 1
            /varset PetAttackRange ${PetAttackDistance}
            /varset ReturnToCamp 1
            /varset ChaseAssist 0
            /varset MountOn 0
            /varcalc CampRadiusExceed ${MaxRadius}+200
            /while (${Me.Pet.ID} && !${PetTauntOn}) {
                /if (${DebugFramework}) /Echo Current Line ${Macro.CurLine}
				/pet taunt on
                /delay 10
                /doevents PTaunt
            }
            /if (${Math.Distance[${Me.Pet.Y},${Me.Pet.X}:${CampYLoc},${CampXLoc}]}<=${CampRadius}) /pet guard
            /if (${Math.Distance[${Me.Pet.Y},${Me.Pet.X}:${CampYLoc},${CampXLoc}]}>${CampRadius}) /pet follow
            /if (${PullRoleToggle} && ${Group.Leader.ID}!=${Me.ID}) {
                /echo You are set to toggle puller mode but are NOT the group leader.
                /echo Please correct this and restart KissAssist. 
                /endmacro
            }
            |- Function to determine pet active state and suspended pet state if enabled.
            /if (${PetSuspend} && ${specialK}) /call PetStateCheck           
        } else /if (${Role.Equal[manual]}) {
            /if (${UseMQ2Melee}) /squelch /melee aggro=0
            /varset MeleeOn 0
            /varset ReturnToCamp 0
            /varset ChaseAssist 0
            /varset DPSOn 0
            /varset BuffsOn 0
            /varset DebuffAllOn 0
            /if (${Defined[HealsOn]}) /varset HealsOn 0
            /if (${Defined[MezOn]}) /varset MezOn 0
        }
        /if (${StickHow.Equal[null]} || ${StickHow.Equal[auto]}) /varset StickHow 0
        /if (${Select[${Role},puller,pullerpet]}==0 && ${ChainPull}) /varset ChainPull 0 
        /if (!${Role.Find[puller]} && !${Role.Find[hunter]}) /varset PullPause 0 
        /if (${Debug}) /echo \atDEBUG CheckRoles Leave \agLine#: ${Macro.CurLine}
    /return
| -------------------------------------------------------------------------------------
| SUB: PullRangeSet
| -------------------------------------------------------------------------------------
   Sub PullRangeSet
       /if (${DebugPull}) /echo \atDEBUGPULL PullRange Enter \agLine#: ${Macro.CurLine}
       /declare PullItemRange int local
        /if (${Select[${FindItem[=${PullWith.Arg[1,|]}].Type},Archery,Throwing,Throwingv1,Throwingv2,ammo]} && ${FindItemCount[=${PullWith.Arg[1,|]}]} && ${Redguides}) {
            /varset PullItem ${PullWith.Arg[1,|]}
            /varset PullItemRange ${FindItem[=${PullWith.Arg[1,|]}].Range}
            /if (!${PullItemRange}) /varset PullItemRange 50
            /if (${FindItem[=${PullWith.Arg[2,|]}].WornSlot[ammo]} && ${FindItemCount[=${PullWith.Arg[2,|]}]}) {
                /varset PullAmmo ${PullWith.Arg[2,|]}
                | If pullitem is a bow add arrow range to bow for total range
                /if (${FindItem[=${PullWith.Arg[1,|]}].Type.Equal[Archery]}) {
                    /varcalc PullItemRange ${PullItemRange}+${FindItem[=${PullWith.Arg[2,|]}].Range}
                }
                /call PullVars ${Math.Calc[${PullItemRange}*(${PullRadiusToUse}/100)]} Ranged ${PullItemRange}
            } else {
                /echo I can't find any ammo defaulting to Melee for PullWith
                /varset PullWith Melee
                /call PullVars 15 Melee 15
                /return
            }
        /if (${DebugPull}) /echo \atPullWith=(${PullWith}) PullItem=(${PullItem}) PullItemRange=(${PullItemRange}) PullItemCount=(${FindItemCount[=${PullWith.Arg[1,|]}]}) PullAmmo=(${PullAmmo})\agLine#: ${Macro.CurLine}
        }
        /if (${FindItemCount[=${PullWith}]} && !${PullWith.Arg[2,|].Length} && ${FindItemCount[=${PullWith.Arg[1,|]}]} && ${Redguides}) {
            /varset PullItemRange ${FindItem[=${PullWith}].Spell.Range}
            /call PullVars  ${Math.Calc[${PullItemRange}*.9]} "${PullWith}" ${PullItemRange}
            /return
        }
        /if (${DebugPull}) /echo \atDEBUGPULL PullRange PullWith: ${PullWith} - CA:${Me.CombatAbility[${PullWith}]}/SPELL:${Me.Book[${PullWith}]}/ AA: ${Me.AltAbility[${PullWith}]} \agLine#: ${Macro.CurLine}
        /if (${Me.CombatAbility[${PullWith}]} || ${Me.Book[${PullWith}]} || ${Me.AltAbility[${PullWith}]})  {
            /if (${Select[${Role},puller,pullertank,pullerpettank,hunterpettank]}) /call PullVars ${Math.Calc[${Spell[${Spell[${PullWith}].ID}].MyRange}/1.11]} "${PullWith}" ${Spell[${Spell["${PullWith}"].ID}].MyRange}
            /if (${Select[${Role},hunter]})  {
                /if (${DebugPull}) /echo ${Math.Calc[${Spell[${Spell[${PullWith}].ID}].MyRange}/2.75]} "${PullWith}" ${Spell[${Spell["${PullWith}"].ID}].MyRange} \agLine#: ${Macro.CurLine}
                /call PullVars ${Math.Calc[${Spell[${Spell[${PullWith}].ID}].MyRange}/2.75]} "${PullWith}" ${Spell[${Spell["${PullWith}"].ID}].MyRange}
            }
        }
        /if (${PullWith.Equal[Pet]}) {
            /if (${Role.Equal[hunterpettank]}) {
                /call PullVars ${Math.Calc[${PetAttackRange}*.80]} Pet ${Math.Calc[${PetAttackRange}*.80]}
            } else {
                /call PullVars 185 Pet 185
            }
        }
        /if (${PullWith.Equal[Melee]}) {
            /if (${PullPathWpCount} && ${PullMoveUse.Equal[advpath]}) {
                /beep
                /beep
                /beep
                /popup You can't pull with MQ2Advpath and Melee. Please change PullWith to a Spell/AA/Disc/Ranged Weapon.
                /if (${DebugPull}) /echo ${PullPathWpCount} && ${PullMoveUse.Equal[advpath]}
                /echo You can't pull with MQ2Advpath and Melee. Please change PullWith to a Spell/AA/Disc/Ranged Weapon.
                /endmac
            } else {
                /call PullVars 15 Melee 15
            }
        }
        /if (${DebugPull}) /echo \atDEBUGPULL PullRange Leave \agLine#: ${Macro.CurLine}
    /return
| -------------------------------------------------------------------------------------
| SUB: PullVars
| -------------------------------------------------------------------------------------
    Sub PullVars(int pRange, pType, int pRange2)
        /if (${DebugPull}) /echo \atDEBUGPULL PullVars Enter \agLine#: ${Macro.CurLine}
        /varset PullRange ${pRange}
        /varset PullWith ${pType}
        /if (${Bool[${Plugin[MQ2Map]}]}) /squelch /mapfilter CastRadius ${PullRange}
        /if (${PullPathWpCount} && ${PullMoveUse.Equal[advpath]}) /varcalc MaxRadius ${TempMaxRadius}+${PullRange}
        /if (${Bool[${Plugin[MQ2Map]}]}) /squelch /mapfilter SpellRadius ${MaxRadius}
        /if (${DebugPull}) /echo MaxRadius is now ${MaxRadius} \agLine#: ${Macro.CurLine}
        /if (${DebugPull}) /echo \atDEBUGPULL PullVars Leave \agLine#: ${Macro.CurLine}
    /return
| -----------------------------------------------------------------------------------------------------------
| SUB: FindMobToPull(int ReadyToPullFlag) (NEW VERSION) ReadyToPullFlag 1 - Find mob and pull  0 - Check to see if there is a mob
| -----------------------------------------------------------------------------------------------------------
    Sub FindMobToPull(int ReadyToPullFlag)
        /if ((${DMZ} && ${Me.InInstance}==FALSE) || (${ReadyToPullFlag} && !${Select[${Role},puller,pullertank,hunter,hunterpettank,pullerpettank]}) || (!${ReadyToPullFlag} && !${Role.Find[puller]}) || ${Pulled} || (${AggroTargetID}  && !${ChainPull}) || ${PullHold} || ${DPSPaused} || ${Me.Buff[Resurrection Sickness].ID} || ${Me.Buff[Revival Sickness].ID}) /return 0
        /call MobRadar ${MeleeDistance} FindMobToPull
        /if (${ChainPull} && (${MobCount}>1 || ${Me.XTarget[${XTSlot2}].ID})) /return 0
        /if (${ReadyToPullFlag}) {
            /if (${ChainPull}) {
                /if (${Target.ID}==${Me.ID}) {
                    /squelch /target clear
                    /delay 10
                }
                /if (${Me.XTarget[${XTSlot}].ID} && ((!${MyTargetID} && !${Target.ID}) || ${Target.PctHPs}>=${ChainPullHP} || (${MyTargetID} && ${Spawn[${MyTargetID}].PctHPs}>=${ChainPullHP}))) /return 0
                /if (${Math.Distance[${CampYLoc},${CampXLoc}:${Spawn[=${MainAssist}].Y},${Spawn[=${MainAssist}].X}]}>75) /return 0
            }
        }
        /if (${ReadyToPullFlag} && (!${Select[${Role},puller,pullertank,hunter,hunterpettank,pullerpettank]} || ${Me.Buff[Resurrection Sickness].ID} || ${Me.Buff[Revival Sickness].ID} || ${IAmDead})) /return 0
        /if (${ReadyToPullFlag} && ${PetRampPullWait} && !${Me.CombatState.Equal[COMBAT]} && ${Select[${Role},pullerpettank]} && ${Select[${Me.Class.ShortName},MAG,NEC,BST]}) /call CheckRampPets      
        /if (${DebugPull}) /echo \atDEBUGPULL FindMobToPull Enter ${ReadyToPullFlag} \agLine#: ${Macro.CurLine}
        /call PullRangeSet
        /doevents
        /declare NearestIgnore int local 0
        /declare j int local
        /declare k int local
        /declare MobsNearCamp int local
        /declare MobsToPullList int local
        /declare o int local
        /declare PullCount int local
        /declare PullMobDistance float local 0
        /varset Pulling 0
        /call GroupWatch
        /if (${PullHold}) /return 0
        /if (${ReadyToPullFlag}) {
            	/if (!${FailCounter}) /echo Looking for Close Range Mobs
        } else {
            /if (!${SpamTimer}) {
                /echo Checking for Close Range Mobs 
                /varset SpamTimer 50
            }   
        }
        | Clear alert list 1, add mobs to ignore alert list1, set timer to keep alert list manageable for pulling no alert 1
        /if (!${PullAlertTimer}) {
            | Add Ignore Mob list to alert list
            /call AlertAddToList 1 "${MobsToIgnore}" "${PullIgnore1}"
            /varset PullAlertTimer 5m
        }
        /varset k 1
        /while (${PullIgnore1.Arg[${k},|].Length} && ${PullIgnore1.Find[|]} && ${PullIgnore1.NotEqual[null]}) {
            /if (${DebugFramework}) /Echo Current Line ${Macro.CurLine}
			/if (${DebugPull}) /echo \atDEBUGPULL PullIgnore: ${PullIgnore1} Count: ${k} Arg: ${PullIgnore1.Arg[${k},|]}
            /if ((!${Spawn[id ${PullIgnore1.Arg[${k},|]}].ID} || ${Spawn[${PullIgnore1.Arg[${k},|]}].Type.Equal[Corpse]}) && ${PullIgnore1.Arg[${k},|].NotEqual[null]}) {
                /echo Removing from Alert List: ${k} ${PullIgnore1.Arg[${k},|]} ${Spawn[id ${PullIgnore1.Arg[${k},|]}].ID}
                /squelch /alert remove 1 id ${PullIgnore1.Arg[${k},|]}
                /varset PullIgnore1 ${PullIgnore1.Replace[|${PullIgnore1.Arg[${k},|]},]}
            } else {
                /varcalc k ${k}+1
            } 
        }
        | Add any mob NOT on MobsToPull list to the Ignore List
        /if (!${MobsToPull.Find[All for all]} && ${MobsToPull.NotEqual[All]}) {
            /declare MobToPullName string local
            /declare MobToPullIgnore int local 
            /declare MobsToIgnoreTemp string local ${MobsToIgnore}
            /varset MobsToPullList ${SpawnCount[npc loc ${CampXLoc} ${CampYLoc} radius ${MaxRadius} zradius ${MaxZRange} targetable]}
            /if (${MobsToPullList}) {
            /for o 1 to ${MobsToPullList}
                /varset MobToPullName  ${NearestSpawn[${o}, npc radius ${PullRange} zradius ${MaxZRange} targetable].CleanName}
                /varset MobToPullIgnore 1
                /for j 1 to 25
                    /if (${MobsToPull.Arg[${j},,].Find[${MobToPullName}]}) {
                        /varset MobToPullIgnore 0
                    }
                    /if (!${MobToPullIgnore}) /break
                /next j
                /if (${MobToPullIgnore}) {
                    /if (${MobsToIgnoreTemp.Find[null]}) {
                        /varset MobsToIgnoreTemp ${MobToPullName}
                    } else {
                        /varset MobsToIgnoreTemp ${MobsToIgnoreTemp},${MobToPullName}
                    } 
                }
            /next o
            /call AlertAddToList 1 "${MobsToIgnoreTemp}" "${PullIgnore1}"
            }            
        }
        | Advpath searches for mobs along the path using Pullwith radius not Maxradius
        | FindAdvPath Routine searches and returns first valid mob along path. 
        | Does not require additional code for searching.
        /if (${PullMoveUse.Equal[advpath]}) {
            /call FindMobAdvPath ${ReadyToPullFlag}
            /return ${Macro.Return}
        } 
        | Get the PullCount based on How you are pulling.
        /if (${PullMoveUse.Equal[nav]}) {
            /varset PullCount ${SpawnCount[npc loc ${CampXLoc} ${CampYLoc} radius ${MaxRadius} zradius ${MaxZRange} targetable noalert 1]}
            /varset MobsNearCamp ${SpawnCount[npc loc ${CampXLoc} ${CampYLoc} radius ${MeleeDistance} zradius ${MaxZRange} targetable noalert 1]}
        } else /if (${Select[${Role},hunter,hunterpettank]}) {
            /varset PullCount ${SpawnCount[npc radius ${MaxRadius} zradius ${MaxZRange} targetable noalert 1]}
            /varset MobsNearCamp ${SpawnCount[npc radius ${MeleeDistance} zradius ${MaxZRange} targetable noalert 1]}
        } else {
            /varset PullCount ${SpawnCount[npc los loc ${CampXLoc} ${CampYLoc} radius ${MaxRadius} zradius ${MaxZRange} targetable noalert 1]}
            /varset MobsNearCamp ${SpawnCount[npc los loc ${CampXLoc} ${CampYLoc} radius ${MeleeDistance} zradius ${MaxZRange} targetable noalert 1]}
        }
        /if (${DebugPull}) /echo \atDEBUGPULL FindMobToPull ReadyToPullFlag:${ReadyToPullFlag} Pullcount: ${PullCount} MobsNearCamp: ${MobsNearCamp} Pull How: ${PullMoveUse} \agLine#: ${Macro.CurLine}
        | Are we Chain Pulling and Last Mob Pulled still out of melee range? 
        /if (!${ReadyToPullFlag} && ${PullCount}>0 && ${Spawn[${LastMobPullID}].Distance}>=${MeleeDistance}) /return 0
        | We are chain Pulling so recalc PullCount based on PullCount - Mobs in MelleDistance.
        /if (!${ReadyToPullFlag}) /varcalc PullCount ${PullCount}-${MobsNearCamp}
        | If PullCount is NOT zero then lets find a valid mob to pull.
        /if (${PullCount}) {
           /if (!${ReadyToPullFlag} && ${MobsNearCamp}) {
                /varset NearestIgnore 2
            } else {
                /varset NearestIgnore 1
            }
            | Find a mob based on pull method.
            /if (${PullMoveUse.Equal[nav]} && ${Select[${Role},hunter1,hunterpettank]}==0) {
                /call FindMobNAV ${ReadyToPullFlag} ${NearestIgnore} ${PullCount}
             } else /if (${Select[${Role},hunter1,hunterpettank]} && ${Select[${PullMoveUse},nav]}>=1) {
                /call FindMobNAV ${ReadyToPullFlag} ${NearestIgnore} ${PullCount} hunter
            } else /if (${PullMoveUse.NotEqual[advpath]}) {
                /call FindMobLOS ${ReadyToPullFlag} ${NearestIgnore} ${PullCount}
            }
            /if (!${PullMob}) /varset ChainPullTemp 0
        } else {
           | There were no mobs to pull based on PullCount.
           /varset ChainPullTemp 0
           /varset PullMob 0
        }
        /if (${DebugPull}) /echo \atDEBUGPULL FindMobToPull: ReadyToPullFlag: ${ReadyToPullFlag} Name: ${Spawn[${PullMob}].CleanName} MobID: ${PullMob} PullCount: ${PullCount} \agLine#: ${Macro.CurLine}
        /if (${DebugPull}) /echo \atDEBUGPULL FindMobToPull: ReadyToPullFlag: ${ReadyToPullFlag} Leave \agLine#: ${Macro.CurLine}
    /return ${PullMob}
| -----------------------------------------------------------------------------------------------------------
| SUB: Find Mob Using Advanced Path.
| -----------------------------------------------------------------------------------------------------------
    Sub FindMobAdvPath(int PFlag)
        /declare i int local
        /declare k int local
        /declare l int local
        /declare PullMobName string local 0
        /declare PullMobDistance float local 0
        /declare PullMobValid int local 0
        /declare DistanceCheck int local
        /declare WPMobCount int local
        | Advpath searches for mobs along the path using Pullwith radius not Maxradius
        /if (${DebugPull}) /echo \atDEBUGPULL FindMobAvdPath Enter ${PFlag} \agLine#: ${Macro.CurLine}
            /if (${Target.ID}) /squelch /target clear
            /varset PullMobValid 0 
            | loop through pathwaypoints and check for mobs
            /for k 1 to ${PullPathWpCount}
                /varset WPMobCount 0
                /varset PullMob 0
                /if (${UseWayPointZ}) {
                    /varset WPMobCount ${SpawnCount[npc loc ${PullPathArrayX[${k}]} ${PullPathArrayY[${k}]} ${PullPathArrayZ[${k}]} radius ${PullRange} zradius ${MaxZRange} targetable noalert 1]}
                } else {
                    /varset WPMobCount ${SpawnCount[npc loc ${PullPathArrayX[${k}]} ${PullPathArrayY[${k}]} radius ${PullRange} zradius ${MaxZRange} targetable noalert 1]}
                }
                /if (${WPMobCount}) {
                    /varset i 0
                    /for l 1 to ${WPMobCount}
                        /if (${UseWayPointZ}) {
                            /varset PullMob ${NearestSpawn[${l}, npc loc ${PullPathArrayX[${k}]} ${PullPathArrayY[${k}]} ${PullPathArrayZ[${k}]} radius ${PullRange} zradius ${MaxZRange} targetable noalert 1].ID}
                        } else {
                            /varset PullMob ${NearestSpawn[${l}, npc loc ${PullPathArrayX[${k}]} ${PullPathArrayY[${k}]} radius ${PullRange} zradius ${MaxZRange} targetable noalert 1].ID}
                        }
                        /if (${DebugPull}) /echo \atDEBUGPULL FindMobAdvPath 1: WP: ${k} MobID ${PullMob} LOS ${LineOfSight[${PullPathArrayY[${k}]},${PullPathArrayX[${k}]},${PullPathArrayZ[${k}]}:${Spawn[id ${PullMob}].Y},${Spawn[id ${PullMob}].X},${Spawn[id ${PullMob}].Z}]} YXZ ${PullPathArrayY[${k}]},${PullPathArrayX[${k}]},${PullPathArrayZ[${k}]}:${Spawn[id ${PullMob}].Y},${Spawn[id ${PullMob}].X},${Spawn[id ${PullMob}].Z} \agLine#: ${Macro.CurLine}
                        /if (${DebugPull}) /echo \atDEBUGPULL FindMobAdvPath 1.0: WP: ${k} MobID ${PullMob} UseWaypointZ: ${UseWayPointZ} WP Z: ${PullPathArrayZ[${k}]} Spawn Z: ${Spawn[id ${PullMob}].Z} Distance From Z: ${Math.Distance[${PullPathArrayZ[${k}]}:${Spawn[id ${PullMob}].Z}]} \agLine#: ${Macro.CurLine}
                        /if (${DebugPull}) /delay 1
                        /if (${PullMob} && ${LineOfSight[${PullPathArrayY[${k}]},${PullPathArrayX[${k}]},${PullPathArrayZ[${k}]}:${Spawn[id ${PullMob}].Y},${Spawn[id ${PullMob}].X},${Spawn[id ${PullMob}].Z}]}) {
                                /varset DistanceCheck ${Math.Distance[${PullPathArrayY[${k}]},${PullPathArrayX[${k}]},${PullPathArrayZ[${k}]}:${Spawn[id ${PullMob}].Y},${Spawn[id ${PullMob}].X},${Spawn[id ${PullMob}].Z}]}
                                /if (${k}<${PullPathWpCount}) {
                                    /varcalc i ${k}+1
                                    /while (${i}<=${PullPathWpCount} && ${DistanceCheck}>${Math.Distance[${PullPathArrayY[${i}]},${PullPathArrayX[${i}]},${PullPathArrayZ[${i}]}:${Spawn[id ${PullMob}].Y},${Spawn[id ${PullMob}].X},${Spawn[id ${PullMob}].Z}]}) {
                                        /if (${DebugFramework}) /Echo Current Line ${Macro.CurLine}
										/varset DistanceCheck ${Math.Distance[${PullPathArrayY[${i}]},${PullPathArrayX[${i}]},${PullPathArrayZ[${i}]}:${Spawn[id ${PullMob}].Y},${Spawn[id ${PullMob}].X},${Spawn[id ${PullMob}].Z}]}
                                        /varset k ${i}
                                        /varcalc i ${i}+1
                                    }
                                }
                            /if (${DebugPull}) /echo \atDEBUGPULL FindMobAdvPath: WP ${k} MobCount ${l} ${WPMobCount} \agLine#: ${Macro.CurLine}
                            /varset PullMobName ${Spawn[id ${PullMob}].CleanName}
                            /varset PullMobDistance ${Math.Distance[${Spawn[id ${PullMob}].Y},${Spawn[id ${PullMob}].X}:${PullPathArrayY[${k}]},${PullPathArrayX[${k}]}]}
                            /varcalc AdvpathPointNum ${k}
                            /varset AdvpathPointX ${PullPathArrayX[${k}]}
                            /varset AdvpathPointY ${PullPathArrayY[${k}]}
                            /varset AdvpathPointZ ${PullPathArrayZ[${k}]}
                            /if (${DebugPull}) /echo \atDEBUGPULL FindMobAdvPath 2: WP: ${k} Pullmob ${PullMob} Waypoint: ${AdvpathPointNum} XY: ${PullPathArrayX[${k}]} ${PullPathArrayY[${k}]} ${Math.Distance[${Spawn[id ${PullMob}].Y},${Spawn[id ${PullMob}].X}:${AdvpathPointY},${AdvpathPointX}]}<${PullRange} \agLine#: ${Macro.CurLine}
                            /if (${DebugPull}) /echo \atDEBUGPULL FindMobAdvPath 2: AdvPull: Pullmob: ${PullMobName} ID ${PullMob} Waypoint: ${PullPathWpCount} XY: ${PullPathArrayX[${k}]} ${PullPathArrayY[${k}]} \agLine#: ${Macro.CurLine}
                            /call PullValidate ${PullMob} ${PFlag}
                            /varset PullMobValid ${Macro.Return}
                            /if (${PullMobValid}) /return ${PullMob}
                        }
                    /next l
                }
            /next k
            /varset PullMob 0
            /if (${DebugPull}) /echo \atDEBUGPULL FindMobAdvPath: Mob Not Found. AdvPull: ReadyToPullFlag: ${PFlag} Role: ${Role} ID: ${PullMob} PullRange: ${PullRange} \agLine#: ${Macro.CurLine}
            /if (${DebugPull}) /echo \atDEBUGPULL FindMobAdvPath: ReadyToPullFlag: ${PFlag} Leave \agLine#: ${Macro.CurLine}
            | Check for mobs in max pull radius for normal,MQ2nav pulling
            /return 0
| -----------------------------------------------------------------------------------------------------------
| SUB: Find Mob Using Navigation.
| -----------------------------------------------------------------------------------------------------------
    Sub FindMobNAV(int PFlag, int BCount, int ECount, string PRole)
        /declare i int local
        /declare m int local
        /declare m2 int local 0
        /declare n int local
        /declare p int local
        /declare PathCount int local 0
        /declare PathArray[999] int local 0
        /declare PathDistance[999] float local 0
        /declare PullMobName string local 0
        /declare PullMobValid int local 0
        /declare SortDistTemp float local 0
        /declare SortIDTemp int local 0
        /if (${DebugPull}) /echo \atDEBUGPULL FindMobNAV Enter ${PFlag} \agLine#: ${Macro.CurLine}
                | Pull mob with shortest path by joojoobee
        /for p 1 to ${ECount}
                    /if (${PRole.Find[hunter]}) {
                        /varset PathArray[${p}] ${NearestSpawn[${p}, npc loc ${Me.X} ${Me.Y} radius ${MaxRadius} zradius ${MaxZRange} targetable noalert 1].ID}
                    } else {
                        /varset PathArray[${p}] ${NearestSpawn[${p}, npc loc ${CampXLoc} ${CampYLoc} radius ${MaxRadius} zradius ${MaxZRange} targetable noalert 1].ID}
                    }
                    /varset PullMob ${PathArray[${p}]}
                    /if (${Navigation.PathExists[id ${PullMob}]} && ${PRole.Find[hunter]}) {
                        /if (${Navigation.PathLength[id ${PullMob}]}>=${PullRange}) {
                            /varset PathDistance[${p}] 10000
                            /if (${DebugPull}) /echo hunter mob outside of pull range >>${Navigation.PathLength[id ${PullMob}]}<< skipping. \agLine#: ${Macro.CurLine}
                        }
                    }  else /if (${Navigation.PathExists[id ${PullMob}]}) {
                        /varset PathDistance[${p}] ${Navigation.PathLength[id ${PullMob}]} 
                        /if (${DebugPull}) /echo Succsesfully Added ${Navigation.PathExists[id ${PullMob}]} (dist :${PathDistance[${p}]}) to the pull array. \agLine#: ${Macro.CurLine}
                    } else {
                        /varset PathDistance[${p}] 100000
                    }
                /next p
		/if (${ECount}>1) {
            /for m 1 to ${ECount}
                        /varset PathCount ${m}
                /varcalc m2 ${m} + 1
                /for n ${m2} to ${ECount}
                            /if (${PathDistance[${n}]} < ${PathDistance[${PathCount}]}) /varset PathCount ${n}
                        /next n
                        /varset SortIDTemp ${PathArray[${m}]}
                        /varset SortDistTemp ${PathDistance[${m}]}
                        /varset PathArray[${m}] ${PathArray[${PathCount}]}
                        /varset PathArray[${PathCount}] ${SortIDTemp}
                        /varset PathDistance[${m}] ${PathDistance[${PathCount}]}
                        /varset PathDistance[${PathCount}] ${SortDistTemp}
                /if (${m2}==${ECount}) /break
                /if (${DebugPull}) /echo \atDEBUGPULL /echo \atDEBUGPULL FindMobNAV: PathNum: ${PathDistance[${m}]} PathDistance:${PathDistance[${PathCount}]} \agLine#: ${Macro.CurLine}
                    /next m
                }
        /for i ${BCount} to ${ECount}
            /if (${DebugPull}) /echo \atDEBUGPULL FindMobNAV 1.0:  ReadyToPullFlag: ${PFlag} Pullcount: ${ECount} \agLine#: ${Macro.CurLine}
                    /varset PullMob ${PathArray[${i}]}
                    /varset PullMobName ${Spawn[id ${PullMob}].CleanName}
            /if (${DebugPull}) /echo \atDEBUGPULL FindMobNAV: ReadyToPullFlag: ${PFlag} MQ2Nav: Name: ${PullMobName} ID: ${PullMob} \agLine#: ${Macro.CurLine}
            /varset PullMobValid 0
            /if (${PullMob}) {
                /call PullValidate ${PullMob} ${PFlag}
                /if (${DebugPull}) /echo \atDEBUGPULL FindMobNAV: ${i}.${PullMob} Macro.Return ${Macro.Return} \agLine#: ${Macro.CurLine}
                /if (${Macro.Return}) { 
                    /varset PullMobValid 1
                    /varset ChainPullTemp ${PullMob}
                }
            }
            /if (${PullMobValid}) /return ${PullMob}
        /next i
        /varset PullMob 0
        /if (${DebugPull}) /echo \atDEBUGPULL FindMobNAV: ReadyToPullFlag: ${PFlag} Leave \agLine#: ${Macro.CurLine}
    /return ${PullMob}
| -----------------------------------------------------------------------------------------------------------
| SUB: Find Mob in Hunter Mode.
| -----------------------------------------------------------------------------------------------------------
    Sub FindMobHunter(int PFlag, int BCount, int ECount) 
        /declare i int local
        /declare p int local
        /declare PullMobName string local 0
        /declare PullMobValid int local 0
        /if (${DebugPull}) /echo \atDEBUGPULL FindMobHunter Enter ${PFlag} \agLine#: ${Macro.CurLine}
        /for i ${BCount} to ${ECount}
            /if (${DebugPull}) /echo \atDEBUGPULL FindMobHunter 1.0:  ReadyToPullFlag: ${PFlag} Pullcount: ${ECount} \agLine#: ${Macro.CurLine}
                   /varset PullMob ${NearestSpawn[${i}, npc radius ${MaxRadius} zradius ${MaxZRange} targetable noalert 1].ID}
                   /varset PullMobName ${Spawn[id ${PullMob}].CleanName}
                /if (${DebugPull} && ${Select[${Role},hunter]}) /echo \atDEBUGPULL FindMobHunter: ReadyToPullFlag: ${PFlag} Role: ${Role} Name: ${PullMobName} ID: ${PullMob} \agLine#: ${Macro.CurLine}
                /varset PullMobValid 0
                /if (${PullMob}) {
                /call PullValidate ${PullMob} ${PFlag}
                /if (${DebugPull}) /echo \atDEBUGPULL FindMobHunter: ${i}.${PullMob} Macro.Return ${Macro.Return} \agLine#: ${Macro.CurLine}
                    /if (${Macro.Return}) { 
                        /varset PullMobValid 1
                        /varset ChainPullTemp ${PullMob}
                    }
                }
                /if (${PullMobValid}) /return ${PullMob}
            /next i
           /varset PullMob 0
        /if (${DebugPull}) /echo \atDEBUGPULL FindMobHunter: ReadyToPullFlag: ${PFlag} Leave \agLine#: ${Macro.CurLine}
    /return ${PullMob}
| -----------------------------------------------------------------------------------------------------------
| SUB: Find Mob Using LOS.
| -----------------------------------------------------------------------------------------------------------
    Sub FindMobLOS(int PFlag, int BCount, int ECount, PRole) 
        /declare i int local
        /declare p int local
        /declare PullMobName string local 0
        /declare PullMobValid int local 0
        /if (${DebugPull}) /echo \atDEBUGPULL FindMobLOS Enter ${PFlag} \agLine#: ${Macro.CurLine}
        /for i ${BCount} to ${ECount}
            /if (${DebugPull}) /echo \atDEBUGPULL FindMobLOS 1.0:  ReadyToPullFlag: ${PFlag} Pullcount: ${ECount} \agLine#: ${Macro.CurLine}
                   /varset PullMob ${NearestSpawn[${i}, npc los loc ${CampXLoc} ${CampYLoc} radius ${MaxRadius} zradius ${MaxZRange} targetable noalert 1].ID}
                   /if (${PullMob}) /varset PullMobName ${Spawn[id ${PullMob}].CleanName}
            /if (${DebugPull}) /echo \atDEBUGPULL FindMobLOS: ReadyToPullFlag: ${PFlag} Normal Name: ${PullMobName} ID: ${PullMob} LOS: ${LineOfSight[${CampYLoc},${CampXLoc},${CampZLoc}:${Spawn[id ${PullMob}].Y},${Spawn[id ${PullMob}].X},${Spawn[id ${PullMob}].Z}]} \agLine#: ${Macro.CurLine}
                /varset PullMobValid 0
                /if (${PullMob}) {
                /call PullValidate ${PullMob} ${PFlag}
                /if (${DebugPull}) /echo \atDEBUGPULL FindMobLOS: ${i}.${PullMob} Macro.Return ${Macro.Return} \agLine#: ${Macro.CurLine}
                    /if (${Macro.Return}) { 
                        /varset PullMobValid 1
                        /varset ChainPullTemp ${PullMob}
                    }
                }
                /if (${PullMobValid}) /return ${PullMob}
            /next i
            /varset PullMob 0
        /if (${DebugPull}) /echo \atDEBUGPULL FindMobLOS: ReadyToPullFlag: ${PFlag} Leave \agLine#: ${Macro.CurLine}
    /return ${PullMob}
| -----------------------------------------------------------------------------------------------------------
| SUB: PullCheck PullMob is Mob ID of mob to pull.
| -----------------------------------------------------------------------------------------------------------
    Sub PullCheck
        /if (${DebugPull}) /echo \atDEBUGPULL PullCheck Enter ${PullMob} \agLine#: ${Macro.CurLine}
        /if (${DebugPull}) /echo \atDEBUGPULL PullCheck: 1.0: Name: ${Spawn[${PullMob}].CleanName} MobID: ${PullMob} ${PullMoveUse} \agLine#: ${Macro.CurLine}
        /if (${PullHold} || ${DPSPaused} || ${Me.Buff[Resurrection Sickness].ID} || ${Me.Buff[Revival Sickness].ID} || ${CampZone}!=${Zone.ID}) /return 0
        /if (${ChainPull}==2) /varset ChainPull 1
        /if (${PullMob} && ${Select[${PullMoveUse},los,nav]}>=1 && (${Spawn[${PullMob}].Distance3D}<=360 || ${Spawn[${PullMob}].LineOfSight})) {
            /target id ${PullMob}
            /delay 20 ${Target.ID}==${PullMob}
        }
        /if (${PullMob} && ${Spawn[${PullMob}].ID}) {
            /varset Pulling 1
            | Advpath skill validate mob
            /if (${PullMob} && ${PullMoveUse.Equal[advpath]}) {
                /varset MyTargetID ${PullMob}
                /varset MyTargetName ${Spawn[${PullMob}].CleanName}
                /target id ${PullMob}
                /delay 20 ${Target.ID}==${PullMob}
                | Is mob really in range. check for spawn lag
                /if (${Math.Distance[${Spawn[id ${PullMob}].Y},${Spawn[id ${PullMob}].X}:${AdvpathPointY},${AdvpathPointX}]}>${PullRange}) {
                    /if (${PullMob}) /alert add 1 id ${PullMob}
                    /echo Mob is OOR after targeting. Trying Again. ${PullMob} ${Math.Distance[${Spawn[id ${PullMob}].Y},${Spawn[id ${PullMob}].X}:${AdvpathPointY},${AdvpathPointX}]} ${PullRange} - ${AdvpathPointY} ${AdvpathPointX}
                    /squelch /target clear
                    /varset Pulling 0
                    /return 0
                }
                /call ValidateTarget
            } else /if (${Target.ID} && ${Target.ID}==${PullMob}) {
                /call ValidateTarget
            } else {
               /if (${PullMob} && ${Spawn[${PullMob}].ID}) /call ValidateTarget ${PullMob}
            }
            /if (${DebugPull}) /echo \atDEBUGPULL PullCheck: Target: ${Spawn[${PullMob}].CleanName} Valid: ${ValidTarget} MacReturn ${Macro.Return} \agLine#: ${Macro.CurLine}
            /if (${ValidTarget}==0 || (${Target.ID} && ${Select[${PullMoveUse},los,nav]}>=1 && ${Math.Distance[${Target.Y},${Target.X}:${CampYLoc},${CampXLoc}]}>${MaxRadius})) {
                /if (${PullMob}) /squelch /alert add 1 id ${PullMob}
                /squelch /target clear
                /varset Pulling 0
                /return 0
            }
            /call BroadCast ${EQBCOn} t "PULLING-> ${Spawn[${PullMob}].CleanName} <- ID:${PullMob} at ${Int[${Math.Distance[${Spawn[${PullMob}].Y},${Spawn[${PullMob}].X}:${CampYLoc},${CampXLoc}]}]} feet."
            /varset MyTargetID ${PullMob}
            /varset MyTargetName ${Spawn[${PullMob}].CleanName}
            /if (${Pulling} && ${MyTargetID}) {
                /if (${PullWith.Equal[Pet]} && (${Me.Pet.Stance.NotEqual[FOLLOW]})) /pet follow  
                /if (${Target.ID} && ${Target.ID}!=${PullMob}) {
                   /if (${Me.Combat}) /attack off
                   /squelch /target clear
                }
                /call Pull
                /if (${PullPause.NotEqual[0]}) /varset PullWaitTimer2 ${Math.Calc[${PullPause.Arg[2,"|"]}+1]}m
                /return 0
            }
        } else /if (!${PullMob}) {
            /varcalc FailCounter ${FailCounter}+1
            /if (${DebugPull}) /echo \atDEBUGPULL PullCheck: No Valid Target in Range ${MaxRadius} - ${FailCounter} Time(s) \agLine#: ${Macro.CurLine}
            /if (${FailCounter}>=${FailMax}) {
                /call AlertClearList 1 PullCheck
                /varset FailCounter 0
                /varset PullAlertTimer 0
                /if (${PullWait}) {
                    /call BroadCast ${EQBCOn} t "PULLING-> Waiting ${PullWait} seconds for mobs to respawn."
                    /call PullDelay ${PullWait}
                }
                /if (${Select[${Role},hunter,hunterpettank]} && ${Math.Distance[${CampYLoc},${CampXLoc}]} > 15) {
                    /if (${DebugPull}) /echo \atDEBUGPULL PullCheck Returning hunter to camp \agLine#: ${Macro.CurLine}
                    /varset ReturnToCamp 1
                    /echo ${Role}: There are no mobs within ${MaxRadius} trying to return to camp.
                    /call DoWeMove 0 pullcheck
                }    
                /return 0
            }
        }
        /if (${DebugPull}) /echo \atDEBUGPULL PullCheck:  Leave \agLine#: ${Macro.CurLine}
    /return 0    
| -------------------------------------------------------------------------------------
| SUB: PullDelay
| -------------------------------------------------------------------------------------
    Sub PullDelay(int TimerAmount)
        /if (${DebugPull}) /echo PullDelay ${TimerAmount} Enter \agLine#: ${Macro.CurLine}
        /declare PDTimer timer local ${TimerAmount}s
        /varset Pulling 0
        /if (${MedOn} && !${Me.Mount.ID} && ${Me.Standing} && !${Me.Moving}) /sit 
        /while (${PDTimer} && !${AggroTargetID}) {
            /if (${DebugFramework}) /Echo Current Line ${Macro.CurLine}
			/doevents
            /delay 2
        }
		|CheckForCombat
		/if (${Me.XTarget[1].ID} && ${SpawnCount[npc radius ${MeleeDistance} zradius 15 targetable playerstate 4]}) /return
        /if (${DebugPull}) /echo PullDelay Leave \agLine#: ${Macro.CurLine}
    /return
| ----------------------------------------------------------------------------
| SUB: PullValidate
| ----------------------------------------------------------------------------
    Sub PullValidate(PVPullMob, int PFlag)
        /declare j int local
        /declare skipFlag int local 0
        /if (!${MobsToPull.Find[All for all]} && ${MobsToPull.NotEqual[All]}) {
            /for j 1 to 25
                /if (${DebugPull} && ${MobsToPull.Arg[${j},,].Length}) /echo \atDEBUGPULL PullValidate: PFlag: ${PFlag} ${j} PullList ${Spawn[id ${PVPullMob}].CleanName}/${MobsToPull.Arg[${j},,]} ${Spawn[id ${PVPullMob}].CleanName.Equal[${MobsToPull.Arg[${j},,]}]} \agLine#: ${Macro.CurLine}
                /if (${Spawn[id ${PVPullMob}].CleanName.Equal[${MobsToPull.Arg[${j},,]}]}) {
                    /varset skipFlag 1
                    /break
                }
            /next j
            /if (!${skipFlag}) {
                /if (${DebugPull}) /echo \atDEBUGPULL PullValidate ${Spawn[id ${PVPullMob}].CleanName} NOT on MobsToPull List \agLine#: ${Macro.CurLine}
                /return 0
            }
        }
        | If mob found on ignore list
        /if (${MobsToIgnore.Find[${Spawn[${PVPullMob}].CleanName}]}) /return 0
        /if (${MobsToIgnoreByID.Find[${PVPullMob}|]}) /return 0
        
        /if (${DebugPull}) /echo \atDEBUGPULL PullValidate Pulling: ${Spawn[id ${PVPullMob}].CleanName} \agLine#: ${Macro.CurLine}
        | Check spawn for out of range - macro start point as epicEnter
        /if (${Select[${PullMoveUse},los,nav]}>=1 && ${Math.Distance[${Spawn[id ${PVPullMob}].Y},${Spawn[${PVPullMob}].X}:${CampYLoc},${CampXLoc}]}>${MaxRadius}) {
            /if (${DebugPull}) /echo \atDEBUGPULL PullValidate: PFlag: ${PFlag} ${Spawn[${PVPullMob}].CleanName} invalid target Reason: Out of Range \agLine#: ${Macro.CurLine}
            /return 0
        }
        | Check spawn path exists mq2nav
        /if (${PullMoveUse.Equal[nav]}) {
            /if (!${Navigation.PathExists[id ${Spawn[${PVPullMob}].ID}]}) {
                /if (${DebugPull}) /echo \atDEBUGPULL PullValidate: PFlag: ${PFlag} MQ2Nav path does not exist. \agLine#: ${Macro.CurLine}
                /return 0
            }
        }
        | Check spawn for eye of zomm/tallon ${SpawnCount[pc ${PVPullMob.Right[${Math.Calc[${PVPullMob.Length}-7]}]}]}
        /if (${Spawn[${PVPullMob}].CleanName.Find[Eye of]} && ${SpawnCount[pc ${Spawn[${PVPullMob}].CleanName.Right[${Math.Calc[${Spawn[${PVPullMob}].CleanName.Length}-7]}]}]}) {
            /if (${DebugPull}) /echo \atDEBUGPULL PullValidate: PFlag: ${PFlag} ${Spawn[${PVPullMob}].CleanName} invalid target Reason: Eye of Zomm/Tallon \agLine#: ${Macro.CurLine}
                /return 0
        }
        | Check spawn for line of sight - no mq2nav
        /if (${Select[${Role},puller,pullertank,pullerpettank]} && !${Spawn[${PVPullMob}].LineOfSight} && ${PullMoveUse.Equal[los]}) {
            /if (${DebugPull}) /echo \atDEBUGPULL PullValidate: PFlag: ${PFlag} ${Spawn[${PVPullMob}].CleanName} invalid target Reason: No line of sight \agLine#: ${Macro.CurLine}
                /return 0
        }
        | Check spawn for Level Range
        /if (${Spawn[${PVPullMob}].Level}<${PullMin} || ${Spawn[${PVPullMob}].Level}>${PullMax}) {
            /if (${DebugPull}) /echo \atDEBUGPULL PullValidate: PFlag: ${PFlag} ${Spawn[${PVPullMob}].Level} invalid target Reason: Invalid NPC Level \agLine#: ${Macro.CurLine}
            /return 0
        }
        | Check if any PC/toon is near the mob
        /if (${SpawnCount[loc ${Spawn[${PVPullMob}].X} ${Spawn[${PVPullMob}].Y} radius 15 pc]}>=1 && ${Pulling} && ${Math.Distance[${Spawn[${PVPullMob}].Y},${Spawn[${PVPullMob}].X}:${Me.Y},${Me.X}]}>=16) {
            /if (${DebugPull}) /echo \atDEBUGPULL PullValidate: PFlag: ${PFlag} ${Spawn[${PVPullMob}].CleanName} invalid target Reason: PCs near mob \agLine#: ${Macro.CurLine} \agLine#: ${Macro.CurLine}
                /return 0
        }
        /if (${PullArcWidth}>0) {
            /call FigureMobAngle ${Int[${PVPullMob}]} 
            /if (${Macro.Return.Equal[0]}) {
                /if (${DebugPull}) /echo \atDEBUGPULL PullValidate: PFlag: ${PFlag} ${Spawn[${PVPullMob}].CleanName} ${PullLSide} ${Spawn[id ${PVPullMob}].HeadingTo[${CampYLoc},${CampXLoc}].Degrees} ${PullRSide} invalid target Reason: Mob not in Pull Area \agLine#: ${Macro.CurLine}
                /return 0
            }
        }
        | Check spawn for 100% health
        /if (${Spawn[${PVPullMob}].PctHPs}<=99 && ${Spawn[${PVPullMob}].Distance}>=${MeleeDistance}) {
            /if (${DebugPull}) /echo \atDEBUGPULL PullValidate: PFlag: ${PFlag} ${Spawn[${PVPullMob}].CleanName} invalid target Reason: Mob not 100% health \agLine#: ${Macro.CurLine} \agLine#: ${Macro.CurLine}
            | If chain pulling then target mob to update server.
            /if (${PFlag} && ${Spawn[${PVPullMob}].Distance}<=360 && ${Target.ID}!=${PVPullMob}) {
                /Echo Mob not at 100% HPs Double checking for server lag PFlag: ${PFlag} PVPullMob: ${PVPullMob} - ${Spawn[${PVPullMob}].CleanName} MobCount: ${MobCount} 
                /target id ${Spawn[${PVPullMob}].ID} 
                /delay 20 ${Target.ID}==${PVPullMob} && ${Target.BuffsPopulated}==TRUE
                /if (${Target.PctHPs}>99) {
                    /return 1
                } else {
                    /squelch /alert add 1 id ${PVPullMob}
                }
            }
            /return 0                
        }
        /if (${Spawn[${PVPullMob}].Named} && ((${PFlag} && ${MobCount} && ${Me.XTarget[${XTSlot}].ID}) || !${PFlag})) {
            /if (${DebugPull}) /echo \atDEBUGPULL PullValidate: PFlag: ${PFlag} ${Spawn[${PVPullMob}].CleanName} invalid target Reason: No Pull Names with Mobs in Camp \agLine#: ${Macro.CurLine}
            /return 0
        }
    /return 1    
|-------------------------------------------------------------------------------- 
|SUB: CheckRampPets - Writtten by Trehuggindruid for KissAssist
|-------------------------------------------------------------------------------- 
    Sub CheckRampPets
        /declare i int local
        /declare DoLoop int local 1
        /if (!${Me.CombatState.Equal[COMBAT]}) {
            | Wait for rampage pets to poof before pulling.
            /for i 0 to 20
                /if (${Spawn[${Me.CleanName}`s_pet0${i}].ID}) /echo +++ My rampage pet is up: (${Spawn[${Me.CleanName}`s_pet0${i}]}|${Spawn[${Me.CleanName}`s_pet0${i}].ID}), HOLDING . . .
                /while (${DoLoop}) {
                    /if (${DebugFramework}) /Echo Current Line ${Macro.CurLine}
					/delay 1
                    /if (!${Me.CombatState.Equal[COMBAT]} && ${Spawn[${Me.CleanName}`s_pet0${i}].ID}) /continue
                    /varset DoLoop 0
                }
            /next i
        }
    /return    
| -------------------------------------------------------------------------------------
| SUB: Pull
| -------------------------------------------------------------------------------------
    Sub Pull
        /if (${DMZ} && ${Me.InInstance}==FALSE) /return
        /if (${Select[${Role},puller,pullertank,hunter,hunterpettank,pullerpettank]}==0) /return
        /if (!${Pulling}) /return
        /if (${DPSPaused}) /return
        /if (${DebugPull}) /echo \atDEBUGPULL Pull Enter \agLine#: ${Macro.CurLine}
        /declare PullAttempts int local 0 
        /declare StuckCount int local 0 
        /declare PullDist float local ${PullRange}
        /declare WasTwistingPull bool local ${Twist}
        /declare AdvpathPaused int local 0
        /declare WPCurrent int local 0
        /declare AdvpathDirection string local
        /declare AutoFireOff int local ${AutoFireOn}
        /declare X1 int local
        /declare Y1 int local
        /declare X2 int local
        /declare Y2 int local
        /declare AdjustHeadingTimer timer local 0
        /declare WasInRange int local 0
        /varset Pulled 0
        /varset PullTooFar 0
        /varset PullTimer 50
        /varset CantHit 0
        /varset ToClose 0
        /if (${GroupWatchOn}) /call GroupWatch
        /if (${DebugPull}) /echo \atDEBUGPULL Pull: PullWith:${PullWith} PullDist: ${PullDist} \agLine#: ${Macro.CurLine}
        | Set autofire setting off during pulls if not using ranged item to pull
        /if (${AutoFireOff}) /varset AutoFireOn 0
        /if (${IAmABard} && !${PullTwistOn} && ${WasTwistingPull}) { 
            /while (${Me.BardSongPlaying}) {
                /if (${DebugFramework}) /Echo Current Line ${Macro.CurLine}
				/if (${Twist}) /squelch /twist off
                /stopsong
                /delay 5
            }
        }
        /if (!${Me.Mount.ID} && ${Me.Sitting}) /stand        
        /if (${Select[${Role},pullerpettank]} && ${PullRoleToggle} && ${Group.Puller.ID}!=${Me.ID}) {
            /if (${Math.Distance[${Spawn[${MyTargetID}].Y},${Spawn[${MyTargetID}].X},${Spawn[${MyTargetID}].Z}:${CampYLoc},${CampXLoc},${CampZLoc}]}>${CampRadius}) /call PullModeToggle TurnOn
        }
        /varset BeginMobID ${Me.XTarget[${XTSlot}].ID}
       :PullAgain
        /doevents 
        /if (!${DragCorpse} && ${SpawnCount[pccorpse ${Me} radius ${MaxRadius}]}) {
            /call GrabCorpse
            /if (${DragCorpse}) {
                /goto :DonePulling
            }
        }
        /if (${DPSPaused}) /return  
        | vars used to determine if we are stuck
            /varset X1 ${Int[${Me.X}]}
            /varset Y1 ${Int[${Me.Y}]}            
            /if (${PullAggroTargetID}) {
                /if (${DebugPull}) /echo Pulling 1.1 \agLine#: ${Macro.CurLine}
                /varset Pulled 1
                /varset MyTargetID ${AggroTargetID}
                /varset MyTargetName ${Spawn[${AggroTargetID}].CleanName}
                /call StopMoving
                /if (${DebugPull}) /echo \atDEBUGPULL Pull Aggro detected \agLine#: ${Macro.CurLine}
                /goto :DonePulling
            }
            | Exit pull and reset if timed out or wandered too far from camp
            /if (${DebugPull}) /echo Pulling 1.2 PullTimer: ${PullTimer} Distance: ${Math.Distance[${CampYLoc},${CampXLoc}]} Distance3D: ${Math.Distance[${CampYLoc},${CampXLoc},${CampZLoc}]} MaxRadius: ${Math.Calc[${MaxRadius}*.90]} PullAttempts: ${PullAttempts} MyTargetID: ${Spawn[${MyTargetID}].ID}  Target LOS: ${Spawn[${MyTargetID}].LineOfSight} \agLine#: ${Macro.CurLine}
            /if (${PullTimer}==0 || (${Math.Distance[${CampYLoc},${CampXLoc},${CampZLoc}]} >= ${Math.Calc[${MaxRadius}*.90]}) || (${PullAttempts}>=7 && !${Spawn[${MyTargetID}].LineOfSight} && !${Select[${Role},hunter,hunterpettank]}) || !${Spawn[${MyTargetID}].ID} || ${PullAttempts}>=100) {
                /if (${MyTargetID}) /squelch /alert add 1 id ${MyTargetID}
                /if (${DebugPull}) /echo \atDEBUGPULL Pull: /echo Adding ${Spawn[${MyTargetID}].CleanName} ID: ${MyTargetID} to temp ignore list \agLine#: ${Macro.CurLine}
                /if (${DebugPull}) /echo \atDEBUGPULL Pull: Done Pulling-Timer expired, Mob unreachable or exceeded max pull radius. \agLine#: ${Macro.CurLine}
                /call BackToCampReset
                /if (${Macro.Return}) /return
            }
            /if (((${AggroTargetID} && !${ChainPull}) || (${Me.XTarget[${XTSlot2}].ID} && ${ChainPull})) && ${Math.Distance[${CampYLoc},${CampXLoc}]} < ${CampRadius}) {
                /echo Looks like mobs in camp aborting pull.
                /call PullReset
				/if (${Me.XTarget[1].ID} && ${SpawnCount[npc radius ${MeleeDistance} zradius 15 targetable playerstate 4]}) /return
                /if (${DebugPull}) /echo \atDEBUGPULL Pull Mobs in camp detected \agLine#: ${Macro.CurLine}
                /return
            }
            /if (${PullWith.Equal[Ranged]}) {
                /call PullWithRanged ${PullDist} 0
            }
            | - Filter to prevent pulling until AA/Disc/Spell/Item is ready.
            /if (${DebugPull}) /echo \atDEBUGPULL Check Ability: ${AggroTargetID} ${PullAggroTargetID} ${ChainPull} ${Select[${PullWith},Melee,Pet,Ranged]} ${Me.SpellReady[${PullWith}]} ${Me.AltAbilityReady[${PullWith}]} ${Me.CombatAbilityReady[${PullWith}]} ${Me.ItemReady[${PullWith}]} ${PullWith} ${PullWith.Equal[Ranged]} ${Me.RangedReady} \agLine#: ${Macro.CurLine}
            /if (${PullTimer} && (!${AggroTargetID} && !${ChainPull}) && ((!${Select[${PullWith},Melee,Pet,Ranged]} && !${Select[TRUE,${Me.SpellReady[${PullWith}]},${Me.AltAbilityReady[${PullWith}]},${Me.CombatAbilityReady[${PullWith}]},${Me.ItemReady[${PullWith}]}]}) || (${PullWith.Equal[Ranged]} && !${Me.RangedReady}))) /goto :PullAgain
            /if (${DebugPull}) /echo \atDEBUGPULL Pull Starting \agLine#: ${Macro.CurLine}
            /varset PullAttempts 0
            | Set group role puller to adjust for merc running up while pulling if soloing
            /if (${Group}==1 && !${Group.Puller.Name.Equal[${Me}]} && ${Select[${Role},puller]} && ${Spawn[=${MainAssist}].Type.Equal[Mercenary]}) /call AssignGroupRole set "${Me.CleanName}" 3
|------------------------------------------------------------------------Pull Begin Move-------------------------------------------------------------------------------------------|            
            /if ((${Spawn[${MyTargetID}].Distance3D}>${PullDist} || !${Spawn[${MyTargetID}].LineOfSight}) && ${Math.Distance[${Spawn[${MyTargetID}].Y},${Spawn[${MyTargetID}].X},${Spawn[${MyTargetID}].Z}:${CampYLoc},${CampXLoc},${CampZLoc}]}<${MaxRadius}) {
                :WeThereYet
|------------------------------------------------------------------------MQ2AdvPath-------------------------------------------------------------------------------------------|                
                | Advpath pull does not use max pull radius. It uses pullwith radius
                /if (${PullMoveUse.Equal[advpath]}) {
                    /call PullUsingAdvPath ${MyTargetID} ${PullDist}
                    /if (!${MyTargetID}) /return
|------------------------------------------------------------------------MQ2Nav-------------------------------------------------------------------------------------------|
                } else /if (${PullMoveUse.Equal[nav]}) {
                    /call PullUsingNav ${MyTargetID} ${PullDist} 
                    /if (!${MyTargetID}) /return
|------------------------------------------------------------------------LOS-------------------------------------------------------------------------------------------|
                | We are pulling by LOS.  
                } else /if (${Spawn[${MyTargetID}].LineOfSight}) {
                    /if (${Me.FeetWet}) {
                        /if (${X2}==0) /varcalc PullDist ${PullDist}-(${Spawn[${MyTargetID}].Distance3D}-${Spawn[${MyTargetID}].Distance})
                        /moveto id ${MyTargetID} mdist ${PullDist} uw
                    } else {
                        /moveto id ${MyTargetID} mdist ${PullDist}
                    }
                    /delay 10
                    /varset X2 ${Int[${Me.X}]}
                    /varset Y2 ${Int[${Me.Y}]}            
                    /if (${DebugPull}) /echo \atDEBUGPULL Pull LOS ${Spawn[${MyTargetID}].LineOfSight} ${PullDist} \agLine#: ${Macro.CurLine}
|------------------------------------------------------------------------Mob OOR Return to Camp-------------------------------------------------------------------------------------------|                    
                } else {
                    /if (${X2}!=0) { 
                        /if (${Math.Distance[${Me.Y},${Me.X}:${Y2},${X2}]}>200 || ${PullTimer}==0) {
                            /echo Mob is no Longer in LOS. Returning to Camp.
                            /if (${MyTargetID}) /squelch /alert add 1 id ${MyTargetID}
                            /if (${MoveTo.Moving}) /moveto off
                            /call BackToCampReset
                            /if (${Macro.Return}) /return
                        } else /if ((!${Me.Moving} || !${MoveTo.Moving}) && ${PullDist}<${Spawn[${MyTargetID}].Distance}) {
                            /if (${Me.FeetWet}) {
                                /moveto id ${MyTargetID} mdist ${PullDist} uw
                            } else {
                                /moveto id ${MyTargetID} mdist ${PullDist}
                            }
                            /delay 10
                        }
                    }
                    /if (${DebugPull}) /echo \atDEBUGPULL Pull NO-LOS ${Spawn[${MyTargetID}].LineOfSight} ${Spawn[${MyTargetID}].Distance3D} ${PullDist} \agLine#: ${Macro.CurLine}
                }
            }
|------------------------------------------------------------------------End Pull Move-------------------------------------------------------------------------------------------|            
            /if (${Spawn[${MyTargetID}].Distance3D}<=${PullDist} && ${Target.FeetWet}==${Me.FeetWet}) /varset WasInRange 1
            /if (${Math.Distance[${Spawn[${MyTargetID}].Y},${Spawn[${MyTargetID}].X},${Spawn[${MyTargetID}].Z}:${CampYLoc},${CampXLoc},${CampZLoc}]}>${MaxRadius}) {
                /if (!${PullIgnore1.Find[|${MyTargetID}]} && ${MyTargetID}>0) {
                    /squelch /alert add 1 id ${MyTargetID}
                    /varset PullIgnore1 ${PullIgnore1}|${MyTargetID}
                    /echo Added ${MyTargetID} to ignor pull list. ${PullIgnore1}
                }
            }
            /varset CantSee 0
            /doevents
            /if (${Pulled}) /goto :DonePulling
            |Checking to see if you are far from camp to try and fix the exceed to far from camp check.
            /if ((${Select[${PullMoveUse},los,nav]}>=1 && ${Math.Distance[${CampYLoc},${CampXLoc},${CampZLoc}]}>=${Math.Calc[${MaxRadius}*.90]})) /goto :PullAgain
            /if (${DPSPaused}) /return 
            | Extending PullTimer if moving closer or target moving && !${Select[${Role},hunter]}
            /if (${PullMoveUse.Equal[nav]}) {
                /if ((${Navigation.Active} || ${MoveTo.Moving} || (${Spawn[${MyTargetID}].Speed}>25 && ${Spawn[${MyTargetID}].Distance3D}>${PullRange}))) /varcalc PullTimer ${PullTimer}+50
            } else /if (${PullMoveUse.Equal[los]} && !${Select[${Role},hunter,hunterpettank]}) {
                /if ((${Me.Moving} || ${MoveTo.Moving} || (${Spawn[${MyTargetID}].Speed}>25 && ${Spawn[${MyTargetID}].Distance3D}>${PullRange}))) /varcalc PullTimer ${PullTimer}+50
            
            }
            | Pull counter used to in conjunction with 1s delay for timing
            /varcalc PullAttempts ${PullAttempts}+1
            | Try and pull again after 7 seconds or 3 seconds if target is moving
            /if (${Select[${PullMoveUse},los,nav]}>=1) {
                /if (${PullAttempts}>=7) {
                    | Make range smaller to creep closer to mob if not los
                    /if (${Spawn[${MyTargetID}].Distance3D}<=${PullDist} && !${Spawn[${MyTargetID}].LineOfSight}) /varcalc PullDist ${PullDist}*.6
                    /if (${DebugPull}) /echo \atDEBUGPULL Pull PullDist: ${PullDist} - PullLoops: ${PullAttempts} LineOfSight: ${Spawn[${MyTargetID}].LineOfSight} \agLine#: ${Macro.CurLine}
                    /goto :PullAgain
                } else /if (${PullAttempts}>=3 && ${Spawn[${MyTargetID}].Speed}>25 && ${WasInRange} && ${Spawn[${MyTargetID}].Distance3D}>${PullDist}) {
                    | Make range smaller to creep closer to mob if Mob is Moving
                    /varcalc PullDist ${PullDist}*.6
                    /varset WasInRange 0
                    /if (${DebugPull}) /echo \atDEBUGPULL Pull PullDist: ${PullDist}*.6 - PullLoops: ${PullAttempts} \agLine#: ${Macro.CurLine}
                    /goto :PullAgain
                }
            }
            | 1s timer used in conjunction with PullAttempts to control pulling
            /delay 10
|------------------------------------------------------------------------Are We Stuck-------------------------------------------------------------------------------------------|                       
        | - Check to see if we are stuck
        /if ((${Int[${Me.X}]}==${X1}) && (${Int[${Me.Y}]}==${Y1})) {
            /varcalc StuckCount (${StuckCount})+1
            /if (${StuckCount}>=2) {
                /if (${IAmDead} || ${Me.Hovering}) {
                    /call Stopmoving
                    /return
                } else {
                    /call Stuck
                } 
            }
            /if (${StuckCount}>=7 && !${PullAggroTargetID}) {
                /echo I am stuck aborting pull
                /if (${MyTargetID}) /squelch /alert add 1 id ${MyTargetID}
                /call StopMoving
                /call BackToCampReset
                /if (${Macro.Return}) /return            
            }
        }
|------------------------------------------------------------------------Are We Stuck End-------------------------------------------------------------------------------------------|                        
        /if (${DebugPull})  /echo \atDEBUGPULL Pull Loop Count: ${PullAttempts} ${Me.Moving} ${MoveTo.Moving} ${Me.Speed} ${Spawn[${MyTargetID}].Distance3D} ${PullRange} \agLine#: ${Macro.CurLine}
        | Not using advpath
        /if (${Select[${PullMoveUse},los,nav]}>=1) {
            | Distance loop check until mob in range to pull
            /if ((${Spawn[${MyTargetID}].Distance3D}>${PullRange} || !${Spawn[${MyTargetID}].LineOfSight} || ${Target.FeetWet}!=${Me.FeetWet}) && !${PullAggroTargetID}) {
                /if (!${Me.Moving} || ${WasInRange}) /varcalc PullDist ${PullDist}*.8 
                /goto :WeThereYet
            }
            | If mob moves out of line of sight during pull try moveto mob again
            /if (!${Spawn[${MyTargetID}].LineOfSight} && !${Select[${Role},hunter,hunterpettank]} && ${PullTimer}) {
                /varcalc PullDist ${PullDist}*.8
                /if (${DebugPull}) /echo \atDEBUGPULL Pull Decrease pull distance to ${PullDist} \agLine#: ${Macro.CurLine}
                /goto :PullAgain
            }
            /if (${PullAggroTargetID}) /goto :PullAgain
        }
        /if (${Spawn[${MyTargetID}].ID} && ${Target.FeetWet}==${Me.FeetWet} && !${PullAggroTargetID} && (${Spawn[${MyTargetID}].Distance3D}<${PullRange} || (${PullWith.Equal[Melee]} && ${Spawn[${MyTargetID}].Distance3D}<${Math.Calc[${PullRange}*2]}))) {
             
            /if (${PullMoveUse.Equal[advpath]}) /varset WasInRange 1
            /call StopMoving
            | Target mob before Aggroing
            /target id ${MyTargetID}
            /delay 20 ${Target.ID}==${MyTargetID}
            | Validate target one more time before pulling
            /call ValidateTarget
            /if (${ValidTarget}==0) {
                /if (${Target.ID}) /squelch /alert add 1 id ${Target.ID}
                /squelch /target clear
                /echo Aborting Pull! Target invalid now! Reason:${Macro.Return}
                /call StopMoving
                /call BackToCampReset
                /if (${Macro.Return}) /return
            }
            /if (${PullWith.Equal[Ranged]} && ${Spawn[${MyTargetID}].Distance3D}<30) /varset ToClose 1
|------------------------------------------------------------------------Pull with Melee-------------------------------------------------------------------------------------------|            
            | Handle pulling with Melee setting
            /if (${PullWith.Equal[Melee]} || (${PullWithAlt.Equal[Melee]} && ${ToClose} && !${Select[${Role},hunter,hunterpettank]})) {
                /call PullWithMelee
|------------------------------------------------------------------------Pull with Ranged-------------------------------------------------------------------------------------------|                         
            | Pull with ranged
            } else /if (${PullWith.Equal[Ranged]} && !${ToClose}) {
                /call PullWithRanged ${PullDist} 1
                /if (${Macro.Return}>=1) /varset PullDist ${Int[${Macro.Return}]}
|------------------------------------------------------------------------Pull with Pet-------------------------------------------------------------------------------------------|                                 
            | Pull with pet
            } else /if (${PullWith.Equal[Pet]}) {                
                /call PullWithPet
|------------------------------------------------------------------------Pull with Cast-------------------------------------------------------------------------------------------|                          
            | Pull with cast
            } else {
                /call PullWithCast ${PullDist}
                /if (${Macro.Return}>=1) {
                    /varset PullDist ${Int[${Macro.Return}]}
                    /goto :PullAgain
                }
            }
|------------------------------------------------------------------------Pull with End-------------------------------------------------------------------------------------------|                      
            |- Toggle puller mode off if option enabled.
            /if (${Select[${Role},pullerpettank]} && ${PullRoleToggle} && ${Group.Puller.ID}==${Me.ID}) /call PullModeToggle TurnOff            
        } else /if (${PullAggroTargetID}) {
            | The else /if fixes when puller stalls because puller grabs aggro with out getting to pull.
            /varset Pulled 1
        }
        | If pull failed start over while timer > 0
        /if (${Select[${PullMoveUse},los,nav]}>=1 && !${Pulled}) /goto :PullAgain
        :DonePulling
        | reset mq2moveutils dist back to 10 from pull distance to ensure correct movement 
        /moveto dist 10
        /if (${PullWith.Equal[Ranged]}) {
            /call PullWithRanged ${PullDist} 2
        }
        /varset Pulling 0
        | Turn autofire back on
        /if (${AutoFireOff}) {
            /if (${DebugPull}) /echo \atDEBUGPULL Pull AutoFire on \agLine#: ${Macro.CurLine}
            /varset AutoFireOff 0
            /varset AutoFireOn 1
        }
        /if (${Select[${Role},hunter,hunterpettank]} && ${MyTargetID}) {
            /call PullHunter
            /return
        }
        /if (${DebugPull}) /echo \atDEBUGPULL Pull Done Pulling ${ReturnToCamp} ${Pulled} \agLine#: ${Macro.CurLine}
        /if (${ReturnToCamp}) {
            /if (${Pulled}) {
                /call WaitForMob
                /varset Pulled 0
            } else {
                /call DoWeMove 1 pull
            }
        }
        /if (${DebugPull}) /echo \atDEBUGPULL Pull Leave Mob ID:${Spawn[${MyTargetID}].ID} \agLine#: ${Macro.CurLine}
    /return
|--------------------------------------------------------------------------------------
| SUB: BacktoCampReset
|--------------------------------------------------------------------------------------
    Sub BacktoCampReset  
        /if (${DebugPull}) /echo \atDEBUGPULL BacktoCampReset: Enter \agLine#: ${Macro.CurLine}
        /if (${ReturnToCamp}) {
            /call DoWeMove 0 backtocampreset
        }
        /if (${Math.Distance[${CampYLoc},${CampXLoc}]} < ${CampRadius} || ${Select[${Role},hunter,hunterpettank]}) {
            /call PullReset
            /return TRUE
        }
        /if (${DebugPull}) /echo \atDEBUGPULL BacktoCampReset: Leave \agLine#: ${Macro.CurLine}
    /return 0
|--------------------------------------------------------------------------------------
| SUB: Stop Moving
|--------------------------------------------------------------------------------------
    Sub StopMoving
        /if (${DebugPull}) /echo \atDEBUGPULL StopMoving: Enter \agLine#: ${Macro.CurLine}
        /if (${MoveTo.Moving}) /moveto off
        /if (${Stick.Active}) /stick off
        /if (${PullMoveUse.Equal[nav]}) {
            /if (${Navigation.Active}) /nav stop
        }
        /if (${PullMoveUse.Equal[advpath]}) {
            /if (${AdvPath.State}) /play off
        }
        /delay 30 !${Me.Moving}
        /if (${DebugPull}) /echo \atDEBUGPULL StopMoving: Leave \agLine#: ${Macro.CurLine}
    /return
|--------------------------------------------------------------------------------------
| SUB: Pull with Melee
| -------------------------------------------------------------------------------------
    Sub PullWithMelee
        /if (${DebugPull}) /echo \atDEBUGPULL PullWithMelee: Enter \agLine#: ${Macro.CurLine}
        /if (!${Select[${Role},hunter,hunterpettank]}) {
            | Turn off mq2melee function so puller and pullertank doesn't attack mob on pull
            /if (${Select[${Role},puller,pullertank]} && ${UseMQ2Melee}) /squelch /melee melee=0
            /moveto id ${MyTargetID} mdist 15
            /delay 10
            /while (1) {
                /if (${DebugFramework}) /Echo Current Line ${Macro.CurLine}
				/if (${PullAggroTargetID} || ${Target.PctHPs}<100) /break
                /if (${Target.ID}) /face ${If[${FaceMobOn}==2,nolook,fast nolook]}
                /look 0
                /if (${Target.MaxRangeTo}>=${Target.Distance3D}) { 
                    /if (!${Me.Moving}) /moveto id ${MyTargetID} mdist ${If[${Target.Distance}>5,${Math.Calc[${MoveTo.ArrivalDist}-5]},1]}
                    /squelch /attack on
                    /if (!${Stick.Active} && ${PullMeleeStick} && !${PullAggroTargetID}) /stick id ${MyTargetID} 70%
                } else {
                    /if (!${Me.Moving}) /moveto id ${MyTargetID} mdist ${If[${Target.Distance}>5,${Math.Calc[${MoveTo.ArrivalDist}-5]},1]}
                }
                /delay 5
            /if (${PullAggroTargetID} || ${Target.PctHPs}<100) /break
            }
            | Turn off combat so puller returns to camp. You mean run like hell.
            /if (${Select[${Role},puller,pullertank,pullerpettank,hunterpettank]}) {
                    /attack off
                    /if (${Stick.Active}) /stick off
                    /squelch /target clear
                | Turn on mq2melee function back on after pull
                /if (${Select[${Role},puller,pullertank]} && ${UseMQ2Melee}) /squelch /melee melee=1
            }
        }
        /varset Pulled 1
        /varset ToClose 0
        /if (${DebugPull}) /echo \atDEBUGPULL PullWithMelee: Leave \agLine#: ${Macro.CurLine}
    /return 
|-------------------------------------------------------------------------------------
| SUB: Pull With Ranged
| -------------------------------------------------------------------------------------
    Sub PullWithRanged(int PullDistRanged,int RSwitch)
        /if (${DebugPull}) /echo \atDEBUGPULL PullWithRanged: Enter \agLine#: ${Macro.CurLine}
        /declare TryCount int local 0
        /declare AmmoCount int local 0
        /if (${DebugPull}) /echo \atDEBUGPULL PullWithRanged: Ranged \agLine#: ${Macro.CurLine}
        | Cursor check sometimes summoned items get stuck on cursor.
        /if (${Cursor.ID}) /autoinventory
        /if (${RSwitch}==0) {
            /if (${OrigRanged.NotEqual[${PullItem}]} && ${OrigRanged.NotEqual[null]} && !${RangedSwitch}) {
                /exchange "${PullItem}" ranged
                /varset RangedSwitch 1
                /delay 10
            }
            /if (${TempAmmo.NotEqual[null]} && ${TempAmmo.NotEqual[${PullAmmo}]} && !${AmmoSwitch}) {
                /exchange "${PullAmmo}" ammo
                /delay 10
                /if (${TempAmmo.NotEqual[${PullAmmo}]}) /varset AmmoSwitch 1
            }
        }
        /if (${RSwitch}==1) {
            :RangedAgain
                /varcalc TryCount ${TryCount}+1
                /doevents
                /if (${DPSPaused}) /return 
                /if (${PullAggroTargetID}) {
                    /varset Pulled 1
                    /return
                }
                /if (${CantSee}) {
                    /if (${Target.ID}) /squelch /face ${If[${FaceMobOn}==2,nolook,fast nolook]}
                    /delay 10
                    /varset CantSee 0
                    /if (${DebugPull}) /echo Could Not see Target. Trying Again. \agLine#: ${Macro.CurLine}
                }
                | Mod for puller to turn back to camp after /range this saves on the puller turning AFTER mob is aggroed  and turns facing camp while waiting for mob to aggro.
                /if (${Me.Combat}) {
                    /Attack off
                    /delay 20 !${Me.Combat}
                }
                /if (${Stick.Active}) /stick off
                /if (${Target.ID}) /squelch /face ${If[${FaceMobOn}==2,nolook,fast nolook]}
                /look 0
                /varset AmmoCount ${FindItemCount[=${PullAmmo}]}
                /delay 30 ${Me.Heading.ShortName.Equal[${Target.HeadingTo}]}
                /if (${Target.ID}==${MyTargetID} && ${Target.Distance3D}>=30) {
                    /while (${AmmoCount}==${FindItemCount[=${PullAmmo}]} && !${PullAggroTargetID} && ${Target.Distance3D}>=30 && ${Target.LineOfSight} && ${Target.FeetWet}==${Me.FeetWet}) {
                        /if (${DebugFramework}) /Echo Current Line ${Macro.CurLine}
						/range
                        /doevents TooClose
                        /if (${ToClose}) {
                            /varset PullDistRanged 15
                            /return ${PullDistRanged}
                        }
                        /doevents CantHit
                        /if (${CantHit}) {
                            /varset CantHit 0
                            /varcalc PullDistRanged ${PullDistRanged}*.8
                            /return ${PullDistRanged}
                        }
                        /doevents TooFar
                        /if (${PullTooFar}) {
                            /varset PullTooFar 0
                            /varcalc PullDistRanged ${PullDistRanged}*.8
                            /return ${PullDistRanged}
                        }
                    }
                }
                /if (${Math.Distance[${CampYLoc},${CampXLoc}]} > ${CampRadius}) {
                    /delay 10 ${PullAggroTargetID}
                    /if (${Target.ID}) /squelch /face ${If[${FaceMobOn}==2,nolook,fast nolook]} loc ${CampYLoc},${CampXLoc}
                }
                /if (!${PullAggroTargetID}) {
                    /delay ${Math.Calc[1+${Target.Distance}/50].Int}s ${PullAggroTargetID}
                    /varcalc PullTimer ${PullTimer}+10
                }
                /if (${DebugPull}) /echo \atDEBUGPULL Pull: ${PullTimer} !${PullAggroTargetID} ${Target.PctHPs}==100 \agLine#: ${Macro.CurLine}
                /if (${PullTimer} && ${TryCount}<3 && !${PullTooFar} && !${PullAggroTargetID}) /goto :RangedAgain
            /if (${PullAggroTargetID}) {
                /varset Pulled 1
                /return
            }
        }
        /if (${RSwitch}==2) {
            /if (${RangedSwitch} && ${RSwitch}) {
                /exchange "${OrigRanged}" ranged
                /varset RangedSwitch 0
                /delay 10
            }
            /if (${AmmoSwitch}) {
                /if (${Cursor.ID}) /autoinventory
                /exchange "${TempAmmo}" ammo
                /varset AmmoSwitch 0
                /delay 10
            }
        }
        /if (${DebugPull}) /echo \atDEBUGPULL PullWithRanged: Leave \agLine#: ${Macro.CurLine}
    /return
|-------------------------------------------------------------------------------------
| SUB: Pull With Casting
| -------------------------------------------------------------------------------------
    Sub PullWithCast(int PullDistCast)
        /if (${DebugPull}) /echo \atDEBUGPULL PullWithCas:t Enter \agLine#: ${Macro.CurLine}
            /if (${DebugPull}) /echo \atDEBUGPULL PullWithCast: Casting to pull mob \agLine#: ${Macro.CurLine}
            /if (${Me.Moving}) /call StopMoving
            /if (${Target.ID}) /face ${If[${FaceMobOn}==2,nolook,fast nolook]}
            /look 0                 
            /if (${PullAggroTargetID}) /return ${PullDistCast}
            /if (!${Spawn[${MyTargetID}].LineOfSight}) {
                /varcalc PullDistCast ${PullDistCast}*.8
                /return ${PullDistCast}
            }
            /if (!${Me.Moving}) /call CastWhat "${PullWith}" ${Target.ID} Pull 0
            /if (${Macro.Return.Equal[CAST_SUCCESS]} || ${Macro.Return.Equal[CAST_RESIST]} || ${PullAggroTargetID}) /varset Pulled 1
            /delay 10 ${PullAggroTargetID}
        /if (${DebugPull}) /echo \atDEBUGPULL PullWithCast: Leave \agLine#: ${Macro.CurLine}
    /return      
|-------------------------------------------------------------------------------------
| SUB: Pull With Pet Written by TreeHuginDruid for RedGuides
| -------------------------------------------------------------------------------------
    Sub PullWithPet
        /if (${DebugPull}) /echo \atDEBUGPULL PullWithPet: Enter \agLine#: ${Macro.CurLine}
        /if (${Target.ID}) /face ${If[${FaceMobOn}==2,nolook,fast nolook]}
        |- Ensure we are in pull range and pet is following!                              
        /if (${Me.Pet.Stance.NotEqual[FOLLOW]}) /pet follow
        | - Send in pet if I don't have a mob in extended target               
       :SendInPet
        /echo Pulling with PET now !
        /if (!${PullAggroTargetID}) {
            /pet attack
            /delay 10 ${PullAggroTargetID}
            | Fix for HunterPetTank
            /if (${Spawn[${MyTargetID}].ID} && ${Spawn[${MyTargetID}].Type.NotEqual[corpse]} && !${PullAggroTargetID}) /goto :SendInPet
        }
        | - If I have a extended target, flag as pulled.
        /if (${PullAggroTargetID}) {
            /varset Pulled 1
            /if (${PetHoldOn}) /pet ${PetHold} on
            /pet back off
        } 
        /if (${DebugPull}) /echo \atDEBUGPULL PullWithPet: Leave \agLine#: ${Macro.CurLine}
    /return 
|--------------------------------------------------------------------------------------
| SUB: Pull Hunter
|--------------------------------------------------------------------------------------
    Sub PullHunter
        /if (${DebugPull}) /echo \atDEBUGPULL PullHunter Enter \agLine#: ${Macro.CurLine}
            /if (${PullWith.Equal[Melee]}) {
            :AttackAgain1
                /if (${Target.Moving} || ${Target.Distance}>12) /moveto id ${MyTargetID} mdist 10
                /if (${Target.ID}) /face nolook
                /if (${Target.Distance}<15) /attack on
                /if (!${AggroTargetID}) /stick id ${MyTargetID} 70%
                /delay 5
                /if (!${AggroTargetID} && ${Target.ID}) /goto :AttackAgain1
            }
			/if (${Me.XTarget[1].ID} && ${SpawnCount[npc radius ${MeleeDistance} zradius 15 targetable playerstate 4]}) /return
            /call PullReset
            | Try to return home if exceeding max radius while in ANY hunter mode
            /if (${Math.Distance[${Me.Y},${Me.X}:${CampYLoc},${CampXLoc}]}>${Math.Calc[${MaxRadius}*.95]}) {
            /if (${DebugPull}) /echo \atDEBUGPULL PullHunter Returning hunter to camp \agLine#: ${Macro.CurLine}
                /echo ${Role}: Reached edge of ${MaxRadius} hunting radius. Trying to return to camp.
                /varset ReturnToCamp 1
                /call DoWeMove 0 pullhunter
            }    
        /if (${DebugPull}) /echo \atDEBUGPULL PullHunter Enter \agLine#: ${Macro.CurLine}
    /return
|-------------------------------------------------------------------------------------
| SUB: Pull Using MQ2Nav || (${Math.Distance[${CampYLoc},${CampXLoc}]}>=${PullNavDistance}) fix spwn dist from camp not mine.
| -------------------------------------------------------------------------------------
    Sub PullUsingNav(int BeginMobNavID,float NavPullDist) 
        /if (${DebugPull}) /echo \atDEBUGPULL PullUsingNav Enter Pulling ${Spawn[${BeginMobNavID}].Name} ${NavPullDist} ${Target.Distance} \agLine#: ${Macro.CurLine}
        /varset PullTimer 30
        /declare PullNavTimer timer local 3m 
        /varset PullNavDistance ${Navigation.PathLength[id ${BeginMobNavID}]} 
        /nav id ${BeginMobNavID}
        /while (1) {
            /if (${DebugFramework}) /Echo Current Line ${Macro.CurLine}
			/doevents
            | Check if puller has corpse from dying on previous pull along path
            /if (!${DragCorpse} && ${SpawnCount[pccorpse ${Me} radius ${MaxRadius}]}) {
                /call GrabCorpse
                /if (${DragCorpse}) {
                    /if (${DebugPull}) /echo \atDEBUGPULL PullUsingNav Leave found my cporse \agLine#: ${Macro.CurLine}
                    /return TRUE 
                }
            }
            |Internal loop delay 1 second. No reason to loop faster than 1 second.
            /delay 10
            | Corrects heading when mob is moving and your using Navigation.
            /if (${Spawn[${BeginMobNavID}].Speed}>25) {
                /squelch /nav id ${BeginMobNavID}
                /if (${Role.Equal[hunter]} && ${Spawn[id ${BeginMobNavID}].LineOfSight}) {
                    /if (!${Stick.Active} && ${Target.Distance}<20) {
                        /moveto id ${Target.ID}
                        /stick id ${Target.ID}
                        /return
                    }
                }
            }
            | Check for Unexpected Aggro
            /if ((${AggroTargetID} && !${ChainPull}) || ((${Me.XTarget[${XTSlot2}].ID} || (${Me.XTarget[${XTSlot}].ID} && ${Me.XTarget[${XTSlot}].ID}!=${BeginMobNavID})) && ${ChainPull})) /return 0
           | Check for being to far from camp lose MyTargetID or path
            /if (${Math.Distance[${CampYLoc},${CampXLoc}]}>=${Math.Calc[${MaxRadius}*.95]} || ${PullNavTimer}==0 || !${Spawn[${BeginMobNavID}].ID} || !${Navigation.PathLength[id ${BeginMobNavID}]}) {
                /echo We have exceeded max pulling radius or timer or lost path to mob. Returning to camp  
                /if (${Navigation.Active}) /nav stop
                /if (${DebugPull}) /echo \atDEBUGPULL PullUsingNav Leave Max radius/no timer/no mob/nopath \agLine#: ${Macro.CurLine} (${Math.Distance[${CampYLoc},${CampXLoc}]}>=${Math.Calc[${MaxRadius}*.95]} && ${Spawn[${BeginMobNavID}].Speed}>25) || (${Math.Distance[${CampYLoc},${CampXLoc}]}>=${PullNavDistance}) || ${PullNavTimer}==0 || !${Spawn[${BeginMobNavID}].ID} || !${Navigation.PathLength[id ${BeginMobNavID}]}
                /if (${Select[${Role},hunter,hunterpettank]}) {
                    /call PullReset
                    /return
                } else {
                    /call BackToCampReset
                }
                /return TRUE
            }
            | Keep timer from main Pull sub alive
            /if (${Me.Moving} && ${Navigation.Active}) /varset PullTimer 30
            /if ((${Spawn[${BeginMobNavID}].Distance3D}>${NavPullDist} || !${Spawn[${BeginMobNavID}].LineOfSight} || ${Spawn[${BeginMobNavID}].FeetWet}!=${Me.FeetWet}) && ((!${AggroTargetID} && !${ChainPull}) || (!${Me.XTarget[${XTSlot2}].ID} && ${Me.XTarget[${XTSlot}].ID}!=${BeginMobNavID} && ${ChainPull}))) /continue
                /if (${Navigation.Active}) /nav stop
                /if (!${Spawn[${BeginMobNavID}].LineOfSight} && ${Target.Distance}>20) {
                    /squelch /nav id ${BeginMobNavID}
                    /continue
                }
                /break
         }       
        /if (${DebugPull}) /echo \atDEBUGPULL PullUsingNav Leave \agLine#: ${Macro.CurLine}
    /return 0
|-------------------------------------------------------------------------------------
| SUB: Pull Using AdvPath
| -------------------------------------------------------------------------------------
    Sub PullUsingAdvPath(int BeginMobAPID,float APPullDist)  
        /if (${DebugPull}) /echo \atDEBUGPULL PullUsingAdvPath Enter \agLine#: ${Macro.CurLine}
        /if (${MoveTo.Moving}) /moveto off
        /play ${PullPath} nodoor smart normal 
        /if (${DebugPull}) /echo \atDEBUGPULL PullUsingAdvPath /play ${PullPath} nodoor smart normal \agLine#: ${Macro.CurLine}
        :RunningThePath 
        /if (${DebugPull}) /delay 5 
        /if (${DebugPull}) /echo \atDEBUGPULL PullUsingAdvPath /echo Waypoint: ${AdvPath.NextWaypoint} Target: ${Target.ID} MyTargetID: ${MyTargetID} Aggro: ${AggroTargetID} MobToWPDist: ${Math.Distance[${Spawn[id ${MyTargetID}].Y},${Spawn[id ${MyTargetID}].X}:${AdvpathPointY},${AdvpathPointX}]}<${APPullDist} MeToWPDist: ${Math.Distance[${Me.Y},${Me.X}:${AdvpathPointY},${AdvpathPointX}]}>50 WP<NWP: ${AdvPath.NextWaypoint}>=${AdvpathPointNum} \agLine#: ${Macro.CurLine}
        | Do we have aggro?
        /if (${AggroTargetID}) /goto :StopPath
        | Has the mob move out of range from the original way point
        /if (${Math.Distance[${Spawn[id ${MyTargetID}].Y},${Spawn[id ${MyTargetID}].X}:${AdvpathPointY},${AdvpathPointX}]}>${APPullDist}) /goto :StopPath
        | Is mob within pull range and LOS
        /if (${Math.Distance[${Spawn[id ${MyTargetID}].Y},${Spawn[id ${MyTargetID}].X}:${Me.Y},${Me.X}]}<${APPullDist} && ${Spawn[${MyTargetID}].LineOfSight} && ${Target.FeetWet}==${Me.FeetWet}) /goto :StopPath
        | Stop at our waypoint
        /if (${AdvPath.NextWaypoint}>=${AdvpathPointNum} && ${Math.Distance[${Me.Y},${Me.X}:${AdvpathPointY},${AdvpathPointX}]}<=5) {
            /goto :StopPath
        }
        /goto :RunningThePath
        :StopPath
        /play off
        /if (${DebugPull}) /echo \atDEBUGPULL PullUsingAdvPath /play ${PullPath} nodoor smart normal \agLine#: ${Macro.CurLine}  
        /if (${DebugPull}) /echo \atDEBUGPULL PullUsingAdvPath Leave ${AdvPath.NextWaypoint} \agLine#: ${Macro.CurLine}        
    /return ${AdvPath.NextWaypoint}
| -------------------------------------------------------------------------------------
| SUB: Wait for Mob
| -------------------------------------------------------------------------------------
    Sub WaitForMob
        /if (${Select[${Role},hunter,hunterpettank]} || ${DPSPaused}) /return
        /if (${DebugPull}) /echo \atDEBUGPULL WaitForMob Enter \agLine#: ${Macro.CurLine}
        /varset WaitTimer 45s
        /if (${Pulled}) {
            /if (${DebugPull}) /echo \atDEBUGPULL WaitForMob Waiting for mob \agLine#: ${Macro.CurLine}
            /call DoWeMove 1 waitformob
            /if (${ChainPull}) /varset LastMobPullID ${Target.ID}
            /declare FaceTimer timer local 0
            /if (${InvSlot[ranged].Item.Name.NotEqual[${OrigRanged}]} && ${OrigRanged.NotEqual[null]}) {
                /exchange "${OrigRanged}" ranged
            }
            | When you target a mob and another mob aggros you, but your target never gets aggroed.
            /if (${PullAggroTargetID} && ${Target.ID}!=${PullAggroTargetID} && ${Target.AggroHolder.ID}==0) {
                /target id ${AggroTargetID}
            }
            :WaitForMob
                /if (${FaceMobOn} && ${Target.ID} && (${Me.Standing} || ${Me.Mount.ID})) /face ${If[${FaceMobOn}==1,fast nolook,nolook]}
                /doevents
                /call MobRadar ${CampRadius} WaitForMob
                | If NOT chain pulling and multiple mobs in camp. /return
                /if (${MobCount}>=2 && !${ChainPull}) {
                    /call PullReset
                    /return
                } 
                /if (${DebugPull}) /echo \atDEBUGPULL - WaitTimer: ${WaitTimer} Target Distance: ${Target.Distance} Mob Dist from Camp: ${Math.Distance[${Spawn[${MyTargetID}].Y},${Spawn[${MyTargetID}].X}:${CampYLoc},${CampXLoc}]}>=${CampRadius} Mob Dist from tank: ${Math.Distance[${Spawn[${MyTargetID}].Y},${Spawn[${MyTargetID}].X}:${Me.Y},${Me.X}]}>=20 \agLine#: ${Macro.CurLine}
                | if target lost somehow add to ignore list and continue pulls
                /if ((!${AggroTargetID} && !${ChainPull}) || ${WaitTimer}==0) {
                    /if (${DebugPull}) /echo \atDEBUGPULL WaitForMob /return no AggroTargetID \agLine#: ${Macro.CurLine}
                    /if (${Target.ID}) /squelch /alert add 1 id ${Target.ID}
                    /call PullReset 
                    /return
                }
                /varset FaceTimer 1s
                /delay 1s
                | I am PULLER with PET TANK            
                /if (${Select[${Role},pullerpettank]}) {
                    |- Make sure pet is returning to camp with me.
                    /if (${Me.Pet.ID} && ${Math.Distance[${Me.Pet.Y},${Me.Pet.X}:${CampYLoc},${CampXLoc}]}>${CampRadius} && ${Math.Distance[${Me.Pet.Y},${Me.Pet.X}:${Me.Y},${Me.X}]}>20) {
                        /pet back off
                        /delay 10
                        /pet follow
                    } 
                    | If the mob is within pet attack distance from camp send the pet in to attack
                    /if (${Math.Distance[${CampYLoc},${CampXLoc}:${Spawn[${MyTargetID}].Y},${Spawn[${MyTargetID}].X}]}>=${PetAttackRange}) /goto :WaitForMob
                    /if (!${PetAttack}) /call CombatPet
                }
                | I am PULLER TANK
                /if (${Select[${Role},pullertank]}) {
                    | Wait in camp for mob if timer active and mob is outside of camp radius and mob is farther away from tank than 20 feet
                    /if (${WaitTimer} && ${Math.Distance[${Spawn[${MyTargetID}].Y},${Spawn[${MyTargetID}].X}:${CampYLoc},${CampXLoc}]}>${MeleeDistance}) /goto :WaitForMob
                }
                | If I am PULLER and NOT chain pulling
                /if (${Select[${Role},puller]} && !${ChainPull}) {
                    /if (${Math.Distance[${CampYLoc},${CampXLoc}:${Spawn[${MyTargetID}].Y},${Spawn[${MyTargetID}].X}]}>=${CampRadius} && ${Math.Distance[${Spawn[${MyTargetID}].Y},${Spawn[${MyTargetID}].X}:${Spawn[=${MainAssist}].Y},${Spawn[=${MainAssist}].X}]}>20) /goto :WaitForMob
                    /if (${MercOn} && !${MercAssisting} && ${MyTargetID} && ${Mercenary.State.Equal[Active]}) /call MercsDoWhat
                }
                | If I am PULLER and chain pulling
                /if (${Select[${Role},puller]} && ${ChainPull}) {
                    | Leave if multi mobs or no mobs 
                    /if (${MobCount}>=2 || !${MyTargetID} || (${Me.XTarget[${XTSlot}].ID} && ${Me.XTarget[${XTSlot2}].ID})) { 
                        /call PullReset
                        /return
                    }
                    /if (${Math.Distance[${Spawn[${MyTargetID}].Y},${Spawn[${MyTargetID}].X}:${Spawn[=${MainAssist}].Y},${Spawn[=${MainAssist}].X}]}>20 && ${Target.ID}==${Spawn[${MyTargetID}].ID} && ${Me.TargetOfTarget.ID}==${Me.ID}) /goto :WaitForMob                 
                }
        }
        /if (${Group}==1 && ${Select[${Role},puller]} && ${Group.Puller.Name.Equal[${Me}]} && ${Spawn[=${MainAssist}].Type.Equal[Mercenary]} && ${Spawn[${MyTargetID}].Distance}<=${MeleeDistance}) /call AssignGroupRole unset "${Me.CleanName}" 3            
        /if (${MyTargetID} && !${PullAggroTargetID}) /call PullReset
        /if (${IAmABard}) /call DoBardStuff
        /varset WaitTimer 0
        /call MercsDoWhat
        /if (${DebugPull}) /echo \atDEBUGPULL WaitForMob Leave \agLine#: ${Macro.CurLine}
    /return
| -------------------------------------------------------------------------------------
| SUB: Reset Pull variables
| -------------------------------------------------------------------------------------
    Sub PullReset
        /if (${DebugPull}) /echo \atDEBUGPULL PullReset Enter \agLine#: ${Macro.CurLine}
        /moveto dist 10
        /varset Pulling 0
        /varset Pulled 0
        /varset MyTargetID 0
        /varset MyTargetName
        /varset ToClose 0
        /attack off
        /if (${MoveTo.Moving}) /moveto off
        /if (${PullMoveUse.Equal[nav]}) {
            /if (${Navigation.Active}) /nav stop
        }
        /varset WaitTimer 0
        /varset DragCorpse 0
        /squelch /target clear
        /if (${DebugPull}) /echo \atDEBUGPULL PullReset Leave \agLine#: ${Macro.CurLine}
    /return
| -------------------------------------------------------------------------------------
| SUB: PullModeToggle
| -------------------------------------------------------------------------------------
    Sub PullModeToggle(ToggleState)
        /if (!${Select[${Me},${Group.Leader}]} || !${SpawnCount[group mercenary]}) /return
        /if (${ToggleState.Equal[TurnOn]}) {   
            :TurnOnPullRole
            /if (${Target.Distance}>${CampRadius}) {                
                /if (${Group.Puller.ID}!=${Me.ID}) /grouproles set ${Me.CleanName} 3
                /delay 10 ${Group.Puller.ID}==${Me.ID}
                /if ((${Target.Distance}>${CampRadius}) && (${Group.Puller.ID}!=${Me.ID})) /goto :TurnOnPullRole  
                /if (${Group.Puller.ID}==${Me.ID}) /echo + You have been set be group puller.        
            }
        }
        /if (${ToggleState.Equal[TurnOff]}) {    
            :TurnOffPullRole
            /if ((${Group.Puller.ID}==${Me.ID}) && (${Math.Distance[${Me.Y},${Me.X}:${CampYLoc},${CampXLoc}]}<=${CampRadius})) {        
                /if (${Debug}) /echo KICKIT! ((${Group.Puller.ID}==${Me.ID}) && (${Math.Distance[${Me.Y},${Me.X}:${CampYLoc},${CampXLoc}]}<=${CampRadius})) \agLine#: ${Macro.CurLine}
                /if (${Group.Puller.ID}==${Me.ID}) /grouproles unset ${Me.CleanName} 3
            } else {
                /if ((${Group.Puller.ID}==${Me.ID}) && (${Math.Distance[${Me.Y},${Me.X}:${CampYLoc},${CampXLoc}]}>${CampRadius})) /moveto loc ${CampYLoc} ${CampXLoc} mdist 10
            }
            /delay 10 ${Group.Puller.ID}!=${Me.ID}    
            /if (${Math.Distance[${Me.Y},${Me.X}:${CampYLoc},${CampXLoc}]}>${CampRadius} || (${Group.Puller.ID}==${Me.ID})) /goto :TurnOffPullRole   
            /if (${Group.Puller.ID}!=${Me.ID}) /echo + You are no longer group puller.
        }
    /return
| -------------------------------------------------------------------------------------
| SUB: GroupWatch
| -------------------------------------------------------------------------------------
    Sub GroupWatch
        /if (!${GroupWatchOn} ) /return 
        /if (${AggroTargetID} && !${ChainPull}) /return
        /if (${Debug}) /echo \atDEBUG GroupWatch Enter \agLine#: ${Macro.CurLine}
        /declare i int local
        /declare GrpMemType string local
        /declare GrpMemName string local
        /declare GrpMemClass string local
        /declare GrpMemStat string local
        /if (!${Spawn[=${MainAssist}].ID} && !${Select[${Role},tank,pullertank,pettank,pullerpettank,hunter,hunterpettank]} && ${CampZone}==${Zone.ID}) {
            /echo I am not detecting Main Assist pausing.
            :WaitForMA
                /doevents
                |CHECKFORCOMBAT
				/if (${Me.XTarget[1].ID} && ${SpawnCount[npc radius ${MeleeDistance} zradius 15 targetable playerstate 4]}) /return
                /call WaitSubs
                /if (${Spawn[=${MainAssist}].ID}) {
                    /echo Main Assist is back resuming action.
                    /return
                }
                /delay 10
            /goto :WaitForMA
        }
        /if (${PullHold}==1) /varset PullHold 0
        /for i 1 to 5
            /if (!${Group.Member[${i}].ID} || ${Group.Member[${i}].Type.Equal[corpse]} ) {
                /if (${ChainPull} && ${Group.Member[${i}].Type.Equal[corpse]}) /varset PullHold 1
                /continue
            }
            /if (${GroupWatchOn}==2 && !${Select[${Group.Member[${i}].Class.ShortName},CLR,DRU,SHM]}) /continue
            /varset GrpMemType ${Group.Member[${i}].Type}
            /varset GrpMemName ${Group.Member[${i}].CleanName}
            /varset GrpMemClass ${Group.Member[${i}].Class.ShortName}
            /if (${Select[${GrpMemClass},BER,MNK,ROG,WAR]}) {
                /varset GrpMemStat Endurance
            } else {
                /varset GrpMemStat Mana
            }
            /if (${Debug}) /echo \atDEBUG ${i} /call CheckStats 1 "${GrpMemName}" "${GrpMemClass}" "${GrpMemType}" ${GrpMemStat} ${GroupWatchPct} 90 \agLine#: ${Macro.CurLine}
            /call CheckStats 1 "${GrpMemName}" ${GrpMemClass} ${GrpMemType} ${GrpMemStat} ${GroupWatchPct} 90
            /if (${Select[${GrpMemClass},BST,PAL,RNG,SHD]}) /call CheckStats 1 "${GrpMemName}" "${GrpMemClass}" "${GrpMemType}" Endurance ${GroupWatchPct} 90
        /next i
        /if (${Debug}) /echo \atDEBUG GroupWatch Leave \agLine#: ${Macro.CurLine}
    /return
| -------------------------------------------------------------------------------------
| SUB: CheckStats
| -------------------------------------------------------------------------------------
    Sub CheckStats(int statcheck, charname, ckclass, cktype, stat, int pause,int resume)
        /if (!${statcheck}) /return
        /if (!${Spawn[${ckclass} ${cktype} ${charname}].ID}) /return
        /if (${Spawn[${ckclass} ${cktype} ${charname}].Current${stat}}>${pause}) /return
        /if (${Debug}) /echo \atDEBUG CheckStats Enter \agLine#: ${Macro.CurLine}
        /if (${Debug}) /echo \atDEBUG statcheck ${statcheck} charname ${charname} ckclass ${ckclass} stat ${stat} pause ${pause} resume ${resume} \agLine#: ${Macro.CurLine}
        /if (${Role.Equal[puller]} && ${ChainPull} ) {
                /call MobRadar ${MeleeDistance} CheckStats
                /if (${MobCount}>0) {
                 /varset PullHold 1
             /return
            }
        }
        /if (${Select[${Role},puller,pullertank,hunter,hunterpettank,pullerpettank]}) {
            /call BroadCast ${EQBCOn} t "Waiting for >> ${charname} << to med up to ${resume}% ${stat}."
        } else {
            /echo  Waiting for >> ${charname} << to med up to ${resume}% ${stat}.
        }
        | target toon to make sure they aren't at full mana due to lag
        /target id ${Spawn[${ckclass} ${cktype} ${charname}].ID}
        /delay 10
        /varset Pulling 0
        | Only twist med if song no aggro others fighting willnegate bard fast med
        /if (${IAmABard} && ${TwistMed} && ${TwistOn} && ${AggroTargetID}) /squelch /twist ${TwistMed}
        /varset Medding 1
        :wait_for_resume
            /doevents
            /if (${ReturnToCamp} && ${Math.Distance[${CampYLoc},${CampXLoc}]} > 15 ) {
                /call DoWeMove 1 checkstats
                /delay 100 ${MoveTo.Stopped}
            }
            /delay 10
            /if (!${MedCombat}) /call WaitSubs
           |CheckForCombat
			/if (${Me.XTarget[1].ID} && ${SpawnCount[npc radius ${MeleeDistance} zradius 15 targetable playerstate 4]}) /return
        /if (${Spawn[${ckclass} ${cktype} ${charname}].Current${stat}}<${resume}) /goto :wait_for_resume
        /if (${Select[${Role},puller,pullertank,pullerpettank,hunter,hunterpettank]}) {
            /call BroadCast ${EQBCOn} t "${charname} is now above ${resume}% ${stat} resuming activity."
        } else {
        /echo ${charname} is now above ${resume}% ${stat} resuming activity.
        }
        /if (!${Me.Mount.ID} && ${Me.Sitting}) /stand
        /varset Medding 0
        /varset PullHold 0 
        /if (${IAmABard} && ${TwistMed}) {
            /while (${Me.BardSongPlaying}) {
                /if (${DebugFramework}) /Echo Current Line ${Macro.CurLine}
				/if (${Twist}) /squelch /twist off
                /stopsong
                /delay 5
            }
        }
        /if (${PullPause.NotEqual[0]}) /varset PullWaitTimer1 ${PullPause.Arg[1,"|"]}m
        /if (${Debug}) /echo \atDEBUG CheckStats Leave \agLine#: ${Macro.CurLine}
    /return
| -------------------------------------------------------------------------------------
| SUB: alert clear
| -------------------------------------------------------------------------------------
    Sub AlertClearList(int ListToClear, string SentFrom)
        /if (${DebugPull}) {
            /echo \atDEBUGPULL AlertClearList Enter  \agLine#: ${Macro.CurLine}
            /echo \atDEBUGPULL Clearing Alert list ${ListToClear}. \agLine#: ${Macro.CurLine}
        }
        /squelch /alert clear ${ListToClear}
        /if (${DebugPull}) /echo \atDEBUGPULL AlertClearList Leave \agLine#: ${Macro.CurLine}
    /return
| -------------------------------------------------------------------------------------
| SUB: Assign Group Role
| -------------------------------------------------------------------------------------
    Sub AssignGroupRole(ASGOnOff, AGRName, AGRRole)
        /if (${Debug}) /echo \atDEBUG AssignGroupRole ${ASGOnOff} ${AGRName} ${AGRRole} \agLine#: ${Macro.CurLine}
        /docommand /grouproles ${ASGOnOff} ${AGRName} ${AGRRole}
        /delay 10
    /return
| -------------------------------------------------------------------------------------
| SUB: Event CantSee CantHit
| -------------------------------------------------------------------------------------
    Sub Event_CantSee
        /if (${Debug}) /echo \atDEBUG Event_CantSee \agLine#: ${Macro.CurLine}
        | Reset position via stick
        /if (${Pulling}) {
           /varset CantSee 1
           /return
        }
        | need to add local variables or more Outer to figure stick command parts.
        |Start Here
        /if (${Attacking}) {
            /if (${Debug}) /echo Can't See my target. Moving Closer. \agLine#: ${Macro.CurLine}
            /if (${Me.Sitting}) /stand
            /if (${Target.ID}) /squelch /face ${If[${FaceMobOn}==2,nolook,fast nolook]}
            /look 0
            /if (!${UseMQ2Melee}) {
                /if (${StickHow.NotEqual[0]}) {
                    /if (${Me.FeetWet}) {
                        /if (${Stick.Active}) /Stick off
                        /if (${Target.ID}) /face
                        /moveto ${Target.MaxRangeTo} id ${Target.ID} uw
                        /delay 10
                        /if (${MainAssist.Equal[${Me}]}) {
                            /stick ${StickDistUW} id ${MyTargetID} moveback uw
                        } else {
                            /stick ${StickDistUW} id ${MyTargetID} behindonce moveback uw
                        }
                    } else {
                        /moveto ${Target.MaxRangeTo} id ${Target.ID} 
                        /delay 10
                        /if (${MainAssist.Equal[${Me}]}) {
                            /stick ${StickDist} id ${MyTargetID} moveback
                        } else {
                            /stick ${StickDist} id ${MyTargetID} behindonce moveback
                        }
                    }
                } else /if (${MeleeOn}) {
                    /if (${Me.FeetWet}) {
                        /stick ${StickDistUW} id ${MyTargetID} moveback uw
                    } else {
                        /if (${MainAssist.Equal[${Me}]}) {
                            /stick ${StickDist} id ${MyTargetID} moveback
                        } else {
                            /stick ${StickDist} id ${MyTargetID} !front moveback
                        }
                    }
                }
            }
        }
        /if (${Debug}) /echo Leave Event_CantSee \agLine#: ${Macro.CurLine}
        /doevents flush CantSee
    /return
| -------------------------------------------------------------------------------------
| SUB: Event CantHit
| -------------------------------------------------------------------------------------
    Sub Event_CantHit
        /if (${Debug}) /echo Event_CantHit \agLine#: ${Macro.CurLine}
        | Reset position via stick
        /if (${Pulling}) {
            /varset CantHit 1
            /if (${PullWith.Equal[Ranged]} && ${Target.Distance}<=30 && ${Target.LineOfSight}) /varset ToClose 1
        }
        /if (${Debug}) /echo Leave Event_CantHit \agLine#: ${Macro.CurLine}
    /return
| -------------------------------------------------------------------------------------
| SUB: Event Missing
| -------------------------------------------------------------------------------------
    Sub Event_Missing
        /varset MissingComponent 1
    /return 1
| ----------------------------------------------------------------------------
| SUB: Bind Switch
| ----------------------------------------------------------------------------
    Sub Bind_Switch(NewTarID)
        /if (${MainAssist.Equal[${Me}]}) /return 
        |/declare WasAttacking int local ${Attacking}
		/call CombatReset 1 switch
        /echo New target called
        /varset MyTargetID ${NewTarID}
		/squelch /target id ${NewTarID}
		/if (${DPSOn} && ${MeleeOn} && ${Target.PctHPs}<=${AssistAt}) /nav id ${MyTargetID}
        
		/call EngageTarget
    /return

| ----------------------------------------------------------------------------
| SUB: Bind Switch
| ----------------------------------------------------------------------------
    Sub Bind_parse
      
        /echo Parse called!
        /varset MyTargetID ${Target.ID}
		/squelch /target id ${MyTargetID}
		/call EngageTarget
    /return
| ----------------------------------------------------------------------------
| SUB: Bind SwitchMA
| ----------------------------------------------------------------------------
    Sub Bind_SwitchMA(string newMA, string newRole, int DoWhatFlag)
        /return
        | need to figure out if we need to call assist from assist
        /declare newRole1 string local ${newRole}
        /declare WasAttacking int local ${Attacking}
        /if (${newMA.Length}==0 || ${newMA.Equal[null]}) /return
        /if (${newRole1.Length}==0 || ${newRole1.Equal[null]}) /varset newRole1 Tank
        /if (${DoWhatFlag}==0) {
            /if (${EQBCOn} && ${Macro.IsTLO[EQBC]}) {
                /bcg //switchma ${newMA} ${newRole1} 1
            } else {
                /echo SwitchMA Command requires MQ2EQBC Plugin to be loaded and EQBCOn turned on.
            }
        }
        /echo Switching Main Assist to ${newMA}
        /if (${newMA.Equal[${Me}]}) {
            /varset MainAssist ${Me}
            /varset MainAssistType ${Me.Type}
            /varset MainAssistClass ${Me.Class.ShortName}
            /varset Role ${newRole1}
            /call CheckRoles 0
        } else /if (${Me.Pet.ID} && ${newMA.Equal[${Me.Pet.CleanName}]}) {
            /varset MainAssist ${Me}
            /varset MainAssistType ${Me.Type}
            /varset MainAssistClass ${Me.Class.ShortName}
            /varset Role pettank
            /call CheckRoles 0
            | assist,manual,petassist,tank,pettank,puller,pullertank,pullerpettank,hunter,hunterpettank
        } else {
            /varset MainAssist ${newMA}
            /varset MainAssistType ${Spawn[=${newMA}].Type}
            /varset MainAssistClass ${Spawn[=${newMA}].Class.ShortName}
            /if (${Role.NotEqual[${MyOriginalRole}]} ) {
                /varset Role ${MyOriginalRole}
                /call CheckRoles 0
            }
        }
        /call CombatReset 0 switchma
        /if (${MainAssist.NotEqual[${Me}]}) {
            /if (!${DPSPaused} && !${Select[${Role},manual,petassist,tank,pettank,puller,pullertank,pullerpettank,hunter,hunterpettank,offtank]} && (${MyTargetID}==0 || !${Spawn[targetable id ${MyTargetID}].ID} || ${Spawn[corpse id ${MyTargetID}].ID}) && ${Me.XTarget[1].ID} && ${SpawnCount[npc radius ${MeleeDistance} zradius 15 targetable playerstate 4]}) /call FindTarget 2
        } else {
            /if (!${DPSPaused} && ${Select[${Role},manual,petassist,tank,pettank,puller,pullertank,pullerpettank,hunter,hunterpettank,offtank]} && (!${Me.Combat} || ${Target.ID}!=${MyTargetID} || ${MyTargetID}==0) && ${Me.XTarget[1].ID} && ${SpawnCount[npc radius ${MeleeDistance} zradius 15 targetable playerstate 4]} && !${Spawn[corpse id ${MyTargetID}].ID}) /call FindTarget 1
        }
        /if (${WasAttacking} && ${Target.ID}) {
            /squelch /attack on
            /varset Attacking 1
        }
    /return
| ----------------------------------------------------------------------------
| SUB: Event AttackCalled 
| ----------------------------------------------------------------------------
    Sub Event_AttackCalled(String Line, ACCaller, ACMobID)
		/if (!${ACMobID.Length} || ${ACMobID.Equal[null]}) {
            /varset CalledTargetID 0
            /return
        }
		/if (${Select[${Role},manual,tank,pettank,pullertank,pullerpettank,hunter,hunterpettank]}) /return
        /if (${MainAssist.Equal[${Me}]}) /return
        /echo ==> Attack Called: ${ACCaller} ${ACMobID}

		/call ValidateTarget ${ACMobID}
        /if (${ValidTarget}==0) {
			/if (${Target.ID}) /squelch /alert add 2 id ${Target.ID}
			/varset MyTargetID 0
			/varset MyTargetName
			/echo invalid target
			/return
		} else /if (${Raid.Members} || (!${Raid.Members} && ${ACCaller.Equal[${MainAssist}]})) {
			/varset CalledTargetID ${ACMobID}
			/varset MyTargetID ${ACMobID}
			/varset MyTargetName ${Spawn[${ACMobID}].CleanName}
			
		}
	
		/if (!${DPSPaused} && !${Spawn[corpse id ${MyTargetID}].ID} && ${Spawn[targetable id ${MyTargetID}].ID} && ${Spawn[${SpawnSearchType} id ${MyTargetID}].PctHPs}<=${AssistAt} && ${Spawn[${SpawnSearchType} id ${MyTargetID}].Distance}<${MeleeDistance} && (!${Target.Mezzed.ID} || ${Select[${Role},manual,petassist,tank,pettank,puller,pullertank,pullerpettank,hunter,hunterpettank,offtank]})) {
			/if (${Target.ID}!=${MyTargetID} && ${Spawn[${SpawnSearchType} id ${MyTargetID}].ID} && ${DPSOn} && ${MeleeOn}) {
				/squelch /target id ${MyTargetID}
				/delay 10 ${Target.ID}==${MyTargetID}
			}
			/if (${DPSOn} && ${MeleeOn} && ${Target.PctHPs}<=${AssistAt}) /nav id ${MyTargetID}
			/call EngageTarget
		}
    /return
| ----------------------------------------------------------------------------
| SUB: Event GotHit - Written by TreeHuginDruid for RedGuides
| ----------------------------------------------------------------------------
    Sub Event_GotHit(string Line, string AttackingMob)
        /declare GotHitDistChk int local 10
		/varset SitToMedTimer ${SitToMedTimer.OriginalValue}
        /varset GotHitToggle 1
        /declare AttackingMobID int local
        |Checkforcombat
        /if (${Pulled} && ${WaitTimer} && ${Select[${Role},pullertank,pullerpettank]} && ${Math.Distance[${Me.Y},${Me.X}:${CampYLoc},${CampXLoc}]}<=${CampRadius}) {
            /if (${NearestSpawn[npc los radius ${CampRadius} targetable].ID}!=${MyTargetID}) {
                /varset MyTargetID 0
                /varset MyTargetName
                /if (${Target.ID}) /squelch /target clear
            }
            /varset WaitTimer 0s
            /echo I got hit by >>${AttackingMob}<< ID: ${AttackingMobID} while waiting for mob.
        }     
        /if (${Select[${Role},pettank,pullerpettank,hunterpettank]}) {   
            /doevents flush GotHit        
            /varset AttackingMobID ${NearestSpawn[npc radius 39 targetable "${AttackingMob}"].ID}
            /squelch /target id ${Spawn[${AttackingMobID}].ID}                         
            /delay 10 ${Target.ID}==${AttackingMobID}            
            |- If mob that hit me still too close, move to camp or away from mob.
            /if (${GotHitToggle} && ${AttackingMobID}>0) {
                /echo I got hit by >>${AttackingMob}<< ID:${AttackingMobID}!
                /moveto dist 10
                /if (${Math.Distance[${Me.Y},${Me.X}:${CampYLoc},${CampXLoc}]}>${CampRadius} && !${Select[${Role},hunterpettank]} && ${ReturnToCamp}) {
                    |- Only move away from mob if MoveWhenHit enabled (1)
                    /if (${MoveWhenHit}) {
                        /echo Moving back to camp!
                        /moveto loc ${CampYLoc} ${CampXLoc}
                    }
                } else {
                    |- If mob is in pet attack range from camp, send pet in.
                    /if (${Me.Pet.ID} && ${Math.Distance[${Target.Y},${Target.X}:${Me.Pet.Y},${Me.Pet.X}]}<=${PetAttackRange}) /pet attack
                    |- Only move away from mob if MoveWhenHit enabled (1)
                    /if (${MoveWhenHit}) {
                        /echo Trying to get away from >>${AttackingMob}<<.
                        /if (${Math.Distance[${Me.Y},${Me.X}:${Target.Y},${Target.X}]}<=${GotHitDistChk}) /moveto loc ${Target.Y} ${Math.Calc[${Target.X}-${GotHitDistChk}]}
                    }
                }
            }
            /if (${MoveWhenHit}) /delay 15 ${Math.Distance[${Me.Y},${Me.X}:${Target.Y},${Target.X}]}>${GotHitDistChk}
            /if (${Target.ID}) /face ${If[${FaceMobOn}==2,nolook,fast nolook]}
            /look 0
        }
        /varset GotHitToggle 0
        /doevents flush GotHit
    /return
| ----------------------------------------------------------------------------
| SUB: Event Zoned
| ----------------------------------------------------------------------------
    Sub Event_Zoned(Message)
        /if (${Message.Find[Drunken Monkey]} || ${Message.Find[effects]}) /return
        /delay 60s ${Me.ID} && ${Zone.ID}
        /if (!${JustZoned}) /echo Just zoned
        /call CombatReset 0 zoned
        /varset JustZoned 200
        /varset CampOnDeathTimer 10m
        /if (${ReturnToCamp} && ${CampZone}!=${Zone.ID}) /varset RememberCamp 1
        /if (${LastZone}!=${Zone.ID}) {
            /if (${Zone.Name.Find[,]} || ${Zone.Name.Find[']}) {
                /varset ZoneName ${Zone.ShortName}${If[${Me.InInstance},_I,]}
            } else {
                /varset ZoneName ${Zone}${If[${Me.InInstance},_I,]}
            }
        }
        /varset LastZone ${Zone.ID}
        | Shut down combat and mez in GH, GL, PoK, PoT, and Abysmal
        /if (${Select[${Zone.ID},345,344,202,203,279]}) {
            /varset DMZ 1
        } else {
            /varset DMZ 0
        }
        /if (${ReturnToCamp} && ${CampZone}!=${Zone.ID}) /varset ReturnToCamp 0
        /if (${RememberCamp} && ${CampZone}==${Zone.ID} && ${Math.Distance[${CampYLoc},${CampXLoc}]}<=100) {
            /varset ReturnToCamp 1
            /varset RememberCamp 0
        }
        /call CombatReset 0 zoned
        /call WinTitle
    /return
| ----------------------------------------------------------------------------
| SUB: Event Joined 20s switch to prevent heals from firing off
| ----------------------------------------------------------------------------
    Sub Event_Joined(string Jmessage,string Joinee)
         /echo ${Joinee} has joined the party.
         /varset JoinedParty 200
    /return
| ----------------------------------------------------------------------------
| SUB: Event Too Close
| ----------------------------------------------------------------------------
    Sub Event_TooClose
        /if (${MyTargetID} && ${AutoFireOn} && ${CombatStart} && ${UseMQ2Melee}) {
            /varset AutoFireOn 0
            /killthis
            /timed 300 /varset AutoFireOn 1
        }
        /if (${Pulling} && ${PullWithAlt.Equal[Melee]}) {
           /echo Mob Too Close for ${PullWith}... Switching to Melee.
           /varset ToClose 1
        }
        /doevents flush TooClose
    /return
| ----------------------------------------------------------------------------
| SUB: Event Camping - end macro
| ----------------------------------------------------------------------------
    Sub Event_Camping        
        /if (${IAmABard} && ${Twist}) {
            /while (${Me.BardSongPlaying}) {
                /if (${DebugFramework}) /Echo Current Line ${Macro.CurLine}
				/if (${Twist}) /squelch /twist off
                /stopsong
                /delay 5
            }
        }
        /endmacro
    /return
| ----------------------------------------------------------------------------
| SUB: Event Too Far
| ----------------------------------------------------------------------------
    Sub Event_TooFar
        /varcalc ZDist ${Math.Distance[${Target.Z}:${Me.Z}]}-(${Target.Height}-${Me.Height})
        /if (${Math.Distance[${Target.Y},${Target.X}:${CampYLoc},${CampXLoc}]}<=${MeleeDistance} && ${MeleeOn} && ${CombatStart}) {
            /if (!${UseMQ2Melee}) {
                /if (${Me.FeetWet}) {
                    /face 
                    /if (!${Me.Moving}) /moveto id ${MyTargetID} mdist ${If[${Target.Distance}>5,${Math.Calc[${MoveTo.ArrivalDist}-5]},1]} uw
                    /delay 10
                    /if (${MainAssist.Equal[${Me}]}) {
                        /squelch /stick ${MoveTo.ArrivalDist} id ${MyTargetID} uw
                    } else {
                        /squelch /stick ${MoveTo.ArrivalDist} id ${MyTargetID} !front moveback uw
                    }
                } else {
                    /if (!${Me.Moving}) /moveto id ${MyTargetID} mdist ${If[${Target.Distance}>5,${Math.Calc[${MoveTo.ArrivalDist}*.90]},1]}
                    /squelch /stick ${MoveTo.ArrivalDist} id ${MyTargetID} ${StickHow}
                }
            } else {
                /face 
                /if (!${Me.Moving}) /moveto id ${MyTargetID} mdist ${If[${Target.Distance}>5,${Math.Calc[${MoveTo.ArrivalDist}-5]},1]} uw
                /delay 10
            }
        }
        /call ZAxisCheck ${ZDist} 4.1
        /if (${Select[${Role},pullertank,pullerpettank,puller]} && ${Pulling}) {
            /varset PullTooFar 1
        }
        /doevents flush TooFar
    /return
| ----------------------------------------------------------------------------
| SUB: Bind Change Var Int resets various interger settings from ini file
| ----------------------------------------------------------------------------
    Sub Bind_ChangeVarInt(ISection, IName, IVar)
        /if (${Debug}) Bind_ChangeVarInt ${ISection} ${IName} ${IVar} \agLine#: ${Macro.CurLine}
        /echo Changing ${IName} to ${IVar}
        /varset ${IName} ${IVar}
        /ini "${IniFileName}" "${ISection}" "${IName}" "${IVar}"
        /if (${IName.Find[mezon]} && !${Defined[MezTimer1]}) /call CreateTimersMez
        /if (${IName.Find[dpson]} && !${Defined[DPSTimer1]}) /call CreateTimersDPS
        /if (${IName.Find[buffson]} && !${Defined[Buffs1Timer0]}) {
            /call CreateTimersBuffs
            /echo Buffs on creating timers
        }
        /if (${IName.Equal[ChaseAssist]} && ${IVar} && ${ReturnToCamp}) {
            |/varset WhoToChase ${MainAssist}
            /ini "${IniFileName}" "General" "ReturnToCamp" "0"
            /varset ReturnToCamp 0
        }
        /if (${IName.Equal[ChaseAssist]} && ${IVar}==0 && ${Stick.Active}) /squelch /stick off
        /if (${IName.Equal[ChaseAssist]} && ${IVar}==1 && !${Stick.Active}) /varset RebuffOn 300
        /if (${IName.Equal[MaxRadius]}) /varcalc CampRadiusExceed ${MaxRadius}+200
    /return
| ----------------------------------------------------------------------------
| SUB: Bind ChaseMe
| ----------------------------------------------------------------------------
    Sub Bind_ChaseMe
        /if (${EQBCOn} && ${Macro.IsTLO[EQBC]}) {
            /bcg //chase on ${Me.CleanName}
        } else {
            /echo ChaseMe command requires MQ2EQBC plugin loaded and EQBCOn flag turned on.
        }
    /return    
| ----------------------------------------------------------------------------
| SUB: Bind StayHere
| ----------------------------------------------------------------------------
    Sub Bind_StayHere
        /if (${EQBCOn} && ${Macro.IsTLO[EQBC]}) {
            /bcg //waithere
        } else {
            /echo Stayhere command requires MQ2EQBC plugin loaded and EQBCOn flag turned on.
        }
    /return    
| ----------------------------------------------------------------------------
| SUB: Bind MakeCampHere
| ----------------------------------------------------------------------------
    Sub Bind_MakeCampHere
        /if (${EQBCOn} && ${Macro.IsTLO[EQBC]}) {
            /bcg //camphere 
        } else {
            /echo Makecamphere command requires MQ2EQBC plugin loaded and EQBCOn flag turned on.
        }
    /return    
| ----------------------------------------------------------------------------
| SUB: Event Task Update - EQBC message
| ----------------------------------------------------------------------------
    Sub Event_TaskUpdate(Line,name)
       /call BroadCast ${EQBCOn} t "Task updated...(${name})"
    /return
| ----------------------------------------------------------------------------
| SUB: Event Gain Something - EQBC message
| ----------------------------------------------------------------------------
    Sub Event_GainSomething(string Line,string text)
        /if (!${EQBCOn}) /return
        /if (${Line.Find["ABILITY POINT!"]}) {
            /call BroadCast ${EQBCOn} w "${Me.Name} gained an AA, now has ${Me.AAPoints} unspent"
        } else /if (${Line.Find[LEVEL]}) {
            /call BroadCast ${EQBCOn} w "${Me.Name} gained a level, now is Level ${Me.Level}"
            /if (${GMailEvents.Find[level]}) /call GmailSend "${Me.Name} gained a level, I am Level ${Me.Level}"
           | Recalculate pull when level gained
            /if (${PullLevel.Find[auto]}) {
               /varcalc PullMin ${Me.Level}-5
               /varcalc PullMax ${Me.Level}+2       
            } 
        } 
    /return
| ----------------------------------------------------------------------------
| SUB: Bind Kiss Edit - Edit ini file in MQ2NotePad
| ----------------------------------------------------------------------------
    Sub Bind_KissE
        /if (!${Bool[${Plugin[MQ2Notepad]}]}) {
            /echo This function requires MQ2Notepad to be loaded..
            /echo 1. Please copy MQUI_NotepadWindow.xml to your Everquest/UIFiles/default or custom ui folder
            /echo 2. then /Plugin MQ2notepad
        }
        /if (${Bool[${Plugin[MQ2Notepad]}]}) {
            /docommand /notepad kissassist_${Me}.ini
        }
    /return
| ----------------------------------------------------------------------------
| SUB: Bind Kiss Check - scan ini file for errors based on nostress KissNamechecker.mac
| ----------------------------------------------------------------------------
    Sub Bind_KissCheck
        /call ScanIni
    /return
| ----------------------------------------------------------------------------
| SUB: Event Invised Mainly to turn off bard twisting while invis.
| ----------------------------------------------------------------------------
    Sub Event_Invised
        /if (${IAmABard} && ${Twist}) {
            /while (${Me.BardSongPlaying}) {
                /if (${DebugFramework}) /Echo Current Line ${Macro.CurLine}
				/if (${Twist}) /squelch /twist off
                /stopsong
                /delay 10
            }
        }
    /return    
| ----------------------------------------------------------------------------
| SUB: Event ImDead
| ----------------------------------------------------------------------------
    Sub Event_ImDead(IDMessage)
        /if (${IAmDead}) /return
        /echo I have died and the Angels wept.
        /if (${GMailEvents.Find[dead]}) /call GmailSend "I have died. EQ Said ${IDMessage} Loc ${Me.X}  ${Me.X}"
        /varset IAmDead 1
        /call CombatReset 0 ImDead
        /doevents flush ImDead
        /if (${IAmABard}) {
            /while (${Me.BardSongPlaying}) {
                /if (${DebugFramework}) /Echo Current Line ${Macro.CurLine}
				/if (${Twist}) /squelch /twist off
                /stopsong
                /delay 10
            }
        }
    /return
| ----------------------------------------------------------------------------
| SUB: Event GoM On
| ----------------------------------------------------------------------------
   Sub Event_GoMOn
        /if (${Select[${Me.Class.ShortName},BRD,BER,MNK,ROG,WAR]} || ${GoMByPass}) {
            /varset GoMByPass 0
            /doevents flush GoMOn
            /doevents flush GoMOff
            /return
        }
        /if (!${CombatStart} || ${GoMTimer}) /return
        | Release timer after trying to cast for 10 secs
        /varset GoMTimer 3s
        /declare i int local
        /declare GoMCast string local
        /declare GoMTarget string  local
        /declare GoMCastStat string ${CastResult}
        /for i 1 to ${GoMSpell.Size}
            /if (!${ConOn} || !${GoMSpell[${i}].Find[|cond]} || ${If[${Cond[${GoMSpell[${i}].Mid[${Math.Calc[${GoMSpell[${i}].Find[|cond]}+5]},3]}]},1,0]}) {
                /varset GoMCast ${GoMSpell[${i}].Arg[1,|]}
                /varset GoMTarget ${GoMSpell[${i}].Arg[2,|]}
                /if (${GoMCast.Equal[null]} || ${GoMCast.Find[spell]} || ${GoMSpellTimer${i}}) /continue
                /echo Gift of Mana detected! Trying to cast ${GoMCast}
                /doevents flush GoMOn
                /if (${GoMTarget.Equal[Mob]} || (${GoMTarget.Equal[NULL]} && ${MyTargetID})) /varset GoMTarget ${MyTargetID} 
                /if (${GoMTarget.Equal[Me]} && ${Me.ID}) /varset GoMTarget ${Me.ID}
                /if (${GoMTarget.Equal[MA]} && ${Spawn[=${MainAssist}].ID}) /varset GoMTarget ${Spawn[=${MainAssist}].ID} 
                /varset GoMActive 1
                /if (${GoMTarget.Equal[${MyTargetID}]} && (${Target.Type.Equal[Corpse]} || !${Spawn[id ${MyTargetID}].ID})) {
                    /if (${Debug}) /echo \atDEBUG Event_GoMOn [GoM] skipping because mob is dead or a corpse. \agLine#: ${Macro.CurLine}
                    /echo [GoM] being skipped, because target (${GoMTarget}) is a corpse.
                    /varset GoMTimer 0
                    /delay 10                        
                    /doevents GoMOff
                    /return
                }
                | Wait for global cooldown if active
                /while (${Me.SpellInCooldown}) {
                    /if (${DebugFramework}) /Echo Current Line ${Macro.CurLine}
					/if (${MeleeOn}) {
                        /if (${WeaveArray.Size}>0 && ${WeaveArray[1].NotEqual[null]}) /call CastWeave ${MyTargetID}
                        /if (${MashArray.Size}>0 && ${MashArray[1].NotEqual[null]}) /call MashButtons
                    } else {
                        /delay 2
                    }
                }
                /if (${Me.SpellReady[${GoMCast}]}) {
                    /call CastWhat "${GoMCast}" ${GoMTarget} GoM 0
                } else {
                    /echo "${GoMCast}" is not ready!
                    /delay 10
                }
                /if (${Debug}) /echo Return: ${Macro.Return} \agLine#: ${Macro.CurLine}
                /if (${Macro.Return.Equal[CAST_SUCCESS]}) {
                    /echo Gift of Mana Casting >> ${GoMCast} << 
                    /varset GoMTimer 0
                    /varset GoMSpellTimer${i} (${Spell[${GoMCast}].Duration.TotalSeconds}*${DurationMod})*10
                    /doevents flush GoMOn
                    /delay 10
                    /doevents GoMOff
                    /varset CastResult ${GoMCastStat}
                    /return
                } else /if (${Macro.Return.Equal[CAST_CANCELLED]}) {
                    /varset CastResult CAST_CANCELLED
                    /return
                }
                :NextGOM
            }
        /next i
        /varset CastResult ${GoMCastStat}
    /return
| ----------------------------------------------------------------------------
| SUB: Event GoM Off
| ----------------------------------------------------------------------------
    Sub Event_GoMOff
        /varset GoMActive 0
    /return
| ----------------------------------------------------------------------------
| SUB: Event GUEQBC - Echo guild meassages in EQBC
| ----------------------------------------------------------------------------
    Sub Event_GUEQBC(Message,GUName,GUText)
        /if (${GUName.Equal[${Me.CleanName}]}) /return
        /if (${Macro.IsTLO[EQBC]}) {
            /if (${EQBC.Connected} && ${Select[${EQBCOn},2,4]}) /call BroadCast ${EQBCOn} p "${GUName} tells Guild: ${GUText} "
        }
    /return
| ----------------------------------------------------------------------------
| SUB: Event GUEQBC - Echo fellowship meassages in EQBC
| ----------------------------------------------------------------------------
    Sub Event_FSEQBC(Message,FSName,FSText)
        /if (${FSName.Equal[${Me.CleanName}]}) /return
        /if (${Macro.IsTLO[EQBC]}) {
            /if (${EQBC.Connected} && ${Select[${EQBCOn},3,4]}) /call BroadCast ${EQBCOn} p "${FSName} tells Fellowship: ${FSText} "
        }
    /return
| ----------------------------------------------------------------------------
| SUB: Event EQBCIRC - Pick up commands from MQ2IRC or MQ2EQBC(todo)
| ----------------------------------------------------------------------------
   Sub Event_EQBCIRC(EIMessage,EISender,EICommand)
    /if (${EICommand.Left[1].Equal[/]} && ${EICommand.Left[2].NotEqual[/]}) /docommand ${EICommand}
    /doevents flush EQBCIRC
   /return
| ----------------------------------------------------------------------------
| SUB: Event EQBCIRC - Pick up commands from MQ2IRC or MQ2EQBC(todo)
| ----------------------------------------------------------------------------
   Sub Event_TwistOff
    /varset TwistHold 1
    /doevents flush TwistOff
    /echo Twist is now on hold. Use /twist to restart.
   /return  
| ----------------------------------------------------------------------------
| SUB: Event EQBCIRC - Pick up commands from MQ2IRC or MQ2EQBC(todo)
| ----------------------------------------------------------------------------
   Sub Event_TwistOn
    /varset TwistHold 0
    /doevents flush TwistOff
    /echo Twist is now resuming
   /return      
| ----------------------------------------------------------------------------
| SUB: AFK Tools from AHTools by Anonymous Hero
| ----------------------------------------------------------------------------
    Sub AFKTools
    /declare holding bool local
    /if (${CampZone}!=${Zone.ID} || (${HealsOn} && ${AggroTargetID}) ) /return
    /if (${Select[${AFKToolsOn},1,2]}) {
        /if (${Macro.IsTLO[Posse]}) {
            /while (${Posse.Strangers}>=1) {
                /if (${DebugFramework}) /Echo Current Line ${Macro.CurLine}
				/if (!${holding}) {
                    /echo [AHTools] Macro on hold due to player activity in camp radius.
                    /call BroadCast ${EQBCOn} r "**PCS DETECTED IN CAMP RADIUS**"
                    /multiline ; /beep ; /timed 1 /beep ; /timed 1 /beep ; /timed 5 /beep ; /timed 5 /beep ; /timed 5 /beep ; /timed 5 /beep ; /timed 1 /beep ; /timed 1 /beep
                    /varset holding 1
                }
                /delay 1s
                |CheckForCombat
				/if (${Me.XTarget[1].ID} && ${SpawnCount[npc radius ${MeleeDistance} zradius 15 targetable playerstate 4]}) /return
                /doevents
            }
        } else { 
            /varset holding 0 
        }
    }
    /if (${Select[${AFKToolsOn},1,3]}) {
        /if (${GMailEvents.Find[GM]} && ${SpawnCount[GM]}>=1) /call GmailSend "GM in Zone, ${Zone.ShortName}" 
        /if (${SpawnCount[GM]}>=1) {
            /if (${AFKGMAction}==1) {
                /while (${SpawnCount[GM]}>=1) {
                    /if (${DebugFramework}) /Echo Current Line ${Macro.CurLine}
					/if (!${holding}) {
                        /echo [AHTools] Macro on hold due to GM Presence
                        /call BroadCast ${EQBCOn} r "** GM DETECTED **"
                        /multiline ; /beep ; /timed 1 /beep ; /timed 1 /beep ; /timed 5 /beep ; /timed 5 /beep ; /timed 5 /beep ; /timed 5 /beep ; /timed 1 /beep ; /timed 1 /beep
                        /varset holding 1
                    }
                }
            } else {
                /varset holding 0
            }
            /if (${AFKGMAction}==2) /multiline ; /echo [AHTools] Ending Macro due to GM Presence ; /mq2log [AHTools] Ending Macro due to GM Presence ; /endmacro
            /if (${AFKGMAction}==3) /multiline ; /echo [AHTools] Unloading MQ2 due to GM Presence; /mq2log [AHTools] Unloading MQ2 due to GM Presence ; /unload
            /if (${AFKGMAction}==4) /multiline ; /echo [AHTools] Quitting out of EQ due to GM Presence ; /mq2log [AHTools] Quitting out of EQ due to GM Presence ; /quit
        }
    }
   /return
| ----------------------------------------------------------------------------
| SUB: BuffGroup 
| ----------------------------------------------------------------------------
    Sub Bind_BuffGroup(int Flag1)
        /if (!${Flag1}) {
            /if (${EQBCOn} && ${Macro.IsTLO[EQBC]}) {
                /bcg //buffgroup 1
            } else {
                /echo BuffGroup Command requires MQ2EQBC Plugin to be loaded and EQBCOn turned on.
            }
        }
        /if (${BuffsOn}) {
            /varset ReadBuffsTimer 0
            /varset IniNextTimer 0
            /call CheckBuffs 1
        }
    /return
| ----------------------------------------------------------------------------
| SUB: Burn Section for new bind
| ----------------------------------------------------------------------------
    Sub Bind_Burn
        /call Event_Burn
    /return
| ----------------------------------------------------------------------------
| SUB: Burn Section
| ----------------------------------------------------------------------------
    Sub Event_Burn
        /if (${IAmDead} || ${Me.Hovering} || ${CampZone}!=${Zone.ID} || ${BurnText.Equal[null]} || !${BurnText.Length}) {
            /doevents flush Burn
            /return
        }
        /declare i int local
        /declare BurnSpell string local
        /declare BurnTarget string local
        /declare BurnTargetID int local
        /declare BurnThisArg3 string local
        /call BroadCast ${EQBCOn} r "BURN ACTIVATED => Autobots Transform <="
        /if (${UseTribute} && !${Me.TributeActive}) {
           /squelch /tribute personal on
           /varset TributeTimer 570s
        }
        /for i 1 to ${Burn.Size}
            /if (${Bool[${Burn[${i}].Arg[2,|]}]}) {
                /varset BurnSpell ${Burn[${i}].Arg[1,|]}
                /varset BurnTarget ${Burn[${i}].Arg[2,|]}
            } else {
                /varset BurnSpell ${Burn[${i}]}
                /varset BurnTarget
            }
            /if (${BurnSpell.Equal[null]} || ${Me.Hovering}) /continue
            /if (!${Bool[${Burn[${i}].Arg[2,|]}]} || ${BurnTarget.Equal[Mob]}) /varset BurnTargetID ${MyTargetID}
            /if (${BurnTarget.Equal[Me]}) /varset BurnTargetID ${Me.ID}
            /if (${BurnTarget.Equal[MA]}) /varset BurnTargetID ${Spawn[=${MainAssist}].ID}
            /if (${BurnTarget.Equal[Pet]}) /varset BurnTargetID ${Me.Pet.ID}
            /if (${ConOn} && ${Burn[${i}].Find[|cond]} && ${If[${Cond[${Burn[${i}].Mid[${Math.Calc[${Burn[${i}].Find[|cond]}+5]},3]}]},0,1]}) /continue
            /call CastWhat "${BurnSpell}" ${BurnTargetID} Burn 0
            /if (${Macro.Return.Equal[CAST_SUCCESS]}) {
                /echo Casting >> BURN${i}:${BurnSpell}
                /delay 5
            }
        /next i
        /doevents flush Burn
    /return
| ----------------------------------------------------------------------------
| SUB: Campfire Section -  Code from toomanynames, wizbomb
| ----------------------------------------------------------------------------
    Sub Event_TooSteep
        /varset CampfireOn 0
        /echo Setting CampfireOn to 0. You are on a hill.
    /return
| ----------------------------------------------------------------------------
| SUB: Campfire Section -  OriginalCode from toomanynames, wizbomb
| ----------------------------------------------------------------------------
    Sub Bind_Campfire
    /if (${Select[${Zone.ID},33506]}) /return
        /if (${ReturnToCamp} && ${Math.Distance[${CampYLoc},${CampXLoc}]}>=10) {
            /if (${Me.FeetWet}) {
                /moveto set useback off
                /moveto loc ${CampYLoc} ${CampXLoc} ${CampZLoc} uw mdist 10
            } else {
                /moveto set useback on
                /moveto loc ${CampYLoc} ${CampXLoc} ${CampZLoc} mdist 5
            }
            /delay 10
        }
        /delay 50 !${MoveTo.Moving}
        /if (${MoveTo.Moving}) /moveto off
        /windowstate FellowshipWnd open
        /delay 10
        /nomodkey /notify FellowshipWnd FP_Subwindows tabselect 2
        /if (!${Select[${Me.Fellowship.CampfireZone.ID},${Zone.ID}]}) {
            /nomodkey /notify FellowshipWnd FP_DestroyCampsite leftmouseup
            /delay 5s ${Window[ConfirmationDialogBox].Open}
            /if (${Window[ConfirmationDialogBox].Open}) {
                /nomodkey /notify ConfirmationDialogBox Yes_Button leftmouseup
            }
            /delay 5s !${Me.Fellowship.Campfire}
        }
        /delay 1s
        /nomodkey /notify FellowshipWnd FP_RefreshList leftmouseup
        /delay 1s        
        /nomodkey /notify FellowshipWnd FP_CampsiteKitList listselect 1
        /delay 1s
        /nomodkey /notify FellowshipWnd FP_CreateCampsite leftmouseup
        /delay 5s ${Me.Fellowship.Campfire}
        /windowstate FellowshipWnd close
        /if (${Me.Fellowship.Campfire}) /echo Campfire Dropped
    /return
| ----------------------------------------------------------------------------
| SUB: Sort Array
| ----------------------------------------------------------------------------
    Sub SortArray(ArrayName, HiLo, SortHow)
    /if (${Debug}) /echo \atDEBUG SortArray Enter ${ArrayName} ${HiLo} ${SortHow} \agLine#: ${Macro.CurLine}
        /declare i                  int     local
        /declare j                  int     local
        /declare k                  int     local
        /declare l                  int     local
        /declare m                  int     local
        /declare TempSortedName     string  local ${HiLo}
        /declare TempPos            int     local 0
        /declare NewArrayPos        int     local 0
        /declare NewArraySize       int     local 0
        /declare TempArray[${${ArrayName}.Size}] string     local 0
        /declare TArray2[${${ArrayName}.Size}]   string     local 0
        /declare CArray[${${ArrayName}.Size}]    string     local TRUE
        /declare MArrayCount int    local 1
        /declare WArrayCount int    local 1
        /declare BArrayCount int    local 1
        /declare TempSwapHold       string  local
        /declare Swapped            int     local 1
        | Assign Array to temp array
        /for i 1 to ${${ArrayName}.Size}
            /if (${Debug}) /echo ${i} ${${ArrayName}[${i}]} \agLine#: ${Macro.CurLine}
            /varset TempArray[${i}] ${${ArrayName}[${i}]}
        /next i
        /if (${ArrayName.Equal[dps]}) {
            /for i 1 to ${TempArray.Size}
                /if (${TempArray[${i}].Find[|weave]} && ${TempArray[${i}].Arg[2,|].NotEqual[0]}) {
                    /varset WeaveArray[${WArrayCount}] ${TempArray[${i}].Replace[|weave,]}
                    /if (${Debug}) /echo ${WeaveArray[${WArrayCount}]}
                    /if (${WArrayCount}>1) /varset TempArray[${i}] NULL
                    /varcalc WArrayCount ${WArrayCount}+1
                } else /if (${TempArray[${i}].Find[|mash]} && ${TempArray[${i}].Arg[2,|].NotEqual[0]}) {
                    /varset MashArray[${MArrayCount}] ${TempArray[${i}].Replace[|mash,]}
                    /if (${Debug}) /echo ${MashArray[${MArrayCount}]}
                    /if (${MArrayCount}>1) /varset TempArray[${i}] NULL
                    /varcalc MArrayCount ${MArrayCount}+1
                } else /if (${TempArray[${i}].Find[|ambush]} && ${TempArray[${i}].Arg[2,|].NotEqual[0]}) {
                    /varset BeforeArray[${BArrayCount}] ${TempArray[${i}].Replace[|ambush,]}
                    /if (${Debug}) /echo ${BeforeArray[${BArrayCount}]}
                    /if (${BArrayCount}>1) /varset TempArray[${i}] NULL
                    /varcalc BArrayCount ${BArrayCount}+1
                } 
            /next i
        }
        | Move Array to Temp Array leaving out useless entries.
        /for m 1 to ${${ArrayName}.Size}
            /if (${TempArray[${m}].Length} && !${TempArray[${m}].Find[|0]} && ${TempArray[${m}].NotEqual[null]}) {
                /varcalc NewArrayPos ${NewArrayPos}+1
                /varset TArray2[${NewArrayPos}] ${TempArray[${m}]}
                /varcalc NewArraySize ${NewArraySize}+1
            }
        /next m
        |Sort the Array if needed
        /if (!${Select[${ArrayName},Buffs,Burn,Aggro]} && ${NewArraySize}>1) {
            /varset m ${NewArraySize}
            /while (${Swapped} && ${m}>1) {
                /if (${DebugFramework}) /Echo Current Line ${Macro.CurLine}
				/varset Swapped 0
                /for k 2 to ${m}
                    /varcalc j ${k}-1
                    /if (${TArray2[${j}].Arg[2,|]} ${SortHow} ${TArray2[${k}].Arg[2,|]}) {
                        /varset TempSwapHold ${TArray2[${j}]}
                        /varset TArray2[${j}] ${TArray2[${k}]}
                        /varset TArray2[${k}] ${TempSwapHold}
                        /varset Swapped 1
                    }
                /next k
                /varcalc m ${m}-1
            }
        }
        | Bail if array is empty and turn off switch
        /if (!${NewArraySize}) {
            /if (${Defined[${ArrayName}On]}) {
                /varset ${ArrayName}On 0
                /echo ERROR: ${ArrayName}On=1 but section is empty. Turning ${ArrayName} off. Please check your ini file.
                /beep
                /delay 20
            }
            /return
        }
        /deletevar ${ArrayName}
        /declare ${ArrayName}[${NewArraySize}] string outer
        /for l 1 to ${NewArraySize}
            /varset ${ArrayName}[${l}] ${TArray2[${l}]}
            /if (${Debug}) /echo  ${${ArrayName}[${l}]} \agLine#: ${Macro.CurLine}
        /next l
        /if (${ArrayName.Equal[buffs]}) /call CreateTimersBuffs
        /if (${ArrayName.Equal[dps]}) /call CreateTimersDPS
        /if (${Debug}) /echo ${${ArrayName}.Size} \agLine#: ${Macro.CurLine}
        /if (${Debug}) /echo \atDEBUG SortArray Leave \agLine#: ${Macro.CurLine}   
    /return
| ----------------------------------------------------------------------------
| SUB: Create Timers DPS
| ----------------------------------------------------------------------------
    Sub CreateTimersDPS    
        | Declare timers for DPS duration spells and Attack buffs
        /declare i int local
        /varset DebuffCount 0
        /for i 1 to ${DPS.Size}
            /if (${Int[${DPS[${i}].Arg[2,|]}]}<101) { 
                /declare DPSTimer${i}       timer         outer 5
                /declare ABTimer${i}        timer         outer 0
                /declare FDTimer${i}        timer         outer 0
            } else {
                /declare DBOTimer${i}       timer         outer 0
                /declare DBOList${i}        string        outer 
                /varcalc DebuffCount ${DebuffCount}+1
            }
        /next i
    /return    
| ----------------------------------------------------------------------------
| SUB: Assign single heals - seperate single heals from group heals
| ---------------------------------------------------------------------------
    Sub FindSingleHeals
        /if (${Debug}) /echo Enter FindSingleHeals \agLine#: ${Macro.CurLine}
        /declare i int local
        /declare j int local
        /declare SHCount int 0
        /declare HealHighPoint int  local 0
        /declare HealHighestPoint int  local 0
        /declare HealHighestPointMA int  local 0
        /declare HealPointTag string  local 0
        /declare HealSpell string  local
        /for i 1 to ${Heals.Size}
            /varset HealSpell ${Heals[${i}].Arg[1,|]}
            /varset HealPointTag ${Heals[${i}].Arg[3,|]}
            /if (${HealPointTag.Equal[MA]}) {
                /varset HealHighestPointMA ${Heals[${i}].Arg[2,|]}
            } else {
                /varset HealHighPoint ${Heals[${i}].Arg[2,|]}                
            }
            /if (${Debug}) /echo ${i} ${HealSpell} ${Spell[${HealSpell}].TargetType} ${Select[${Spell[${HealSpell}].TargetType},SingleHeal,Self]} \agLine#: ${Macro.CurLine}
            /if (${HealSpell.Find[Aegis of Superior Divinity]} || ${HealSpell.Find[Harmony of the Soul]} || ${HealSpell.Find[Burst of Life]} || ${HealSpell.Find[Focused Celestial Regeneration]}) {
                /varcalc SHCount ${SHCount}+1
                /varset SingleHeal[${SHCount}] ${Heals[${i}]}
            } else /if (${Select[${Me.Class.Name},Druid,Shaman]} && (${HealSpell.Find[Intervention]} || ${HealSpell.Find[Survival]})) {
                /varcalc SHCount ${SHCount}+1
                /varset SingleHeal[${SHCount}] ${Heals[${i}]}
            } else /if (${Select[${Spell[${HealSpell}].TargetType},Single,Self]} || ${Spell[${FindItem[=${HealSpell}].Spell}].TargetType.Find[single]} || ${Spell[${FindItem[=${HealSpell}].Spell}].TargetType.Find[self]} || ${Heals[${i}].Arg[3,|].Find[tap]} || ${Heals[${i}].Arg[3,|].Find[pet]} || ${Spell[${HealSpell}].TargetType.Find[Targeted AE]} && ${Select[${Heals[${i}].Arg[3,|]},MA,ME,pet]}) {
                /varcalc SHCount ${SHCount}+1
                /varset SingleHeal[${SHCount}] ${Heals[${i}]}
            } else /if (${Spell[${HealSpell}].TargetType.Equal[Free Target]}) {
                /varcalc SHCount ${SHCount}+1
                /varset SingleHeal[${SHCount}] ${Heals[${i}]}
            }
            /if (${HealPointTag.NotEqual[MA]} && ${HealHighPoint}>${SingleHealPoint}) /varset SingleHealPoint ${HealHighPoint}
            /if (${HealPointTag.Equal[MA]} && ${HealHighestPointMA}>${SingleHealPointMA}) /varset SingleHealPointMA ${HealHighestPointMA}
            /if (${Debug}) /echo ${SingleHealPoint} \agLine#: ${Macro.CurLine}
        /next i
        /if (${SHCount}) /call SortArray SingleHeal 100|100 >    
        /if (!${SingleHealPoint}) /varset SingleHealPoint 99
        /if (!${SingleHealPointMA}) /varset SingleHealPointMA ${SingleHealPoint}
        /for j 1 to ${SingleHeal.Size}
            /if (${Debug}) /echo ${j} ${SingleHeal[${j}]} ${Spell[${SingleHeal[${j}].Arg[1,|]}].CastTime.Float} ${Spell[${SingleHeal[${j}].Arg[1,|]}].Duration} \agLine#: ${Macro.CurLine}
        /next j 
        /if (${Debug}) /echo Leave FindSingleHeals \agLine#: ${Macro.CurLine}
    /return    
| ----------------------------------------------------------------------------
| SUB: Assign Group heals
| ---------------------------------------------------------------------------
    Sub FindGroupHeals
        /if (!${Select[${Me.Class.ShortName},BST,CLR,SHM,DRU,PAL]}) /return
        /if (${Debug}) /echo Enter FindGroupHeals \agLine#: ${Macro.CurLine}
        /declare i int local
        /declare j int local
        /declare GHCount int 0
        /declare HealSpell string  local
        /for i 1 to ${Heals.Size}
            /varset HealSpell ${Heals[${i}].Arg[1,|]}    
            /if (${Debug}) /echo ${HealSpell} \agLine#: ${Macro.CurLine}
            /if (!${HealSpell.Length} || ${HealSpell.Equal[null]} || ${Select[${Spell[${HealSpell}].TargetType},Single,Self]} || ${Spell[${FindItem[=${HealSpell}].Spell}].TargetType.Find[self]} || ${HealSpell.Find[Aegis of Superior Divinity]} || ${HealSpell.Find[Harmony of the Soul]}) /continue
            /if (${HealSpell.Find[Burst of Life]} || ${HealSpell.Find[Focused Celestial Regeneration]}) /continue
            /if (${Me.Class.Name.Equal[Shaman]} && ${Spell[${HealSpell}].Name.Find[Intervention]} || ${Me.Class.Name.Equal[Druid]} && ${Spell[${HealSpell}].Name.Find[Survival]}) /continue
            /if (${Spell[${HealSpell}].TargetType.Find[group v]} || ${Spell[${FindItem[=${HealSpell}].Spell}].TargetType.Find[group v]} || ${Spell[${HealSpell}].TargetType.Find[Targeted AE]} && !${Select[${Heals[${i}].Arg[3,|]},MA,ME]}) {
                /varcalc GHCount ${GHCount}+1
                /varset GroupHeal[${GHCount}] ${Heals[${i}]}
            }
        /next i
        /if (${Debug}) /echo ${GHCount} \agLine#: ${Macro.CurLine}
        /if (${GHCount}) {
            /call SortArray GroupHeal 100|100 >    
            /for j 1 to ${GroupHeal.Size}
                /if (${Debug}) /echo ${j} ${GroupHeal[${j}]} ${Spell[${GroupHeal[${j}].Arg[1,|]}].CastTime.Float} ${Spell[${GroupHeal[${j}].Arg[1,|]}].Duration} \agLine#: ${Macro.CurLine}
            /next j 
        }
        /if (${Debug}) /echo Leave FindGroupHeals \agLine#: ${Macro.CurLine}
    /return    
| ----------------------------------------------------------------------------
| SUB: Create Timers Heals
| ----------------------------------------------------------------------------
    Sub CreateTimersHeals    
        | Declare timers for Heal duration spells
        /declare j int local
        /declare k int local
        /declare q int local
        /for j 1 to ${GroupHeal.Size}
            | Group Heal duration timers
            /declare SpellGH${j}    timer   outer   0
        /next j
        /for j 1 to ${SingleHeal.Size}
            /for k 0 to 13
                | Self and MA duration heal timers for  out of group including Pets.
                /declare Spell${j}GM${k}     timer   outer   0
                /if (${Debug}) /echo \atDEBUG Group heal Timers Spell${j}GM${k} ${Spell${j}GM${k}} \agLine#: ${Macro.CurLine}
            /next k
        /next j
       | Declare timers for Pet heals
        /for q 1 to ${SingleHeal.Size}
            /declare PetHealTimer${q} timer outer 0
        /next q
        /for j 1 to ${SingleHeal.Size}
            /for k 0 to ${XSlotTotal}
                | XTarget Timers.
                /declare Spell${j}XT${k}     timer   outer   0
                /if (${Debug}) /echo \atDEBUG XTarget heal Timers Spell${j}XT${k} ${Spell${j}XT${k}} \agLine#: ${Macro.CurLine}
            /next k
        /next j
        
    /return
| ----------------------------------------------------------------------------
| SUB: Create Timers Rez
| ----------------------------------------------------------------------------        
    Sub CreateTimersRez    
        | Declare timers for Rez duration spells
        /declare m int local
        /for m 1 to 5
            /declare BattleRezTimer${m} timer outer 0
        /next m
    /return
| ----------------------------------------------------------------------------
| SUB: Create Timers Mez
| ----------------------------------------------------------------------------    
    Sub CreateTimersMez
        | Declare timers for mezzing
        /if (${Select[${Me.Class.ShortName},BRD,ENC,NEC]}) {
            /declare l int local
            /for l 1 to 30
                /declare MezTimer${l} timer outer 0
                /declare MMTimer${l} timer outer 0
            /next l
        }
    /return
| ----------------------------------------------------------------------------
| SUB: Creat Timers Buffs
| ----------------------------------------------------------------------------
    Sub CreateTimersBuffs
        | Declare timers for Buff duration spells
        /declare o int local
        /declare p int local
        | Create buff timer for all buff in array
        /for o 1 to ${Buffs.Size}
           | Create timers for everyone in group plus 2 extra for MA buffs
            /for p 0 to 7
                /declare Buff${o}GM${p}     timer   outer   0
                /if (${Debug}) {
                    /echo \atDEBUG Buff Timers:Buff${o}GM${p} ${Buff${o}GM${p}} \agLine#: ${Macro.CurLine}
                    /delay 1
                }
            /next p
        /next o
    /return
| ----------------------------------------------------------------------------
| SUB: Create Timers GoM
| ----------------------------------------------------------------------------        
    Sub CreateTimersGoM    
        | Declare timers for Rez duration spells
        /declare i int local
        /for i 1 to ${GoMSpell.Size}
            /declare GoMSpellTimer${i} timer outer 0
        /next i
    /return    
| ----------------------------------------------------------------------------
| SUB: ZCheck /call ZAxisCheck current ,Z to check, difference
| ----------------------------------------------------------------------------
    Sub ZAxisCheck(float Zcur, float Zdiff)
        | Move down if Z distance more than Zcheck due to levitation
        /if (${Debug}) /echo \atDEBUG ZCheck ZCur: ${Zcur} ZDiff: ${Zdiff} Enter. \agLine#: ${Macro.CurLine}
        /if (${Zcur}>=${Zdiff}) {
            /keypress CMD_MOVE_DOWN hold
            /delay 10 ${Math.Distance[${CampZLoc}:${Me.Z}]}<=${Zdiff}
            /keypress CMD_MOVE_DOWN
        }
        /if (${Debug}) /echo \atDEBUG ZCheck ZCur: ${Zcur} ZDiff: ${Zdiff} leave. \agLine#: ${Macro.CurLine}
    /return
| ----------------------------------------------------------------------------
| SUB: Event_PTaunt 
| ----------------------------------------------------------------------------
    Sub Event_PTaunt
        /varset PetTauntOn 1
    /return
| ----------------------------------------------------------------------------
| SUB: Event_WornOff - secondary check to rebuff
| ----------------------------------------------------------------------------
    Sub Event_WornOff(string Line, string wospell, string wotarget)
        /if (!${RebuffOn}) /return
        /if (${wotarget.Equal[${Me}]}) /return
        /if (${AggroTargetID}) /return
        /if (${Me.Class.Name.Find[bard]}) /return
        /if (${wospell.Find[promised]}) /return
        /if (${DebugBuffs}) /echo \atDEBUGBUFFS Event_WornOff Enter ${wospell} ${wotarget} \agLine#: ${Macro.CurLine}
        /declare i int local
        /declare j int local
        /declare WOSpellTT string local 0
        /declare WOTries int local 0
        /if (${Me.Book[${wospell}]}) {
            /varset WOSpellTT ${Spell[${Me.Book[${Me.Book[${wospell}]}].ID}].TargetType}
        } else {
            /varset WOSpellTT ${Spell[${wospell}].TargetType}
        }
        /for i 1 to ${Buffs.Size}
            /for j 1 to 5
                /if (${Group.Member[${j}].CleanName.Equal[${wotarget}]} && ${Buffs[${i}].Find[${wospell}]}) {
                    /varset Buff${i}GM${j} 0
                    /echo ${wotarget} needs ${wospell} because it wore off.
                    :MakeSureCO
                    /if (${WOTries}>5) /break
                    /if (${Select[${WOSpellTT},single,group]} && ${Me.Buff[${wospell}].ID})  {
                        /if (${Select[${EverQuest.Server},fippy,vulak,ragefire,lockjaw]}==0) /removebuff "${wospell}"
                        | reset spell timer on caster
                        /varset Buff${i}GM0 0
                        /varcalc WOTries ${WOTries}+1
                        /if (${Me.Buff[${wospell}].ID}) {
                              /if (${DebugBuffs}) /echo Spell: ${WOSpellTT} Slot: ${Me.Buff[${wospell}].ID} Buff: ${i} GM: ${j}
                            /goto :MakeSureCO
                        }
                    }
                }
            /next j
            /if (${WOTries}>5) /break
            | If MA out of group listen for buffs wearinig off
            /if (!${Spawn[${MainAssist} ${MainAssistType} group].ID} && ${Spawn[=${MainAssist}].CleanName.Equal[${wotarget}]} && ${Buffs[${i}].Find[${wospell}]}) {
                /varset Buff${i}GM7 0
                /echo ${wotarget} needs ${wospell} because it wore off.
            }
        /next i
        /varset ReadBuffsTimer 0
        /if (${IniNextTimer}) /varset IniNextTimer 0
         /if (${DebugBuffs}) /echo \atDEBUGBUFFS Event_WornOff Leave \agLine#: ${Macro.CurLine}
    /return
|-----------------------------------------------------------------------------  
| SUB: Capture Tells  
| ----------------------------------------------------------------------------      
    Sub Event_YouGotTell(Message, Fwho, Swhat)
        /if (${GMailEvents.Find[tells]}) {
            | The Fwho.Equal[${Me.CleanName}'s pet] does NOT work, so I split it to 2 Finds and this works.
            /if ((${Me.Pet.ID} && ${Spawn[${Fwho}].ID}==${Me.Pet.ID}) || (${Fwho.Find[${Me.CleanName}]} && ${Fwho.Find[s pet]}) ) /return
            /if (!${Me.Pet.ID} && ${Swhat.Find[, master.]} && ${Swhat.Find[I am unable to wake an]}) /return
            /if (${Select[${Spawn[${Fwho}].Type},NPC,PET]}) /return
            /echo ====> ${Fwho} Sent you a Tell: ${Swhat} <====
            /call GmailSend "You Got Tell From ${Fwho}, ${Swhat}"
        } else {
            /doevents flush YouGotTell
        }
    /return
| ----------------------------------------------------------------------------
| SUB: Write Buffs Merc state 4 = no gold membership
| ----------------------------------------------------------------------------
    Sub WriteBuffsMerc  
        /if (!${Spawn[mercenary ${Group.Member[1].ID}].ID}) /return
        /if (${WriteBuffsMercTimer}) /return
        /if (!${Redguides}) /return
        /if (${AggroTargetID}) /return
        /if (${DebugBuffs}) /echo \atDEBUGBUFFS WriteBuffsmerc Enter \agLine#: ${Macro.CurLine}
        /declare i int local 0
        /declare k int local 0
        /declare BuffList string local
        /declare Writebufflist string local
        /call CleanBuffsFile
        | Write day of the month and hour. Entry will be deleted if more than a hour old
        /if (!${Ini[framework/${MacroName}_Buffs.ini,${Spawn[mercenary ${MyMerc}].ID},Day].Length}) /ini framework/${MacroName}_Buffs.ini "${Spawn[mercenary ${MyMerc}].ID}" Day "${Time.Day}"
        /if (!${Ini[framework/${MacroName}_Buffs.ini,${Spawn[mercenary ${MyMerc}].ID},Hour].Length}) /ini framework/${MacroName}_Buffs.ini "${Spawn[mercenary ${MyMerc}].ID}" Hour "${Time.Hour}"
        /if (!${Ini[framework/${MacroName}_Buffs.ini,${Spawn[mercenary ${MyMerc}].ID},Zone].Length}) /ini framework/${MacroName}_Buffs.ini "${Spawn[mercenary ${MyMerc}].ID}" Zone "${Zone.ID}"
        /if (!${Ini[framework/${MacroName}_Buffs.ini,${Spawn[mercenary ${MyMerc}].ID},Buffs].Length}) /ini framework/${MacroName}_Buffs.ini "${Spawn[mercenary ${MyMerc}].ID}" Buffs
        | Write all current buffs to Kissassist_Buffs.ini file
        /target id ${Spawn[mercenary ${MyMerc}].ID}
        /delay 20
        /for i 1 to 15
            /if (${DebugBuffs}) /echo \atDEBUGBUFFS WriteBuffsMerc ${i} ${Target.Buff[${i}]} \agLine#: ${Macro.CurLine}
            /if (${Target.Buff[${i}].Name.Length}) {
                /varset BuffList ${Target.Buff[${i}]}
            } else {
                /varset BuffList
            }
            /if (${BuffList.Length}) {
                /if (${DebugBuffs}) /echo \atDEBUGBUFFS WriteBuffsMerc: ${i}-${BuffList} \agLine#: ${Macro.CurLine}
                /varset Writebufflist ${Writebufflist}|${BuffList}
            }
        /next i
        /ini framework/${MacroName}_Buffs.ini "${Spawn[mercenary ${MyMerc}].ID}" Buffs "${Writebufflist}"
        /delay 15
        /varset WriteBuffsMercTimer 30s
        /if (${DebugBuffs}) /echo \atDEBUGBUFFS WriteBuffsMerc Leave \agLine#: ${Macro.CurLine}
    /return
| ----------------------------------------------------------------------------
| SUB: Write Buffs Pet
| ----------------------------------------------------------------------------
    Sub WriteBuffsPet
        /if (!${Me.Pet.ID}) /return
        /if (${AggroTargetID}) /return        
        /if (!${Select[${Role},pettank,pullerpettank]} && ${Spawn[${MainAssist} ${MainAssistType}].ID}!=${Me.Pet.ID}) /return
        /if (${WriteBuffsPetTimer}) /return
        /if (!${Redguides}) /return
        /if (${DebugBuffs}) /echo \atDEBUGBUFFS WriteBuffPet Enter \agLine#: ${Macro.CurLine}
        /declare i int local 0
        /declare k int local 0
        /declare Blockedbuff string local
        /declare Blockedbufflist string local
        /declare BuffList string local
        /declare Writebufflist string local
        /call CleanBuffsFile
        | Write day of the month and hour. Entry will be deleted if more than a hour old
        /if (!${Ini[framework/${MacroName}_Buffs.ini,${Me.Pet.ID},Day].Length}) /ini framework/${MacroName}_Buffs.ini "${Me.Pet.ID}" Day "${Time.Day}"
        /if (!${Ini[framework/${MacroName}_Buffs.ini,${Me.Pet.ID},Hour].Length}) /ini framework/${MacroName}_Buffs.ini "${Me.Pet.ID}" Hour "${Time.Hour}"
        /if (!${Ini[framework/${MacroName}_Buffs.ini,${Me.Pet.ID},Zone].Length}) /ini framework/${MacroName}_Buffs.ini "${Me.Pet.ID}" Zone "${Zone.ID}"
        /if (!${Ini[framework/${MacroName}_Buffs.ini,${Me.Pet.ID},Buffs].Length}) /ini framework/${MacroName}_Buffs.ini "${Me.Pet.ID}" Buffs
        | Write all current buffs to Kissassist_Buffs.ini file
        /target id ${Me.Pet.ID}
        /delay 20
        /for i 1 to 50
            /if (${DebugBuffs}) /echo \atDEBUGBUFFS WriteBuffPet ${i} ${Target.Buff[${i}]} \agLine#: ${Macro.CurLine}
            /if (${Me.PetBuff[${i}].Name.Length}) {
                /varset BuffList ${Me.PetBuff[${i}]}
            } else {
                /varset BuffList
            }
            /if (${BuffList.Length}) {
                /if (${DebugBuffs}) /echo \atDEBUGBUFFS WriteBuffPet: ${i}-${BuffList} \agLine#: ${Macro.CurLine}
                /varset Writebufflist ${Writebufflist}|${BuffList}
            }
        /next i
        /ini framework/${MacroName}_Buffs.ini "${Me.Pet.ID}" Buffs "${Writebufflist}"
        /delay 15
        | Open Blocked Pet Buffs window temporarily to read blocked buffs
        /if (!${Window[BlockedPetBuffWnd].Open} && !${BPBWindowOpen}) {
            /windowstate BlockedPetBuffWnd open
            /varset BPBWindowOpen 120m
            /delay 10
        }
        | Write all blocked buffs to Kissassist_Buffs.ini file
        /for k 0 to 39
            /varset Blockedbuff ${Window[BlockedPetBuffWnd].Child[BW_BLOCKEDPETBUFF${k}_Button].Child[BPBuff${k}].Tooltip}
            /if (${Blockedbuff.Length}) {
                 /varset Blockedbufflist ${Blockedbufflist}|${Blockedbuff}
            }
        /next k
        /if (${Blockedbufflist.Length}) /ini framework/${MacroName}_Buffs.ini "${Me.Pet.ID}" Blockedbuffs "${Blockedbufflist}"
        /if (${Window[BlockedPetBuffWnd].Open}) /windowstate BlockedPetBuffWnd close
        /varset WriteBuffsPetTimer 30s
        /if (${DebugBuffs}) /echo \atDEBUGBUFFS WriteBuffsPet Leave \agLine#: ${Macro.CurLine}
    /return
| ----------------------------------------------------------------------------
| SUB: Clean Buffs File
| ----------------------------------------------------------------------------
    Sub CleanBuffsFile
        /if (${CleanBuffsTimer}) /return
        /declare i int local
        /declare SectionList string local ${Ini[framework/${MacroName}_Buffs.ini]}
        /declare SectionListCount int local ${SectionList.Count[|]}
        /if (${SectionListCount}==0) /return
        /varcalc SectionListCount ${SectionListCount}-1
        /declare SectionName string local
        /for i 1 to ${SectionListCount}
            /varset SectionName ${SectionList.Arg[${i},|]}
            /if (${DebugBuffs}) /echo \atDEBUGBUFFS CleanBuffsFile ${i} ${SectionName} ${Math.Calc[${Ini[framework/${MacroName}_Buffs.ini,${SectionName},Day]}-${Time.Day}]} ${Math.Calc[${Time.Hour}-${Ini[framework/${MacroName}_Buffs.ini,${SectionName},Hour]}]} Day: ${Time.Day} Hour: ${Time.Hour} \agLine#: ${Macro.CurLine}
            /if (${Ini[framework/${MacroName}_Buffs.ini,${SectionName},Day].NotEqual[${Time.Day}]}) {
                /ini framework/${MacroName}_Buffs.ini ${SectionName} NULL NULL
                /continue
            }
            /if (${Math.Calc[${Time.Hour}-${Ini[framework/${MacroName}_Buffs.ini,${SectionName},Hour]}]}!=0) /ini framework/${MacroName}_Buffs.ini ${SectionName} NULL NULL
        /next i
        /varset CleanBuffsTimer 10m
    /return
| ----------------------------------------------------------------------------
| SUB: AE check - cast area effect spells depending on set number of mobs
| ----------------------------------------------------------------------------
    Sub AECheck
        /if (!${AEOn}) /return
        /if (${Target.Type.Equal[corpse]}) /return
        /if (!${AggroTargetID}) /return
        /if (${DebugCombat}) /echo \atDEBUGCOMBAT AECheck Enter \agLine#: ${Macro.CurLine}
        /declare i int local
        /declare j int local
        /declare k int local
        /declare l int local
        /declare AESpell string local
        /declare AEMobCount int local
        /declare AETarget string local
        /declare AETargetID int local
        /declare ArrayCount int local 0
        /declare MobCountTemp int local 0
        /declare CheckSpawnID
        /call MobRadar ${AERadius} AECheck
        | Adjust mobcount by subtracting mobs not on xtarget
        /if (${DebugCombat}) /echo \atDEBUGCOMBAT AECheck Mobcount:${MobCount} \agLine#: ${Macro.CurLine}
        /if (!${MobCount}) /return
        /varset MobCountTemp ${SpawnCount[npc xtarhater targetable los radius ${AERadius} zradius 50 noalert 3]}
        /if (${MobCountTemp}<=0) /return
        /for i 1 to ${AE.Size}
            /varset AESpell ${AE[${i}].Arg[1,|]}
            /varset AEMobCount ${AE[${i}].Arg[2,|]}
            /varset AETarget ${AE[${i}].Arg[3,|]}
            | Check if AEspell is ready to use if not skip it
            /if (${AESpell.NotEqual[burn]} && !${Me.SpellReady[${Spell[${AESpell}].RankName}]} && !${Me.AltAbilityReady[${AESpell}]} && !${Me.CombatAbilityReady[${Spell[${AESpell}].RankName}]} && !${Me.AbilityReady[${AESpell}]} && !${AESpell.Find[command:]}) /continue 
            /if (${FindItem[=${AESpell}].ID} && !${Me.ItemReady[=${AESpell}]}) /continue
            /if (${AEMobCount}<=${MobCountTemp}) {
                /if (${AETarget.Equal[null]} || ${AETarget.Equal[Mob]} || ${AETarget.Equal[Single]}) /varset AETargetID ${MyTargetID}
                /if (${AETarget.Equal[Me]}) /varset AETargetID ${Me.ID}
                /if (${AETarget.Equal[MA]}) /varset AETargetID ${Spawn[=${MainAssist}].ID}
                /if (${AETarget.Equal[Pet]}) /varset AETargetID ${Me.Pet.ID}
                /if (${AESpell.Equal[burn]} && !${BurnActive}) {
                    /echo AE-> ${MobCountTemp} Mobs: Activating BURN
                    /varset BurnActive 1
                    /call Event_Burn
                    /return
                }
                /if (${Spawn[npc id ${AETargetID}].ID} && ${SpawnCount[npc xtarhater loc ${Spawn[id ${AETargetID}].X} ${Spawn[id ${AETargetID}].Y} radius ${Spell[${AESpell}].AERange}]} < ${SpawnCount[npc loc ${Spawn[id ${AETargetID}].X} ${Spawn[id ${AETargetID}].Y} radius ${Spell[${AESpell}].AERange}]}) {
                    /if (${AETarget.NotEqual[Single]}) /echo AE-> Casting ${Spell[${AESpell}].Name} now would aggro more mobs than we have on xtarget
                    /continue
                }
                /if (!${ConOn} || !${AE[${i}].Find[|cond]} || ${If[${Cond[${AE[${i}].Mid[${Math.Calc[${AE[${i}].Find[|cond]}+5]},3]}]},1,0]}) {
                    /if (${MobCountTemp}==1 && ${AETarget.Equal[Single]}) {
                        /call CastWhat "${AESpell}" ${AETargetID} AoE 0
                        /if (${Macro.Return.Equal[CAST_SUCCESS]}) {
                            /echo AE-> ${AESpell} on Single target  >> ${Spawn[${AETargetID}].CleanName} <<
                        }
                        /continue
                    } else /if (${MobCountTemp}>=2 && ${AETarget.Equal[Single]}) {
                        /continue
                    } else {
                        /call CastWhat "${AESpell}" ${AETargetID} AoE 0
                        /if (${Macro.Return.Equal[CAST_SUCCESS]}) {
                            /echo AE-> ${MobCountTemp} Mobs: Casting AE ${AESpell}
                        }
                    }
                }
            }
        /next i
        /if (${DebugCombat}) /echo \atDEBUGCOMBAT AECheck Leave \agLine#: ${Macro.CurLine}
    /return
| ----------------------------------------------------------------------------
| SUB: WriteDebuffs
| ----------------------------------------------------------------------------
    Sub WriteDebuffs
    /if (${DebugHeal}) /echo \atDEBUGHEALS WriteDebuffs Enter \agLine#: ${Macro.CurLine}
        /declare DebuffList string local 
        /declare IAmDeBuffed int local ${Math.Calc[${Int[${Me.Poisoned.ID}]}+${Int[${Me.Diseased.ID}]}+${Int[${Me.Cursed.ID}]}+${Int[${Me.Corrupted.ID}]}]}
        /if (${IAmDeBuffed} && !${NeedCuring}) {
            /varset NeedCuring 1
            /varset DebuffList ${IAmDeBuffed}|${Int[${Me.Poisoned.ID}]}|${Int[${Me.Diseased.ID}]}|${Int[${Me.Cursed.ID}]}|${Int[${Me.Corrupted.ID}]}
            /ini framework/${MacroName}_Buffs.ini "${Me.ID}" Debuffs "${DebuffList}"
            /delay 10
            /if (${DebugHeal}) /echo \amDEBUGHEALS WriteDebuffs Writing debuffs to ini file \agLine#: ${Macro.CurLine}
        }
        /if (!${IAmDeBuffed} && ${NeedCuring}) {
            /varset NeedCuring 0
            /varset DebuffList 
            /ini framework/${MacroName}_Buffs.ini "${Me.ID}" Debuffs "${DebuffList}"
            /delay 10
            /if (${DebugHeal}) /echo \amDEBUGHEALS WriteDebuffs Clearing debuffs from ini file \agLine#: ${Macro.CurLine}
        }
        /if (${DebugHeal}) /echo \atDEBUGHEALS WriteDebuffs Leave \agLine#: ${Macro.CurLine}
    /return
| ----------------------------------------------------------------------------
| SUB: CheckCures
| ----------------------------------------------------------------------------
    Sub CheckCures
        /if (!${CuresOn}) /return
        /if (${Me.Invis} && !${AggroTargetID}) /return
        /if (${Medding} && ${MedCombat}) /return
        /if (${DebugHeal}) /echo \amDEBUGHEALS CheckCures Enter  \agLine#: ${Macro.CurLine}
        /declare i int local
        /declare j int local
        /declare IniIDList string local ${Ini[framework/${MacroName}_Buffs.ini]}
        /declare IniIDCount int local ${Math.Calc[${IniIDList.Count[|]}-1]}
        /declare IniDebuffCount string local 0
        /declare IniDebuffList string local
        /declare CuretoCast string local 
        /declare CTID int local
        /for i 1 to ${Cures.Size}
            /if (!${Cures[${i}].Length}) /continue
            /for j 1 to ${IniIDCount}
                /varset CuretoCast
                /varset IniDebuffCount ${Ini[framework/${MacroName}_Buffs.ini,${IniIDList.Arg[${j},|]},"Debuffs"]} 
                /varset CTID ${Spawn[${IniIDList.Arg[${j},|]}].ID}
                /if (${IniDebuffCount.Arg[1,|]} && ${Spawn[${IniIDList.Arg[${j},|]}].ID} && ${Spawn[${IniIDList.Arg[${j},|]}].Distance}<100) {
                    /if (${IniDebuffCount.Arg[1,|]} && ${Cures[${i}].Arg[2,|].Length}==0) {
                        /varset CuretoCast ${Cures[${i}]}
                    } else /if (${IniDebuffCount.Arg[2,|]}>0 && ${Cures[${i}].Arg[2,|].Equal[poison]}) {
                        /varset CuretoCast ${Cures[${i}].Arg[1,|]}
                    } else /if (${IniDebuffCount.Arg[3,|]}>0 && ${Cures[${i}].Arg[2,|].Equal[disease]}) {
                        /varset CuretoCast ${Cures[${i}].Arg[1,|]}
                    } else /if (${IniDebuffCount.Arg[4,|]}>0 && ${Cures[${i}].Arg[2,|].Equal[curse]}) {
                        /varset CuretoCast ${Cures[${i}].Arg[1,|]}    
                    } else /if (${IniDebuffCount.Arg[5,|]}>0 && ${Cures[${i}].Arg[2,|].Equal[corruption]}) {
                        /varset CuretoCast ${Cures[${i}].Arg[1,|]}    
                    }  
                    | Check cures for group component since they don't seem to work on out of group toons
                    /if (${Spell[${CuretoCast}].TargetType.Find[group v]} && !${Spawn[id ${IniIDList.Arg[${j},|]} group].ID}) {
                        /if (!${Defined[CureTimer${CTID}${i}]}) {
                            /declare CureTimer${CTID}${i} timer outer 30s
                            /if (${DebugHeal}) /echo \amDEBUGHEALS CheckCures /echo declare CureTimer${CTID}${i} \agLine#: ${Macro.CurLine}
                        } else /if (!${CureTimer${CTID}${i}}) {
                            /varset CureTimer${CTID}${i} 30s
                            /if (${DebugHeal}) /echo \amDEBUGHEALS CheckCures /echo varset CureTimer${CTID}${i} \agLine#: ${Macro.CurLine}
                        }  
                        /if (${DebugHeal} && !${CureTimer${CTID}${i}}) /echo CURING: >> ${Spawn[${IniIDList.Arg[${j},|]}].CleanName} << is not in your group and >> ${CuretoCast} << is a group spell.
                        /continue
                    }
                    /if (${Me.SpellReady[${Spell[${CuretoCast}].RankName}]} || ${Me.AltAbilityReady[${CuretoCast}]} || ${Me.CombatAbilityReady[${Spell[${CuretoCast}].RankName}]} || ${Me.AbilityReady[${CuretoCast}]} || ${Me.ItemReady[${CuretoCast}]}) {
                        /call CastWhat "${CuretoCast}" ${IniIDList.Arg[${j},|]} Cure 0
                    }
                    /if (${Macro.Return.Equal[CAST_SUCCESS]}) {
                        /call BroadCast ${EQBCOn} o "CURING: >> ${Spawn[${IniIDList.Arg[${j},|]}].CleanName} << with ${CuretoCast}"
                        /delay 10
                    }
                }
            /next j
        /next i
        /if (${DebugHeal}) /echo \amDEBUGHEALS CheckCures Leave \agLine#: ${Macro.CurLine}
    /return
| ----------------------------------------------------------------------------
| SUB: WaitSubs - bunch of crap to call while medding standing around etc
| ----------------------------------------------------------------------------
    Sub WaitSubs
        /if (!${Me.Mount.ID} && ${Me.Standing} && !${Me.Moving}) /sit
        /if (${UseModHeal}==0 && ${HealsOn}==1) {
			/if (${HealsOn}) /call CheckHealth				
		} else /if (${UseModHeal}==1 && ${HealsOn}==1 && ((${Spawn[${WorstHurt[both,1,200,TRUE]}].Type.NotEqual[Pet]} && ${Spawn[${WorstHurt[both,1,200,TRUE]}].Class.ShortName.NotEqual[Corpse]} && ${Spawn[${WorstHurt[both,1,200,TRUE]}].PctHPs} <= ${Math.Calc[${${Spawn[${WorstHurt[both,1,200,TRUE]}].Class.ShortName}Point}*.${tmpHealOverride}]}) || (${Spawn[${WorstHurt[both,1,200,TRUE]}].Type.Equal[Pet]} && ${Spawn[${WorstHurt[both,1,200,TRUE]}].Class.ShortName.NotEqual[Corpse]} && ${Spawn[${WorstHurt[both,1,200,TRUE]}].PctHPs} <= ${Math.Calc[${PetPoint}*.${tmpHealOverride}]}))) {
			/echo ${Macro.CurLine}
			/call NewCast ${Spawn[${WorstHurt[both,1,200,TRUE]}].ID} "Heals"
		}
        /call WriteDebuffs
        /if (${CuresOn}) /call CheckCures
        /if (${MezOn}) {
            /varset MezBroke 0
            /doevents MezBroke
            /if (!${MezBroke}) {
                /varset GoMByPass 1
                /call DoMezStuff WaitSubs
                /varset GoMByPass 0
            }
        }
        /call WriteBuffs
        /if (${AutoRezOn}) /call RezCheck all
        /call CanIDoStuff
        /call CastMana WaitSubs
        /if (${PetOn}) /call DoPetStuff
        /if (${BuffsOn}) /call CheckBuffs 0
        /if (${MercOn}) /call MercsDoWhat
    /return
| ----------------------------------------------------------------------------
| SUB: BroadCast - Handles echos and messages in mq2irc and mq2eqbc
| ----------------------------------------------------------------------------
    Sub BroadCast(doeqbc, eqbcolor, message)
        /if (${eqbcolor.Equal[null]}) /varset eqbcolor w
        /if (${doeqbc}) {
        /if (${Macro.IsTLO[EQBC]}) {
            /if (${EQBC.Connected}) {
                    /if (TRUE) /${EQBCSay} [+${eqbcolor}+] [${Time}] ${message} [+x+]
                } else {
                    /echo You are NOT connected to an EQBC Server. Please check your connection.
                    /echo ${message}
                }
            } else {
                /echo EQBC is Required, but the plugin is NOT Loaded.
                /echo ${message}
            }
        } else {
            /echo ${message}
        }
        
    /return
| ----------------------------------------------------------------------------
| SUB: Campfire ${Window[FellowshipWnd].Child[FP_CampPage].Child[FP_CampsiteViewer].Text}
| ----------------------------------------------------------------------------
    Sub Campfire
        /if (!${CampfireOn}) /return
        /if (${CampfireTimer}) /return
        /if (${Me.Fellowship.Campfire} && (${Select[${Me.Fellowship.CampfireZone.ID},${Zone.ID}]} || ${Me.Fellowship.CampfireZone.Name.Find[guild hall]})) /return
        /if (${Math.Distance[${CampYLoc},${CampXLoc}]}>${CampRadius}) /return
        /if (${AggroTargetID}) /return
        /if (${CombatStart}) /return
        /declare FellowCount int local 0
        /declare i int local
        /declare j int local
        /for i 1 to ${SpawnCount[pc radius 50]}
            /for j 1 to ${Me.Fellowship.Members}
                /if (${NearestSpawn[${i},PC radius 50].CleanName.Equal[${Me.Fellowship.Member[${j}]}]}) /varcalc FellowCount ${FellowCount}+1
            /next j
        /next i
        /if (${FellowCount}>=3) {
            /call Bind_Campfire
        } else {
            /echo Not enough fellowship members trying again in 5 minutes
            /varset CampfireTimer 5m
        }
        /doevents TooSteep
    /return
| ----------------------------------------------------------------------------
| SUB: NamedWatch
| ----------------------------------------------------------------------------
    Sub NamedWatch(int IgnoreTarget)
    /if (!${BurnAllNamed}) {
        | For GMail Notify Only
        /if (${GMailEvents.Find[named]} && ${SpawnCount[xtarhater named radius ${MeleeDistance}]}) {
            /call GmailSend "${Spawn[xtarhater named radius ${MeleeDistance}].CleanName} is a NAMED and its in CAMP!"
            /varset NamedCheck 1 
        }
    } else {
        | BurnAllNameds is ON, So Do this.
        /if (!${IgnoreTarget}) {
            | Use Target and MyTargetID to ID the Named. 
            /if (${BurnAllNamed}==1 && ${Spawn[${MyTargetID}].Named}) {
                /popup *** Mob:(${Target.CleanName}) is a NAMED!
                /echo *** Mob:(${Target.CleanName}) is a NAMED!
                /if (${BurnAllNamed}) /call Event_Burn
                /varset NamedCheck 1 
                /if (${GMailEvents.Find[named]}) /call GmailSend "${Target.CleanName} is a NAMED and its in CAMP!"
            } else {
                | Setting BurnAllNamed=2 will only burn mobs on the list.
                /declare i int local
                /for i 1 to 25        
                    /if (${MobsToBurn.Find[null]}) /return
                    /if (${MobsToBurn.Arg[${i},,].Length} && !${MobsToBurn.Find[null]} && ${Spawn[${MobsToBurn.Arg[${i},,]}].ID}==${MyTargetID} && ${Spawn[${MobsToBurn.Arg[${i},,]}].CleanName.Equal[${Target.CleanName}]}) {
                        /call Event_Burn
                        /popup *** Mob:(${Target.CleanName}) is a NAMED!
                        /echo *** Mob:(${Target.CleanName}) is a NAMED!    
                        /if (${GMailEvents.Find[named]}) /call GmailSend "${Target.CleanName} is a NAMED and its in CAMP!"
                        /varset NamedCheck 1
                        /break
                    }
                /next i
            }
        } else {
            | BurnAllNameds is ON, but I am NON-Melee, So Using SpawnCount and Spawn info to determine if Named.
            /if (${BurnAllNamed}==1 && ${SpawnCount[xtarhater named radius ${MeleeDistance}]}) {
                /popup *** Mob:(${Spawn[xtarhater named radius ${MeleeDistance}].CleanName}) is a NAMED!
                /echo *** Mob:(${Spawn[xtarhater named radius ${MeleeDistance}].CleanName}) is a NAMED!
                /varset MyTargetID ${Spawn[xtarhater named radius ${MeleeDistance}].ID}
                /varset MyTargetName ${Spawn[xtarhater named radius ${MeleeDistance}].CleanName}
                /call Event_Burn
                /varset NamedCheck 1
                /varset MyTargetID 0
                /if (${GMailEvents.Find[named]}) /call GmailSend "${Spawn[xtarhater named radius ${MeleeDistance}].CleanName} is a NAMED and its in CAMP!"
            } else {
                | Setting BurnAllNamed=2 will only burn mobs on the list.
                /declare i int local
                /if (${MobsToBurn.Find[null]}) /return
                /for i 1 to 25
                    /if (${MobsToBurn.Arg[${i},,].Length} && ${Spawn[${MobsToBurn.Arg[${i},,]}].ID}==${Spawn[xtarhater named radius ${MeleeDistance}].ID} && ${Spawn[${MobsToBurn.Arg[${i},,]}].CleanName.Equal[${Spawn[xtarhater named radius ${MeleeDistance}].CleanName}]}) {
                        /varset MyTargetID ${Spawn[xtarhater named radius ${MeleeDistance}].ID}
                        /varset MyTargetName ${Spawn[xtarhater named radius ${MeleeDistance}].CleanName}
                        /call Event_Burn
                        /popup *** Mob:(${Spawn[xtarhater named radius ${MeleeDistance}].CleanName}) is a NAMED!
                        /echo *** Mob:(${Spawn[xtarhater named radius ${MeleeDistance}].CleanName}) is a NAMED!    
                        /if (${GMailEvents.Find[named]}) /call GmailSend "${Spawn[xtarhater named radius ${MeleeDistance}].CleanName} is a NAMED and its in CAMP!"
                        /varset NamedCheck 1
                        /varset MyTargetID 0
                        /break
                    } else /if (${MobsToBurn.Arg[${i},,].Length}==0 || ${MobsToBurn.Arg[${i},,].Equal[null]}) {
                        /break
                    }
                /next i
            }
        }
    }
    /return
| ----------------------------------------------------------------------------
| SUB: Scan ini file for errors in spelling or missing items
| ----------------------------------------------------------------------------
    Sub ScanIni
    /declare i int local 1
    /declare j int local 1 
    /declare Section1 string local Buffs
    /declare Section2 string local DPS
    /declare Section3 string local Burn
    /declare Section4 string local Heals
    /declare Section5 string local AE
    /declare Section6 string local Cures
    /declare Section7 string local Pet
    /declare Section8 string local PetBuffs
    /declare Section9 string local GoM
    /declare CountEnrties int local 0
    /declare CountErrors int local 0
    /declare iniKey string local
    /declare SummonedStuff string local null

        /for i 1 to ${BuffsSize}
        /varset iniKey ${Ini["${IniFileName}",Buffs,Buffs${i}]}
        /if (${iniKey.NotEqual[null]}) {
            /if (${iniKey.Arg[2,|].Equal[summon]}) {
                /if (${SummonedStuff.Equal[null]}) {
                    /varset SummonedStuff ${iniKey.Arg[3,|]}|
                } else {
                    /varset SummonedStuff ${SummonedStuff}${iniKey.Arg[3,|]}|
                }
            }
        }
    /next i

    /for j 1 to 9
        /echo ---------------->> Scanning ${Section${j}} <<----------------
        /varset CountEnrties 0
        /varset CountErrors 0
        /for i 1 to 20            
            /varset iniKey ${Ini["${IniFileName}",${Section${j}},${Section${j}}${i}]}
            /if (${Section${j}.Equal[Pet]} && ${i}==1) /varset iniKey ${Ini["${IniFileName}",${Section${j}},PetSpell]}
            /if (${Section${j}.Equal[Pet]} && ${i}==2) /varset iniKey ${Ini["${IniFileName}",${Section${j}},PetShrinkSpell]}
            /if (${Section${j}.Equal[PetBuffs]}) /varset iniKey ${Ini["${IniFileName}",Pet,Petbuffs${i}]}
            /if (${Section${j}.Equal[GoM]}) /varset iniKey ${Ini["${IniFileName}",GoM,GomSpell${i}]}                                    
            /if (${Section${j}.Equal[Buffs]} && ${iniKey.Arg[2,|].Equal[summon]}) /varset iniKey null                                    
            /if (${Section${j}.Equal[Buffs]} && ${SummonedStuff.NotEqual[null]} && ${SummonedStuff.Find[${iniKey.Arg[1,|]}|]}) /varset iniKey null 
            /if (${iniKey.NotEqual[null]}) {
                /if (${Debug}) /echo ScanIni: ${Section${j}}${i}=${iniKey}  \agLine#: ${Macro.CurLine}
                | find out if there is a Rank and fix spell name.
                /call SpellRankCheck "${iniKey}"
                /varset iniKey ${Macro.Return}
                /if (${Debug}) /echo ScanIni: ${iniKey} after return  \agLine#: ${Macro.CurLine}
                /if (${iniKey.Find[|]}) /varset iniKey ${iniKey.Arg[1,|]}
                /if ( ${iniKey.Find[Command:]}) /goto :SkipInientry
                /if (${Section${j}.Equal[GoM]} && ${iniKey.Find[Gift Of Mana]}) /goto :SkipInientry
                /if (${Section${j}.Equal[AE]} && ${iniKey.Find[Burn]}) /goto :SkipInientry
                /if (!${Me.Book[${iniKey}]} && !${Me.CombatAbility[${iniKey}]} && !${Me.AltAbility[${iniKey}]} && !${FindItem[=${iniKey}].ID} && ${iniKey.NotEqual[banestrike]} && !${Me.Ability[${iniKey}]}) {
                    /echo ...ERROR: ${Section${j}}${i}=${iniKey} unable to find as a  AA, Combat Ability,  Item, Skill, or Spell
                    /varcalc CountErrors ${CountErrors}+1
                }
                /varcalc CountEnrties ${CountEnrties}+1
            }
            :SkipInientry
            /if (!${CountEnrties} && ${i}==20) {
                /echo -- Nothing defined in this section
            }
            /if (!${CountErrors} && ${CountEnrties} && ${i}==20) {
                /echo -- No Spelling Errors or Missing Items Detected
            }       
        /next i
    /next j
    /return
| ----------------------------------------------------------------------------
| SUB: IniWrite - quick ini entry for spells,  aas, discs, items
| ----------------------------------------------------------------------------
    Sub Bind_IniWrite(IWSection, IWE1, IWE2, IWE3, IWE4, IWE5, IWE6, IWE7, IWE8)
    /if (${Debug}) /echo Bind_IniWrite: Enter  \agLine#: ${Macro.CurLine}
    /declare keyNum int local 0
    /declare IWPercent int local 100
    /declare IWSlot int local 1
    /declare IWType string local ${IWE1}
    /declare IWTypeSingle string local
    /declare IWArray int local ${${IWSection}.Size}
    /declare IWEmptySlot string local 0
    /declare IWEntry string local
    /declare i int local
    /declare j int local
    /declare k int local
    | Determine if single type 
    /if (${Select[${IWType},aa,disc,item,spell,clear]}) {
        | Set Item
        /if (${IWType.Equal[item]}) {
            /if (!${Cursor.ID}) {
                /echo ..SET${IWSection}: You need to put the item on your cursor.
                /return
            }
            /varset IWTypeSingle ${Cursor.Name}
            /echo ${IWTypeSingle}
        }
        | Set Spell
        /if (${IWType.Equal[spell]}) {
            /if (!${Me.Gem[${IWE1}].Name.Length}) {
                /echo ..SET${IWSection}: You need to mem a spell
                /return
            }
            /varset IWTypeSingle ${Me.Gem[${IWE2}].Name}
         }
        | Set AA
        /if (${IWType.Equal[aa]}) {
            /if (!${Me.AltAbility[${IWE1}]}) {
                /echo ..SET${IWSection}: You don't have that AA
                /return
            }
            /varset IWTypeSingle ${Me.AltAbility[${IWE2}].Name}
        }
        | Set Disc/Combat Ability
        /if (${IWType.Equal[disc]}) {
            /if (!${Select[${IWE1},1,2,3,4,5,6,7,8]}) {
                /echo ..SET${IWSection}: Disc # must be a Combat Abilty Button 1-8 
                /return
            }
            /if (!${Me.CombatAbility[${Window[CombatAbilityWnd].Child[CAW_Button${IWE1}].Text}]}) {
                /echo ..SET${IWSection}: You don't have that Disc or Combat Ability button ${IWE1} is empty.
                /return
            }
            /varset IWTypeSingle ${Window[CombatAbilityWnd].Child[CAW_Button${IWE1}].Text}
        }
        | Final Catchall for error control
        /if (!${IWTypeSingle.Length}) {
            /echo ..SET${IWSection}: ${IWType} parameter is blank. Please provide a ${IWType}
            /return
        }
        | Find empty slot & check if entry exists
        /echo ..SET${IWSection}: Looking of for spot to write ${IWTypeSingle}
        /for k 1 to ${IWArray}
            /varset IWEntry ${Ini[${IniFileName},${IWSection},${IWSection}${k}]}
            /if (${IWSection.Equal[DPS]}) /varset IWPercent 90
            /if (${IWSection.Equal[Heals]}) /varset IWPercent 80
            /if (${Debug}) /echo ${${IWSection}[${k}].Length} \agLine#: ${Macro.CurLine}
            /if (${IWEntry.Find[${IWTypeSingle}]}) {
                /echo ..SET${IWSection}: Duplicate entry ${IWSection}${k}=${IWTypeSingle} skipping.
                /return
            }
            /if (${IWEntry.Equal[null]} && ${IWEmptySlot}==0) {
                /varset IWEmptySlot ${k}
            }
            /if (${k}==${IWArray} && !${IWEmptySlot}) /varset IWEmptySlot ${k}
        /next k
        /if (${IWEmptySlot}==${IWArray}) {
            /echo ..SET${IWSection}: No empty slots in ${IWSection} to write
            /return
        }
        /if (${Select[${IWSection},DPS,Heals]}) {
            /ini "${IniFileName}" "${IWSection}" "${IWSection}${IWEmptySlot}" "${IWTypeSingle}|${IWPercent}"
            /echo  ..SET${IWSection}: ${IWSection}${IWEmptySlot} is empty writing ${IWTypeSingle}|${IWPercent}
        } else {
            /ini "${IniFileName}" "${IWSection}" "${IWSection}${IWEmptySlot}" "${IWTypeSingle}"
            /echo  ..SET${IWSection}: ${IWSection}${IWEmptySlot} is empty writing ${IWTypeSingle}
        }
    } else {
        /echo ..SET${IWSection}: This command will write over current ${IWSection} settings 
        /for i 1 to 8
            /varset keyNum ${i}
            /if (${Me.Gem[${IWE${i}}].Name.Length}) {
                /if (${IWSection.Equal[DPS]}) /varcalc IWPercent ${IWPercent}-5
                /if (${IWSection.Equal[Heals]}) /varset IWPercent 80
                /if (${Select[${IWSection},DPS,Heals]}) {
                    /ini "${IniFileName}" "${IWSection}" "${IWSection}${IWSlot}" "${Me.Gem[${IWE${i}}].Name}|${IWPercent}"
                    /echo ..SET${IWSection}: Writing ${IWSection}${IWSlot}=${Me.Gem[${IWE${i}}].Name}|${IWPercent}
                }
                /if (${Select[${IWSection},Buffs]}) {
                    /ini "${IniFileName}" "${IWSection}" "${IWSection}${IWSlot}" "${Me.Gem[${IWE${i}}].Name}"
                    /echo ..SET${IWSection}: Writing ${IWSection}${IWSlot}=${Me.Gem[${IWE${i}}].Name}
                }
                /varcalc IWSlot ${IWSlot}+1
                /delay 10
            }
        /next i
    }
    /return
|-----------------------------------------------------------------------------
| SUB: Campfire back to camp
| ----------------------------------------------------------------------------
    Sub CampfireBack
        /if (!${ClickBacktoCamp} || ${CampfireClickTimer} || ${Me.Hovering}) /return
        /varset CampfireClickTimer 1m
        | Am I Dead?
        /if (${Me.Buff[Revival Sickness].ID} && ${CampZone} != ${Zone.ID} && ${Me.ID}) /varset IAmDead 1
        /if (${IAmDead}) {
            | Does Campfire Exist?
            /if (!${Me.Fellowship.Campfire}) {
                /echo There is no campfire up.
                /return
            }
            |Test this: make sure IAmDead=0 is correct
            | Am I & the campfire in the same zone?
            /if (${Select[${Me.Fellowship.CampfireZone.ID},${Zone.ID}]}) {
                /echo I'm back in the same zone as my campfire. 
                /varset IAmDead 0
                /return
            }
            /if (${FindItem[Fellowship Registration Insignia].TimerReady} == 0) {
                /echo Time to get back to work. Clicking Fellowship Insignia in 30 seconds.
                | Delay for rest state to kick in
                /delay 30s
                /squelch /nomodkey /itemnotify "Fellowship Registration Insignia" rightmouseup
            } else {
                /echo Waiting for Fellowship Registration Insignia to refresh.
            }
        }
    /return
|-----------------------------------------------------------------------------
| SUB: Debug All
| ----------------------------------------------------------------------------
    Sub Bind_DebugAll
            /if (${EverQuest.CurrentUI.NotEqual[Default]}) {
                /echo You are using a Custom UI. Please switch to Default UI before Posting.
            }
        /if (!${DebugAllOn}) {
            /varset DebugAllOn 1
            /echo \atDEBUG ALL On
        } else {
            /varset DebugAllOn 0
            /echo \atDEBUG ALL Off
        }
        /varset Debug ${DebugAllOn}
        /varset DebugBuffs ${DebugAllOn}
        /varset DebugCast ${DebugAllOn}
        /varset DebugCombat ${DebugAllOn}
        /varset DebugHeal ${DebugAllOn}
        /varset DebugMez ${DebugAllOn}
        /varset DebugMove ${DebugAllOn}
        /varset DebugPet  ${DebugAllOn}
        /varset DebugPull ${DebugAllOn}
		/varset DebugFW ${DebugAllOn}
		/varset DebugMacroFlow ${DebugAllOn}
    /return
|-----------------------------------------------------------------------------
| SUB: PetSusStateAdd1
| ----------------------------------------------------------------------------    
    Sub Event_PetSusStateAdd1
        /varset PetActiveState  0
        /varset PetSuspendState 1
        /varset PetTotCount     1
        /if (${DebugPet}) /echo PetSusStateAdd1 triggered. \agLine#: ${Macro.CurLine}
        /if (${DebugPet}) /echo PetTotCount(${PetTotCount}) PetActiveState(${PetActiveState}) PetSuspendState(${PetSuspendState}) \agLine#: ${Macro.CurLine}
    /return
|-----------------------------------------------------------------------------
| SUB: PetSusStateAdd2
| ----------------------------------------------------------------------------    
    Sub Event_PetSusStateAdd2
        /varset PetActiveState  1
        /varset PetSuspendState 1
        /varset PetTotCount     2
        /if (${DebugPet}) /echo PetSusStateAdd2 triggered. \agLine#: ${Macro.CurLine}
        /if (${DebugPet}) /echo PetTotCount(${PetTotCount}) PetActiveState(${PetActiveState}) PetSuspendState(${PetSuspendState}) \agLine#: ${Macro.CurLine}
    /return
|-----------------------------------------------------------------------------
| SUB: PetSusStateSub
| ----------------------------------------------------------------------------    
    Sub Event_PetSusStateSub
        /varset PetActiveState  1    
        /varset PetSuspendState 0
        /varset PetTotCount     1
        /if (${DebugPet}) /echo PetSusStateSub triggered. \agLine#: ${Macro.CurLine}
        /if (${DebugPet}) /echo PetTotCount(${PetTotCount}) PetActiveState(${PetActiveState}) PetSuspendState(${PetSuspendState}) \agLine#: ${Macro.CurLine}
    /return   
|-----------------------------------------------------------------------------  
| SUB: Back Off and stop melee  
| ----------------------------------------------------------------------------      
    Sub Bind_BackOff(string OnOffFlag)
        /if (${Select[${OnOffFlag},on,off,1,0]}>0) {
            /if (${Select[${OnOffFlag},on,1]}>0) {
                /varset DPSPaused 0
            } else {
                /varset DPSPaused 2
            }
        }
        /if (${DPSPaused}) {  
            /if (${DPSPaused}==2 && ${UseMQ2Melee}) /squelch /melee on
            /varset DPSPaused 0  
            /echo Resetting. No Longer Backing off.  
        } else {  
            /varset DPSPaused 1  
            /varset CombatStart 0  
            /if (${UseMQ2Melee}) /squelch /melee off
            /squelch /attack off  
            /if (${Stick.Active}) /stick off 
            /call CombatReset 0 backoff
            /varset DPSPaused 2 
            /echo Backing off - All Combat has been reset.
        }  
        /if (${ReturnToCamp} && ${Math.Distance[${CampYLoc},${CampXLoc}]} > 15) {  
            /call DoWeMove 0 bind_backoff
        }  
        /doevents flush BackOff  
    /return 
| -------------------------------------------------------------------------------------
| SUB: Event PetToysPlease 
| -------------------------------------------------------------------------------------    
    Sub Event_PetToysPlease(Message,string MTPet)
        /if (!${MTPet.Length}) /return
        /if (${MTPet.Find[null]}) /return
        /if (${Spawn[${MTPet}].Type.NotEqual[Pet]} && ${MTPet.NotEqual[group]}) /return
        /declare PTPPetID int local
        /declare GMemID int local
        /declare GMemShortName string local
        /declare GMemPetName string local
        /declare i int local 0
        /if (${DebugPet}) /echo \atDEBUGPET PetToysPlease: Enter \agLine#: ${Macro.CurLine}
        | If group command give all pets in group toys
        /if (${MTPet.Find[GROUP]}) {
            /echo I am giving pet toys to every Pet in Group except mine.
            | Start at 1 my pet doesn't need toys
            /for i 1 to 5
            /varset GMemID ${Group.Member[${i}].ID};
            /varset PTPPetID ${Group.Member[${i}].Pet.ID}
            /varset GMemShortName ${Group.Member[${i}].Class.ShortName} 
            /varset GMemPetName ${Group.Member[${i}].Pet.CleanName}
            /if (${DebugPet}) /echo \atDEBUGPET PetToysPlease: ${GMemID} && ${PTPPetID} && ${Select[${GMemShortName},shm,nec,mag,bst,dru,enc,shd]} && ${Spawn[${GMemPetName}].Type.Equal[Pet]} \agLine#: ${Macro.CurLine}
            /if (${GMemID} && ${PTPPetID} && ${Select[${GMemShortName},shm,nec,mag,bst,dru,enc,shd]} && ${Spawn[${GMemPetName}].Type.Equal[Pet]}) {
                /if (${PetToysOn}) /call pettoys ${GMemPetName}
            }
            /next i
        } else {
            | Individual Pet.
            /if (${PetToysOn}) {
                /echo Giving pet toys to (${MTPet}).
                /call pettoys ${MTPet}
            }
        }
        /if (${DebugPet}) /echo \atDEBUGPET PetToysPlease: Leave \agLine#: ${Macro.CurLine}
    /return
| -------------------------------------------------------------------------------------s
| SUB: Add stuff to alert list  
| -------------------------------------------------------------------------------------      
    Sub AlertAddToList(int whatlist, MvarList, IDvarList)
        /if (${Debug}) /echo \atDEBUG AlertAddToList List:${whatlist} Mlist: ${MvarList} \agLine#: ${Macro.CurLine}
        /declare k int local
        | Clear ignore mobs alert from list before assigning from ini list
        /squelch /alert clear ${whatlist}
        /if (${MvarList.Length} && !${MvarList.Find[null]}) {
            /for k 1 to 25
                /if (${MvarList.Arg[${k},,].Length} && !${MvarList.Find[null]} && ${Debug}) /echo \atDEBUG ADD ${MvarList.Arg[${k},,]} to ${MvarList}
                /if (${MvarList.Arg[${k},,].Length}) {
                    /if (${MvarList.Arg[${k},,].Find[*]}) {
                        /squelch /alert add ${whatlist} "${MvarList.Arg[${k},,].Replace[*,]}"
                    } else {
                        /squelch /alert add ${whatlist} "=${MvarList.Arg[${k},,]}"
                    }
                    /if (${Debug}) /echo \atDEBUG AlertAddToList Add ${MvarList.Arg[${k},,]} to Alert List ${whatlist} \agLine#: ${Macro.CurLine}
                }
            /next k
        }
        | Add by mob ID for mobs that wonder out of range when trying to pull.
        /if (${IDvarList.Length} && ${IDvarList.NotEqual[null]}) {
            /varset k 1
            /while (${IDvarList.Arg[${k},|].Length} && ${IDvarList.Arg[${k},|].NotEqual[null]} && ${Int[${IDvarList.Arg[${k},|]}]}>0) {
                /if (${DebugFramework}) /Echo Current Line ${Macro.CurLine}
				/if (${Debug}) /echo \atDEBUG ADD ${IDvarList.Arg[${k},|]} to ${MvarList}
                /if (${Int[${IDvarList.Arg[${k},|]}]}>0) /squelch /alert add ${whatlist} id ${IDvarList.Arg[${k},|]}
                /if (${Debug}) /echo \atDEBUG AlertAddToList Add ${IDvarList.Arg[${k},|]} to Alert List ${whatlist} \agLine#: ${Macro.CurLine}
                /varcalc k ${k}+1
            }
        }
        /if (${Debug}) /echo \atDEBUG AlertAddToList Leave \agLine#: ${Macro.CurLine}
    /return
| -------------------------------------------------------------------------------------
| SUB: Cast Mount
| -------------------------------------------------------------------------------------      
    Sub CastMount
        /if (${Me.Mount.ID} || !${MountOn} || (${HealsOn} && ${AggroTargetID})) /return
        /declare i int local
        /for i 1 to ${Buffs.Size}
        | Cast mount
        /if (${Buffs[${i}].Arg[2,|].Equal[Mount]} && !${Buffs[${i}].Find[0]} && !${Me.Mount.ID} && !${Attacking} && ${MountOn} && !${Me.FeetWet}) {
            /if (${DebugBuffs}) /echo \atDEBUGBUFFS CheckBuffs Mount \agLine#: ${Macro.CurLine}
                /if (${ConOn} && ${Buffs[${i}].Find[|cond]} && ${If[${Cond[${Buffs[${i}].Mid[${Math.Calc[${Buffs[${i}].Find[|cond]}+5]},3]}]},0,1]}) /continue
                /call CastWhat "${Buffs[${i}].Arg[1,|]}" ${Me.ID} CastMount
            /delay 1s
            /if (${Macro.Return.Equal[CAST_NOMOUNT]}) /varset MountOn 0
        }
        /next i
    /return
| -------------------------------------------------------------------------------------
| SUB: Cast Mana
| -------------------------------------------------------------------------------------      
    Sub CastMana(string SentFrom)
        /if (${Me.Invis}) /return
        /if (${DebugBuffs}) /echo \atDEBUG CastMana Enter ${SentFrom} \agLine#: ${Macro.CurLine}
        /declare i int local
        /declare CondNo int local 0
        /if (${MezOn}) {
            /varset MezBroke 0
            /doevents MezBroke
            /if (!${MezBroke}) {
                /varset GoMByPass 1
                /call DoMezStuff CastMana
                /varset GoMByPass 0
            }
        }
        /for i 1 to ${Buffs.Size}
            /if (${Buffs[${i}].Find[|0]} || ${Buffs[${i}].Equal[null]}) /continue
            /if (${Select[${Buffs[${i}].Arg[2,|]},mana,managroup]}==0) /continue
            /if (${UseModHeal}==0 && ${HealsOn}==1) {
				/if (${HealsOn}) /call CheckHealth				
			} else /if (${UseModHeal}==1 && ${HealsOn}==1 && ((${Spawn[${WorstHurt[both,1,200,TRUE]}].Type.NotEqual[Pet]} && ${Spawn[${WorstHurt[both,1,200,TRUE]}].Class.ShortName.NotEqual[Corpse]} && ${Spawn[${WorstHurt[both,1,200,TRUE]}].PctHPs} <= ${Math.Calc[${${Spawn[${WorstHurt[both,1,200,TRUE]}].Class.ShortName}Point}*.${tmpHealOverride}]}) || (${Spawn[${WorstHurt[both,1,200,TRUE]}].Type.Equal[Pet]} && ${Spawn[${WorstHurt[both,1,200,TRUE]}].Class.ShortName.NotEqual[Corpse]} && ${Spawn[${WorstHurt[both,1,200,TRUE]}].PctHPs} <= ${Math.Calc[${PetPoint}*.${tmpHealOverride}]}))) {
				|/echo ${Macro.CurLine}
				/call NewCast ${Spawn[${WorstHurt[both,1,200,TRUE]}].ID} "Heals"
			}
            /if (${ConOn} && ${Buffs[${i}].Find[|cond]}) {
                /varset CondNo ${Buffs[${i}].Mid[${Math.Calc[${Buffs[${i}].Find[|cond]}+5]},3]}
            } else {
                /varset CondNo 0
            }
            | Check and Cast mana type spells/aas/items - Canni/Paragon/Harvest - prevent toon from using before rez after zoning for 2 min
                /if (${Buffs[${i}].Arg[2,|].Equal[Mana]} && !${Me.Buff[Revival Sickness].ID} && !${JustZoned}) {
                    /if (${Buffs[${i}].Arg[1,|].Equal[Dichotomic Psalm]} && (${IAmABard} || ${Me.CurrentEndurance}<6600)) /continue
                    /if (${Me.PctMana}<=${Buffs[${i}].Arg[3,|]} && ${Me.PctHPs}>${Int[${Buffs[${i}].Arg[4,|]}]}) {
                        /if (${Cursor.ID}) /call CheckCursor CastMana
                        /if (${DebugBuffs}) /echo \atDEBUGBUFFS Canni/Paragon/Harvest \agLine#: ${Macro.CurLine}
                            /if (${CondNo} && ${If[${Cond[${CondNo}]},0,1]}) /continue
                            /call CastWhat "${Buffs[${i}].Arg[1,|]}" ${Me.ID} CastMana 0 0
                            /if (${Macro.Return.Equal[CAST_SUCCESS]}) /echo Casting >> ${Buffs[${i}].Arg[1,|]} << for mana
                    }
                } else /if (${Buffs[${i}].Arg[2,|].Equal[Managroup]} && (!${Medding} || (!${MedCombat} && ${Medding}))) {
                    /call RegenOther "${Buffs[${i}].Arg[1,|]}" Mana ${Buffs[${i}].Arg[3,|]} 0 ${CondNo}
                }
        /next i
        /if (${DebugBuffs}) /echo \atDEBUG CastMana Leave ${SentFrom} \agLine#: ${Macro.CurLine}
    /return

| -------------------------------------------------------------------------------------
| SUB: Comma Me Bro - CommaNation Domination
| ------------------------------------ -------------------------------------------------           
    Sub CommaMeBro(string cmbnumber)
        /declare CommaNator string local 
        | Strip out any decimal points 
        /varset cmbnumber ${cmbnumber.Arg[1,.]}
        /if (${cmbnumber.Length}<=3 ) /varset CommaNator ${cmbnumber}
        /if (${cmbnumber.Length}>3 && ${cmbnumber.Length}<=6) /varset CommaNator  ${cmbnumber.Left[${Math.Calc[${cmbnumber.Length}-3]}]},${cmbnumber.Right[3]}
        /if (${cmbnumber.Length}>6  && ${cmbnumber.Length}<=9) /varset CommaNator ${cmbnumber.Left[${Math.Calc[${cmbnumber.Length}-6]}]},${cmbnumber.Mid[${Math.Calc[${cmbnumber.Length}-5]},3]},${cmbnumber.Right[3]}
        /if (${cmbnumber.Length}>9) /varset CommaNator ${cmbnumber.Left[${Math.Calc[${cmbnumber.Length}-9]}]},${cmbnumber.Mid[${Math.Calc[${cmbnumber.Length}-8]},3]},${cmbnumber.Mid[${Math.Calc[${cmbnumber.Length}-5]},3]},${cmbnumber.Right[3]}
    /return ${CommaNator}
| -------------------------------------------------------------------------------------
| SUB: Event_Timer 
| ------------------------------------ -------------------------------------------------           
    Sub Event_Timer(Timer, OriginalValue)
        /if (${Select[${Timer},TributeTimer,AggroOffTimer,TellTimer,SitToMedTimer]}==0) /return
        /if (${Debug}) /echo \atDEBUGBUFFS Event_Timer Enter \agLine#: ${Macro.CurLine}
        /if (${Timer.Equal[TributeTimer]}) {
            /if (${UseTribute} && ${Me.TributeActive}) {
                /if (!${AggroTargetID} || (${Target.ID} && !${Target.Named})) {
                    /squelch /tribute personal off
                } else {
                    /if (${Target.ID} && ${Target.Named}) /varset ${Timer} 580s
                }      
            }
        }
        /if (${Timer.Equal[AggroOffTimer]}) {
            /if (${Me.Feigning}) /stand
            /if (${Me.Invis}) /makemevisible
        }
		/if (${Timer.Equal[SitToMedTimer]} && !${Me.Moving}) {
			/if (!${MeleeOn} && ${Me.Standing} && ${MedCombat}==2 && !${Me.Mount.ID} && !${Me.Casting.ID} && (${Me.TargetOfTarget.ID}!=${Me.ID} || ${Target.ID}==${Me.ID})) /sit
        }
        /if (${Debug}) /echo \atDEBUGBUFFS Event_Timer leave \agLine#: ${Macro.CurLine}
        /return
| -------------------------------------------------------------------------------------
| SUB: SpellRankCheck
| ------------------------------------ -------------------------------------------------           
    Sub SpellRankCheck(Rk_Check_What)
        /declare rkCheck                string      local null
        /declare rkCheck1               string      local 
        /declare rkdCheck               string      local
        /declare rkTemp                 string      ${Rk_Check_What.Arg[1,|]}
        /declare rkdTemp                string      ${Rk_Check_What.Arg[3,|]}
        /if (${DebugRK}) /echo \atDEBUG SpellRankChecks: Enter \agLine#: ${Macro.CurLine}
		|might need to change if some spells have the word script in them.
		/if (${Rk_Check_What.Find[script]}) /return ${Rk_Check_What} 
        /if (${Rk_Check_What.Left[1].Equal[0]} || ${Int[${Rk_Check_What.Left[1]}]}>0) /return ${Rk_Check_What}
        | Check for Rk. in spell name and Remove it.   
        /if (${rkTemp.Find[ Rk.]}) {
            /varset rkTemp ${rkTemp.Left[${Math.Calc[${rkTemp.Find[ Rk.]}-1]}]} 
        }
        /if (${Int[${Me.Book[${rkTemp}]}]}==0 && ${Int[${Me.Book[${Spell[${rkTemp}].RankName}]}]}==0 && ${Int[${Me.AltAbility[${rkTemp}]}]}==0 && ${Int[${Me.AltAbility[${rkTemp}].Spell.ID}]}==0 && ${Int[${Me.CombatAbility[${Spell[${rkTemp}].RankName}]}]}==0) /return ${Rk_Check_What}
        /if (${DebugRK}) /echo \atDEBUG SpellRankChecks: 1 rkCheck: "${rkCheck}" rkTemp: "${rkTemp}" rkdCheck: "${rkdCheck}" rkdTemp: "${rkdTemp}"  \agLine#: ${Macro.CurLine}
        | If this is NOT an Alt Ability then it must be a spell.
        /if (${Int[${Me.AltAbility[${rkTemp}].ID}]}!=0 || ${Int[${Me.AltAbility[${rkTemp}].Spell.ID}]}!=0) {
           /if (${DebugRK}) /echo 1a. well we think ${rkTemp} is an AA
           /varset rkCheck ${rkTemp}
        } else {
           /if (${DebugRK}) /echo 1c. well ${rkTemp} is not an AA or CombatAbility
           /varset rkCheck ${Spell[${rkTemp}].RankName}
        }
        | check for null
        /if (${DebugRK}) /echo \atDEBUG SpellRankChecks: 2 rkCheck: ${rkCheck} rkTemp: ${rkTemp} Rk_Check_What: ${Rk_Check_What} \agLine#: ${Macro.CurLine}
        | must NOT be null so lets fix Rk_Check_What.
        /if (${rkCheck.NotEqual[${rkTemp}]}) {
            /if (${Rk_Check_What.Find[|]}>0) {
                /varset rkCheck1 ${rkCheck}${Rk_Check_What.Right[-${Math.Calc[${Rk_Check_What.Find[|]}-1]}]} 
                /varset rkCheck ${rkCheck1}
            }
        } else {
            /varset rkCheck ${Rk_Check_What}
        }
        /if (${Rk_Check_What.Arg[2,|].Equal[dual]}) {
           /if (${rkdTemp.Find[ Rk.]}) {
               /varset rkdTemp ${rkdTemp.Left[${Math.Calc[${rkdTemp.Find[ Rk.]}-1]}]} 
           }
           /if (${Int[${Me.AltAbility[${rkdTemp}].ID}]}!=0 || ${Int[${Me.AltAbility[${rkTemp}].Spell.ID}]}!=0) {
               /varset rkdCheck ${Spell[${rkdTemp}].RankName}
           } else {
               /if (${Me.Subscription.NotEqual[gold]}) {
                   /varset rkdCheck ${rkdTemp}
               } else {
                   /varset rkdCheck ${Spell[${rkdTemp}].RankName}
               }
           }
           /if (${DebugRK}) /echo \atDEBUG SpellRankChecks: 3 rkdCheck: ${rkdCheck} rkdTemp: ${rkdTemp} Rk_Check_What: ${Rk_Check_What} \agLine#: ${Macro.CurLine}
           /varset rkCheck ${rkCheck.Arg[1,|]}|dual|${rkdCheck}
        }
        /if (${DebugRK}) /echo \atDEBUG SpellRankChecks: 4 Rk_Check_What: ${Rk_Check_What} rkCheck: ${rkCheck} rkTemp: ${rkTemp}  \agLine#: ${Macro.CurLine}
        /if (${DebugRK}) /echo \atDEBUG SpellRankChecks: leave \agLine#: ${Macro.CurLine}
    /return ${rkCheck}
| -------------------------------------------------------------------------------------
| SUB: Check cursor
| -------------------------------------------------------------------------------------           
    Sub CheckCursor(string SentFrom)
        /if (${Debug}) /echo \atDEBUG CheckCursor: enter \agLine#: ${Macro.CurLine}
        :inventory
            /if (${Debug} && ${Cursor.ID}) /echo Dropping ${Cursor} ${SentFrom}
            /autoinventory
            /delay 10
        /if (${Cursor.ID}) /goto :inventory
        /if (${Debug}) /echo \atDEBUG CheckCursor: leave \agLine#: ${Macro.CurLine}
    /return      
| -------------------------------------------------------------------------------------
| SUB: Event LeftGroup
| ------------------------------------------------------------------------------------- 
    Sub Event_LeftGroup(Line,LGName)
        /if (${GMailEvents.Find[leftgroup]}) /call GmailSend "${LGName} has left the group."
        /doevents flush LeftGroup
    /return
| -------------------------------------------------------------------------------------
| SUB: Bind ZoneInfo
| ------------------------------------------------------------------------------------- 
    Sub Bind_ZoneInfo
        /declare LineInfo string local
        /echo -------------------------------------------------------------------------
        /echo  ${ZoneName} - (${Zone.ShortName})
        /echo -------------------------------------------------------------------------
        /echo MezImmune: ${Ini[${InfoFileName},${ZoneName},MezImmune]}
        /echo MobsToPull: ${Ini[${InfoFileName},${ZoneName},MobsTopull]}
        /echo MobsToIgnore: ${Ini[${InfoFileName},${ZoneName},MobsToIgnore]}
        /echo MobsToBurn: ${Ini[${InfoFileName},${ZoneName},MobsToBurn]}
        /echo -------------------------------------------------------------------------
    /return
| -------------------------------------------------------------------------------------
| SUB: CombatReset
| ------------------------------------------------------------------------------------- 
    Sub Bind_combatreset
        /call CombatReset 0
    /return
| -------------------------------------------------------------------------------------
| SUB: Bind WriteMySpell
| ------------------------------------------------------------------------------------- 
    Sub Bind_WriteMySpells(NewSpellSet)
        /declare i int local
            /for i 1 to 13
            /echo Gem ${i}: ${Me.Gem[${i}].Name}
            /ini "${IniFileName}" "${NewSpellSet}" "Gem${i}" "${Me.Gem[${i}].Name}"
        /next i
    /return  
| -------------------------------------------------------------------------------------
| SUB: Bind MemMySpells
| ------------------------------------------------------------------------------------- 
   Sub Bind_MemMySpells(SpellSet, Message)
        /declare temppCharName          string      local
        /declare pCharName              string      local ${Message}
        /declare tempIniFileName        string      local
        /declare pKV                    string      local
        /declare i                      int         local
        /declare ii                     int         local
        /declare SpellToMem             string      local       
        /declare tempSpellName          string      local 
        
        /if (${Debug}) /echo \atDEBUG MemMySpells: Enter \agLine#: ${Macro.CurLine}
        /if (!${pCharName.Length} || ${pCharName.Equal[null]}) {
           /varset temppCharName ${Me.CleanName}
        } else {
           /varset temppCharName ${pCharName}
        }
        /if (${temppCharName.NotEqual[${Me.CleanName}]}) {
        /if (${Ini[${MacroName}_${EverQuest.Server}_${temppCharName}.ini,General,KissAssistVer].Length}) {
            /varset tempIniFileName ${MacroName}_${EverQuest.Server}_${temppCharName}.ini
            /echo Server Name ini file detected using ${tempIniFileName}
        } else {
            /varset tempIniFileName ${MacroName}_${temppCharName}.ini
        }
        } else /if (!${PIniSet}) {
            /varset tempIniFileName ${MacroName}_${temppCharName}.ini
        } else {
            /varset tempIniFileName ${IniFileName}
        }
		
		/varset tempIniFileName ${IniFileName}
        /varset pKV ${Ini[${tempIniFileName},General,KissAssistVer]}
        |/if (${Int[${pKV}]}==0) {
        |   /echo Invalid INI file: ${tempIniFileName} for memorizing spells. Returning.
        |   /return
        |}
        /varset pKV ${Ini[${tempIniFileName},"${SpellSet}",Gem1]}
        /if (${Int[${pKV.Length}]}==0) {
           /echo No Spells found in INI file: ${tempIniFileName}. Use /writespells and try again. Returning.
           /return
        }
        /for i 1 to 13
            /varset SpellToMem ${Ini[${tempIniFileName},"${SpellSet}",Gem${i}]}
            /if (${SpellToMem.Length} && ${SpellToMem.NotEqual[null]}) {
                /if (${SpellToMem.Find[ Rk.]}) {
                   /varset tempSpellName ${SpellToMem.Left[${Math.Calc[${SpellToMem.Find[ Rk.]}-1]}]} 
                } else {
                   /varset tempSpellName ${SpellToMem} 
                }
                /varset SpellToMem ${Spell[${tempSpellName}].RankName}
                /if (${Me.Book[${SpellToMem}]}) {
                    /if (${Int[${Me.Gem[${SpellToMem}]}]}>0 && ${Int[${Me.Gem[${SpellToMem}]}]}!=${i}) {
                        /varcalc ii ${Int[${Me.Gem[${SpellToMem}]}]}-1
                        /notify CastSpellWnd CSPW_Spell${ii} rightmouseup
                        /delay 20 ${Int[${Me.Gem[${SpellToMem}]}]}==0
                    }
                    /if (!${Int[${Me.Gem[${i}].Name.Length}]} || ${Me.Gem[${i}].Name.NotEqual[${SpellToMem}]}) {
                        /varset DontMoveMe 1
                        /while (${Me.Moving}) {
                            /if (${DebugFramework}) /Echo Current Line ${Macro.CurLine}
							/delay 5
                        }
                        /echo Meming ${SpellToMem} in slot ${i}
                        /if (${Stick.Active}) {
                            /stick pause
                            /MemSpell ${i} "${SpellToMem}"
                            /delay 150 ${Me.Gem[${i}].Name.Equal[${SpellToMem}]}
                            /stick unpause
                        } else {
                            /MemSpell ${i} "${SpellToMem}"
                            /delay 150 ${Me.Gem[${i}].Name.Equal[${SpellToMem}]}
                        }
                        /varset DontMoveMe 0
                    }
                } else {
                    /echo Could Not find the spell ${SpellToMem} in your spell book.
                }
            }
        /next i   
        /varset ReMemMiscSpell ${Me.Gem[${MiscGem}].Name}
        /varset ReMemMiscSpellLW ${Me.Gem[${MiscGemLW}].Name}
    /if (${Debug}) /echo \atDEBUG MemMySpells: leave \agLine#: ${Macro.CurLine}
    /return
| -------------------------------------------------------------------------------------
| SUB: Bind Parse
| -------------------------------------------------------------------------------------
    Sub Bind_old_Parse(TimeToParse)
        /if (${Debug}) /echo \atDEBUGBUFFS Bind_Parse Enter \agLine#: ${Macro.CurLine}
        /if (!${Defined[ParseDPS]}) /declare ParseDPS     timer       outer       0
        /echo Parsing combat for ${TimeToParse} second
        /varset BurnAllNamed 0
        /tar npc dummy
        /delay 10 ${Target.ID}
        /varset MyTargetID ${Target.ID}
        /varset MyTargetName ${Target.CleanName}
        /varset ParseDPS ${TimeToParse}s
        |/call Combat
        /call CombatReset 0 parse
        /target clear
        /attack off
        /stick off
        /endmacro
        /if (${Debug}) /echo \atDEBUGBUFFS Bind_Parse Leave \agLine#: ${Macro.CurLine}
    /return
| -------------------------------------------------------------------------------------
| SUB: Bind_TrackMeDown
| -------------------------------------------------------------------------------------
    Sub Bind_TrackMeDown(int StickOff, int UseNavOnly, int IgnoreDistance)
        /if (${DontMoveMe}) {
            /echo WAIT UP! I was told not to move. Leaving TrackMeDown.
            /return
        }
        /if (${Debug}) /echo \atDEBUG Bind_TrackMeDown Enter \agLine#: ${Macro.CurLine}
        /declare tmdChaseAssist int local ${ChaseAssist}
        /declare tmdReturnToCamp int local ${ReturnToCamp}
        /declare tmdChaseDistance int local ${ChaseDistance}
        /declare tmdCampRadiusExceed int local ${CampRadiusExceed}
        | Check if I am Dead.
        /if (${Me.Hovering} || ${IAmDead}) /return
        | Check if Who to chase character is in the zone.
        /if (${Spawn[pc ${WhoToChase}].ID}==0) /return
        /varset BindActive 1
        | Check if we are to use Navigation and it is loaded with a valid Mesh and Path.
        /if (${UseNavOnly} ) {
            /if (${PullMoveUse.NotEqual[nav]} || !${Navigation.MeshLoaded}) {
                /echo I can't Track Down ${WhoToChase}. Navigation not loaded or bad Mesh.
                /return
            } else {
                /if (${Navigation.PathExists[id ${Spawn[pc ${WhoToChase}].ID}]}==FASLE)
                /echo I can't Track Down ${WhoToChase}. No Valid Path too destination.
                /return
            }
        }
        /varset ChaseAssist 2
        /varset ReturnToCamp 0
        /varset ChaseDistance 20
        /if (${IgnoreDistance}) /varset CampRadiusExceed 100000
        /if (${Me.Casting.ID}) /stopcast
        | Go chase them down.
        /call DoWeChase TrackMeDown
        | Set things back
        /if (${tmdReturnToCamp}) {
            /varset CampXLoc ${Me.X}
            /varset CampYLoc ${Me.Y}
            /varset CampZLoc ${Me.FloorZ}
            /varset LookForward ${Me.Heading.DegreesCCW}
            /echo >> New camp set ${Me.Y}, ${Me.X}
        }
        /if (${StickOff}) {
            /if (${Stick.Active}) /squelch /stick off
        }
        /varset ChaseAssist ${tmdChaseAssist}
        /varset ReturnToCamp ${tmdReturnToCamp}
        /varset ChaseDistance ${tmdChaseDistance}
        /varset CampRadiusExceed ${tmdCampRadiusExceed}
        /varset BindActive 0
        /if (${Debug}) /echo \atDEBUG Bind_TrackMeDown Leave \agLine#: ${Macro.CurLine}
    /return

|-----------------------------------------------------------------------------
| SUB: SetPullAngle
| ----------------------------------------------------------------------------       
    Sub Bind_SetPullArc(float AWidth, string FDir)
        /declare DirDegree string local 0,45,90,135,180,225,270,315
        /declare FDirTemp  string local ${FDir}
        /if (!${AWidth}) {
            /if (${PullArcWidth}) {
                /echo Turning off Directional Pulling.
                /varset PullArcWidth 0
            }
            /return
        } else {
            /varset PullArcWidth ${AWidth}
        }
        /if (!${Bool[${FDir}]}) {
            /varset FDirTemp ${Me.Heading.Degrees}
        } else /if (${Float[${FDir}]}>0) {
            /varset FDirTemp ${FDir}
        } else {
            /varset FDirTemp ${DirDegree.Arg[${Select[${FDir},n,ne,e,se,s,sw,w,nw]},,]}.00
            /if (!${FDirTemp} && ${FDir.NotEqual[n]}) {
                /echo Invalid Direction. Turning off Directional Pulling.
                /varset PullArcWidth 0
                /return
            }
        }
        /call SetPullAngles ${Float[${FDirTemp}]} ${AWidth} 0
    /return
|-----------------------------------------------------------------------------
| SUB: SetPullAngles
| ----------------------------------------------------------------------------       
    Sub SetPullAngles(float FDir, float AWidth, int IgnoreMessage)
        /if (!${AWidth}) /return
        /if (!${FDir}) /varset FDir 0.00
        | Figure the Degrees for the left side
        /if (${Math.Calc[${FDir}-(${AWidth}*.5)]}<0) {
            /varcalc PullLSide 360-((${AWidth}*.5)-${FDir})
        } else {
            /varcalc PullLSide ${FDir}-(${AWidth}*.5)
        }
        |Figure the Degrees for the right side
        /if (${Math.Calc[${FDir}+(${AWidth}*.5)]}>360) {
            /varcalc PullRSide ((${AWidth}*.5)+${FDir}-360)
        } else {
            /varcalc PullRSide ${FDir}+(${AWidth}*.5)
        }
        |Store your current heading
        /varset PullHeading ${FDir}
        /if (!${IgnoreMessage}) /echo Setting Pull Angles. Facing: ${FDir} Left Side: ${PullLSide} Right Side: ${PullRSide} Width: ${AWidth}  
    /return
|-----------------------------------------------------------------------------
| SUB: FigureAngles
| ----------------------------------------------------------------------------       
    Sub FigureMobAngle(int aMobID)
        /if (!${aMobID}) /return 0
        /declare DirectionToMob float local 0
        /varset DirectionToMob ${Spawn[${aMobID}].HeadingTo[${CampYLoc},${CampXLoc}].Degrees}
        /if (${PullLSide}>=${PullRSide}) {
            /if (${DirectionToMob}<${PullLSide} && ${DirectionToMob}>${PullRSide}) /return 0
        } else {
            /if (${DirectionToMob}<${PullLSide} || ${DirectionToMob}>${PullRSide}) /return 0
        }
    /return 1
|-----------------------------------------------------------------------------
| SUB: AssignLooter
| ----------------------------------------------------------------------------       
    Sub AssignLooter
        /if (${Select[${Me},${Group.Leader}]}==0) /return
        /if (${LooterAssigned}) /return
        /if (${Group}<=0) /return
        /if (${Group.MasterLooter.ID}>=1) /return
        /if (${Debug}) /echo \atDEBUG Sub AssignLooter Enter \agLine#: ${Macro.CurLine}
        /declare k int local
        /declare IniIDList string local ${Ini[framework/${MacroName}_Buffs.ini]}
        /declare IniIDCount int local ${Math.Calc[${IniIDList.Count[|]}-1]}
        | If I am group leader set Main Looter Tag for Group
        /if (${Select[${Me},${Group.Leader}]}) { 
            /if (${Debug}) /echo \atDEBUG AssignLooter: /echo I am group Leader \agLine#: ${Macro.CurLine}
            |Assign myself as MainLooter if LootOn=1
            /if (${LootOn}) {
            /if (${Debug}) /echo \atDEBUG AssignLooter: /echo I am the looter \agLine#: ${Macro.CurLine}
                /if (${Group.MasterLooter.Name.NotEqual[${Me}]} && ${Group.MasterLooter.Name.Length}) {
                    /call AssignGroupRole unset "${Group.MasterLooter.Name}" 5
                    /delay 30 !${Group.MasterLooter.Name.Length}
                    /call AssignGroupRole set "${Group.MainAssist.Name}" 5
                    /call BroadCast ${EQBCOn} r "Assigning ${Me} as Master Looter in Group Window"
                    /varset LooterAssigned 1
                    /return
                }
            }
            /if (${LootOn}==0) {
                /if (${Debug}) /echo \atDEBUG AssignLooter: Looking for looter \agLine#: ${Macro.CurLine}
                /for k 1 to ${IniIDCount}
                    /if (${Debug}) /echo \atDEBUG AssignLooter: ${Spawn[${IniIDList.Arg[${k},|]}].ID} ${Ini[framework/${MacroName}_Buffs.ini,${IniIDList.Arg[${k},|]},"AmILooting"]}  ${Spawn[${IniIDList.Arg[${k},|]}].Type.NotEqual[pc]} ${Spawn[id ${IniIDList.Arg[${k},|]} group].ID} \agLine#: ${Macro.CurLine}
                    | If toon is not the zone or not a PC skip to next ID
                    /if (!${Spawn[id ${IniIDList.Arg[${k},|]}].ID} || ${Spawn[id ${IniIDList.Arg[${k},|]}].Type.NotEqual[pc]} || !${Ini[framework/${MacroName}_Buffs.ini,${IniIDList.Arg[${k},|]},"AmILooting"]}) /goto :NextLooterCheck
                    /if (${Spawn[id ${IniIDList.Arg[${k},|]} pc group].ID}) {
                        | If Looter is someone else than who its suppose to be unset Group tag
                        /if (${Group.MasterLooter.Name.Length} && ${Group.MasterLooter.Name.NotEqual[${Spawn[id ${IniIDList.Arg[${k},|]} group pc].CleanName}]}) /call AssignGroupRole unset "${Group.MasterLooter.Name}" 5
                        /delay 30 !${Group.MasterLooter.Name.Length}
                        /call AssignGroupRole set "${Spawn[id ${IniIDList.Arg[${k},|]} group pc].CleanName}" 5
                        /call BroadCast ${EQBCOn} r "LOOT: Assigning ${Spawn[id ${IniIDList.Arg[${k},|]} group pc].CleanName} as Master Looter in Group Window"
                        /varset LooterAssigned 1
                        /return
                    }
                :NextLooterCheck
                /next k
            }
        }
        /if (${Debug}) /echo \atDEBUG Sub AssignLooter Leave \agLine#: ${Macro.CurLine}
    /return    
| ----------------------------------------------------------------------------
| SUB: GmailParse
| ----------------------------------------------------------------------------
    Sub GmailIniParse
        /if (${Debug}) /echo \atDEBUGBUFFS GmailSend Enter \agLine#: ${Macro.CurLine}
        /declare i int local 0
        /declare GMailEventCheck string local
        /for i 1 to ${GMail.Size}
            /varset GMailEventCheck ${Ini[${IniFileName},Gmail,Gmail${i}]}
            /if (${GMailEventCheck.Length} && ${GMailEventCheck.NotEqual[null]}) {
                /if (${Select[${GMailEventCheck},Dead,Drag,GM,Level,Named,Leftgroup,Tells]}) {
                     /if (${Debug}) /echo \atDEBUGBUFFS /echo ${i}. ${GMailEventCheck}
                    /if (${GMailEvents.Length}) {
                        /varset GMailEvents ${GMailEvents},${GMailEventCheck}
                    } else {
                        /varset GMailEvents ${GMailEventCheck}
                    }
                }
            }
        /next i
        /if (${Debug}) /echo \atDEBUGBUFFS GmailSend Leave \agLine#: ${Macro.CurLine}
    /return
| ----------------------------------------------------------------------------
| SUB: GmailSend
| ----------------------------------------------------------------------------
    Sub GmailSend(GMessage)
        /if (${Debug}) /echo \atDEBUGBUFFS GmailSend Enter \agLine#: ${Macro.CurLine}
        |Goofy time shit because Gmail fails if any entry has a colon : in it. 
        /declare GTime string local 
        /declare GtimeHour string local ${Time.Hour}
        /declare AMPM string local am
        /if (${Time.Hour}>=13) {
            /varset GtimeHour ${Int[${Math.Calc[${Time.Hour}-12]}]}
            /varset AMPM pm
        }    
        /varset GTime Date.${Time.Date} Time.${GtimeHour}.${Time.Minute} ${AMPM}
        | Ghetto fix for buffer overflow until MQ2GMail is fixed
        /if (${Bool[${Plugin[MQ2Gmail]}]}) /squelch /plugin MQ2Gmail unload noauto
        /squelch /plugin MQ2Gmail noauto
        /gmail "Kiss-${EverQuest.Server}-${Me}" "${GTime} - ${GMessage}"
        /echo GMAIL just sent "Kiss-${EverQuest.Server}-${Me}" "${GTime} - ${GMessage}"
        /varcalc GSent ${GSent}+1
        /if (${GSent}==5) {
            /varset GSent 0
        }
        /delay 10
        /if (${Debug}) /echo \atDEBUGBUFFS GmailSend Leave \agLine#: ${Macro.CurLine}
    /return    

| ----------------------------------------------------------------------------
| SUB: LoadSpellSet
| ----------------------------------------------------------------------------
    Sub LoadSpellSet
        /if (${Debug}) /echo \atDEBUGBUFFS LoadSpellSet Enter \agLine#: ${Macro.CurLine}   
        /declare GemNum      int local
        /declare ValidSpells int local 0
            
        /if (${Debug}) /echo \atDEBUG Sub LoadSpellSet LoadSpellSet=(${LoadSpellSet}) \agLine#: ${Macro.CurLine}
        /if (${LoadSpellSet}==1) {
            /if (${Debug}) /echo \atDEBUG Sub LoadSpellSet SpellSetName=(${SpellSetName}) \agLine#: ${Macro.CurLine}
            /echo Memming spellset (${SpellSetName}).
            /memspellset ${SpellSetName}    
        } else {       
            |---Test to see if we have MySpells section defined in INI or not.
            /for GemNum 1 to 13
                /call LoadIni MySpells Gem${GemNum} string NULL
                /if (${Gem${GemNum}.Length} && ${Gem${GemNum}.NotEqual[NULL]}) {
                    |-- We have found a good spell defined, one good spell is all it takes to be a valid MySpells config.
                    /varset ValidSpells 1
                }
            /next GemNum 
            /if (${LoadSpellSet}==2 && ${ValidSpells}==0) /echo You have no valid spells defined in your ini file [MySpells], load your spells now and do a /writespells command while in KissAsssist.
            /if (${LoadSpellSet}==2 && ${ValidSpells}==1) /call Bind_MemMySpells ${Me.CleanName}
        }
        |-- If we called this routine, make sure we update values for ReMemMiscSpell and ReMemMiscSpellLW since they might have changed after spellset load.
        /varset ReMemMiscSpell ${Me.Gem[${MiscGem}].Name}
        /varset ReMemMiscSpellLW ${Me.Gem[${MiscGemLW}].Name}
        /if (${Debug}) /echo \atDEBUGBUFFS LoadSpellSet Leave \agLine#: ${Macro.CurLine} 
    /return    
| ----------------------------------------------------------------------------
| SUB: Set Window Title Buffs
| ----------------------------------------------------------------------------    
    Sub WinTitle
        /if (${Debug}) /echo \atDEBUGBUFFS WinTitle Enter \agLine#: ${Macro.CurLine} 
        /SetWinTitle ${Me.Name} (Lvl:${Me.Level} ${Zone.ShortName})
        /if (${Debug}) /echo \atDEBUGBUFFS WinTitle Leave \agLine#: ${Macro.CurLine} 
    /return    
| ----------------------------------------------------------------------------
| SUB: Set Xtargets to Heal
| ----------------------------------------------------------------------------    
    Sub SetXTargetHealList(string HealList)
        /if (!${XTarHeal} && ${HealList.Equal[null]}) /return
        /declare n int local 0
        /if (${HealList.Equal[all]}) {
            /for GlobalIndex 1 to ${XSlotTotal}
                /if (${Me.XTarget[${GlobalIndex}].TargetType.Equal[Auto Hater]}) {
                    /echo XTarget ${GlobalIndex} is assigned as Auto Hater. You may want to fix this when using the ALL tag.
                } else {
                    /varcalc n ${n}+1
                    /varset XTarToHeal[${n}] ${GlobalIndex}
                }
            /next GlobalIndex
            /if (${n} && ${n}<${XSlotTotal}) {
                /varcalc n ${n}+1
                /for GlobalIndex ${n} to ${XSlotTotal}
                    /varset XTarToHeal[${GlobalIndex}] 0
                /next GlobalIndex
            }
        } else /if (${HealList.Equal[auto]}) {
            /for GlobalIndex 1 to ${XSlotTotal}
                /if (${Me.XTarget[${GlobalIndex}].TargetType.Equal[Auto Hater]}) {
                    /continue
                } else {
                    /varcalc n ${n}+1
                    /varset XTarToHeal[${n}] ${GlobalIndex}
                }
            /next GlobalIndex
            /if (${n} && ${n}<${XSlotTotal}) {
                /varcalc n ${n}+1
                /for GlobalIndex ${n} to ${XSlotTotal}
                    /varset XTarToHeal[${GlobalIndex}] 0
                /next GlobalIndex
            }
        } else {
            /varset n 1
            /varset GlobalIndex 1
            /if (${HealList.Find[|]}) {
                /while (${GlobalIndex}<${XSlotTotal}) {
                    /if (${DebugFramework}) /Echo Current Line ${Macro.CurLine}
					/if (${Int[${HealList.Arg[${GlobalIndex},|]}]}>0 && ${Int[${HealList.Arg[${GlobalIndex},|]}]}<=${XSlotTotal}) {
                        /varset XTarToHeal[${n}] ${Int[${HealList.Arg[${GlobalIndex},|]}]}
                        /if (${Me.XTarget[${XTarToHeal[${n}]}].TargetType.Equal[Auto Hater]}) /echo XTarget ${XTarToHeal[${n}]} is assigned as Auto Hater. You may want to fix this.
                        /varcalc n ${n}+1
                        /varcalc GlobalIndex ${GlobalIndex}+1
                    } else /if (${Int[${HealList.Arg[${GlobalIndex},|]}]}==0) {
                        /varset XTarToHeal[${n}] 0
                        /varcalc GlobalIndex ${XSlotTotal}+1
                    } else {
                        /varcalc GlobalIndex ${GlobalIndex}+1
                    }
                }
            } else {
                /varset XTarToHeal[1] ${Int[${HealList}]}
            }
        }
    /return
| ----------------------------------------------------------------------------
| SUB: Grab Corpse
| ----------------------------------------------------------------------------
    Sub GrabCorpse 
        /if (${Debug}) /echo \atDEBUG GrabCorpse Enter \agLine#: ${Macro.CurLine}  
        /declare i int local
        /declare CorpseFarthest int local 0
        /declare CorpseFarthestTemp int local 0 
        /if (${SpawnCount[pccorpse ${Me} radius ${MaxRadius}]} && ${Me.AltAbilityReady[Summon Remains]}) {
            /target ${Me}
            /delay 10
            /call CastWhat "Summon Remains" ${Me} GrabCorpse 0
            /delay 30 
            /return
        }     
        /if (${SpawnCount[pccorpse ${Me} radius 89]} && !${DragCorpse}) {
            /corpsedrag
            /varset DragCorpse 1
            /echo Hey I found my corpse. Running back to camp for a rez
            /varset Pulled 1
            /if (${GMailEvents.Find[drag]}) /call GmailSend "Hey I found my corpse. Running back to camp for a rez!"
        }
        /if (${Debug}) /echo \atDEBUG GrabCorpse Leave \agLine#: ${Macro.CurLine}
    /return 
| ----------------------------------------------------------------------------
| SUB: DoCastingEvents 
| ---------------------------------------------------------------------------- 
    Sub DoCastingEvents(int CastTimer)
        /if (${DebugCast}) /echo \atDEBUGCAST DoCastingEvents \awEnter \agLine#: ${Macro.CurLine}   
        |/declare CastCalcTimer timer local 2
		/declare CastCalcTimer timer local 1
        /if (${CastTimer}) /varset CastCalcTimer ${CastTimer}
        /while (${CastCalcTimer}) {
            /if (${DebugFramework}) /Echo Current Line ${Macro.CurLine}
			/doevents CAST_BEGIN
            /doevents CAST_CANNOTSEE    
            /doevents CAST_COLLAPSE
            /doevents CAST_COMPONENTS
            /doevents CAST_DISTRACTED    
            /doevents CAST_FDFAIL    
            /doevents CAST_FIZZLE  
            /doevents CAST_IMMUNE
            /doevents CAST_INTERRUPTED
            /doevents CAST_NOMOUNT   
            /doevents CAST_NOTARGET
            /doevents CAST_NOTREADY
            /doevents CAST_OUTDOORS
            /doevents CAST_OUTOFMANA  
            /doevents CAST_OUTOFRANGE
            /doevents CAST_RECOVER    
            /doevents CAST_RESISTED    
            /doevents CAST_RESISTEDYOU    
            /doevents CAST_STANDING 
            /doevents CAST_STUNNED
            /doevents CAST_TAKEHOLD    
            /if (${DPSMeter}) /doevent YouHit
        }
        /if (${DebugCast}) /echo \atDEBUGCAST DoCastingEvents \awLeave \agLine#: ${Macro.CurLine}  
    /return
| ---------------------------------------------------------------------------- 
| SUB: Event_CAST_BEGIN 
| ---------------------------------------------------------------------------- 
    Sub Event_CAST_BEGIN(line,CBItem)
        /if (${DebugCast}) /echo \atDEBUGCAST Event_CAST_BEGIN \awEnter \agLine#: ${Macro.CurLine}
        /if (${DebugCast}) /echo \atDEBUGCAST Event_CAST_BEGIN \aw${line} \agLine#: ${Macro.CurLine}
        /varset castReturn CAST_SUCCESS
        /if (${DebugCast}) /echo \atDEBUGCAST Event_CAST_BEGIN \awLeave \agLine#: ${Macro.CurLine}
    /return
| ---------------------------------------------------------------------------- 
| SUB: Event_CAST_CANNOTSEE
| ---------------------------------------------------------------------------- 
    Sub Event_CAST_CANNOTSEE
        /if (${DebugCast}) /echo \atDEBUGCAST Event_CAST_CANNOTSEE \awEnter \agLine#: ${Macro.CurLine}
        /varset castReturn CAST_CANNOTSEE
        /if (${DebugCast}) /echo \atDEBUGCAST Event_CAST_CANNOTSEE \awLeave \agLine#: ${Macro.CurLine}
    /return    
| ---------------------------------------------------------------------------- 
| SUB: Event_CAST_COLLAPSE
| ---------------------------------------------------------------------------- 
    Sub Event_CAST_COLLAPSE
        /if (${DebugCast}) /echo \atDEBUGCAST Event_CAST_COLLAPSE \awEnter \agLine#: ${Macro.CurLine}
        /varset castReturn CAST_COLLAPSE
        /if (${DebugCast}) /echo \atDEBUGCAST Event_CAST_COLLAPSE \awLeave \agLine#: ${Macro.CurLine}
    /return
| ---------------------------------------------------------------------------- 
| SUB: Event_CAST_COMPONENTS
| ---------------------------------------------------------------------------- 
    Sub Event_CAST_COMPONENTS
        /if (${DebugCast}) /echo \atDEBUGCAST Event_CAST_COMPONENTS \awEnter \agLine#: ${Macro.CurLine}
        /varset castReturn CAST_COMPONENTS
        /doevents flush
        /if (${DebugCast}) /echo \atDEBUGCAST Event_CAST_COMPONENTS \awLeave \agLine#: ${Macro.CurLine}
    /return    
| ---------------------------------------------------------------------------- 
| SUB: Event_CAST_DISTRACTED
| ---------------------------------------------------------------------------- 
    Sub Event_CAST_DISTRACTED
        /if (${DebugCast}) /echo \atDEBUGCAST Event_CAST_DISTRACTED \awEnter \agLine#: ${Macro.CurLine}
        /varset castReturn CAST_DISTRACTED
        /if (${DebugCast}) /echo \atDEBUGCAST Event_CAST_DISTRACTED \awLeave \agLine#: ${Macro.CurLine}
    /return    
| ---------------------------------------------------------------------------- 
| SUB: Event_CAST_FDFAIL
| ---------------------------------------------------------------------------- 
    Sub Event_CAST_FDFAIL(line,name)
        /if (${DebugCast}) /echo \atDEBUGCAST Event_CAST_FDFAIL \awEnter \agLine#: ${Macro.CurLine}
        /if (${name.Equal[${Me.Name}]} && ${Defined[castReturn]}) {
            /if (${Me.Sitting}) /stand
            /varset castReturn CAST_RESTART
        }
        /if (${DebugCast}) /echo \atDEBUGCAST Event_CAST_FDFAIL \awLeave \agLine#: ${Macro.CurLine}
    /return
| ---------------------------------------------------------------------------- 
| SUB: Event_CAST_FIZZLE
| ---------------------------------------------------------------------------- 
    Sub Event_CAST_FIZZLE
        /if (${DebugCast}) /echo \atDEBUGCAST Event_CAST_FIZZLE \awEnter \agLine#: ${Macro.CurLine}
        /varset castReturn CAST_FIZZLE
        /if (${IAmABard}) /call DoBardStuff 
        /if (${DebugCast}) /echo \atDEBUGCAST Event_CAST_FIZZLE \awLeave \agLine#: ${Macro.CurLine}
    /return
| ---------------------------------------------------------------------------- 
| SUB: Event_CAST_IMMUNE
| ---------------------------------------------------------------------------- 
    Sub Event_CAST_IMMUNE(line,name)
        /if (${DebugCast}) /echo \atDEBUGCAST Event_CAST_IMMUNE \awEnter \agLine#: ${Macro.CurLine}
        /if (${DebugCast}) /echo \atDEBUGCAST Event_CAST_IMMUNE \aw${line} \agLine#: ${Macro.CurLine}
        | /echo  \aw${line}
        /varset castReturn CAST_IMMUNE
        /if (${DebugCast}) /echo \atDEBUGCAST Event_CAST_IMMUNE \awLeave \agLine#: ${Macro.CurLine}
    /return
| ---------------------------------------------------------------------------- 
| SUB: Event_CAST_INTERRUPT
| ---------------------------------------------------------------------------- 
    Sub Event_CAST_INTERRUPTED
        /if (${DebugCast}) /echo \atDEBUGCAST Event_CAST_INTERRUPT \awEnter \agLine#: ${Macro.CurLine}
        /varset castReturn CAST_INTERRUPTED
        /if (${DebugCast}) /echo \atDEBUGCAST Event_CAST_INTERRUPT \awLeave \agLine#: ${Macro.CurLine}
    /return
| ---------------------------------------------------------------------------- 
| SUB: Event_CAST_NOMOUNT
| ---------------------------------------------------------------------------- 
    Sub Event_CAST_NOMOUNT
        /if (${DebugCast}) /echo \atDEBUGCAST Event_CAST_NOMOUNT \awEnter \agLine#: ${Macro.CurLine}
        /varset castReturn CAST_NOMOUNT
        /if (${DebugCast}) /echo \atDEBUGCAST Event_CAST_NOMOUNT \awLeave \agLine#: ${Macro.CurLine}
    /return
| ---------------------------------------------------------------------------- 
| SUB: Event_CAST_NOTARGET
| ---------------------------------------------------------------------------- 
    Sub Event_CAST_NOTARGET
        /if (${DebugCast}) /echo \atDEBUGCAST Event_CAST_NOTARGET \awEnter \agLine#: ${Macro.CurLine}
        /varset castReturn CAST_NOTARGET
        /if (${DebugCast}) /echo \atDEBUGCAST Event_CAST_NOTARGET \awLeave \agLine#: ${Macro.CurLine}
    /return
| ---------------------------------------------------------------------------- 
| SUB: Event_CAST_NOTREADY
| ---------------------------------------------------------------------------- 
    Sub Event_CAST_NOTREADY
        /if (${DebugCast}) /echo \atDEBUGCAST Event_CAST_NOTREADY \awEnter \agLine#: ${Macro.CurLine}
        /varset castReturn CAST_NOTREADY
        /if (${DebugCast}) /echo \atDEBUGCAST Event_CAST_NOTREADY \awLeave \agLine#: ${Macro.CurLine}
    /return
| ---------------------------------------------------------------------------- 
| SUB: Event_CAST_OUTDOORS
| ---------------------------------------------------------------------------- 
    Sub Event_CAST_OUTDOORS
        /if (${DebugCast}) /echo \atDEBUGCAST Event_CAST_OUTDOORS \awEnter \agLine#: ${Macro.CurLine}
        /varset castReturn CAST_OUTOFMANA
        /if (${DebugCast}) /echo \atDEBUGCAST Event_CAST_OUTDOORS \awLeave \agLine#: ${Macro.CurLine}
    /return    
| ---------------------------------------------------------------------------- 
| SUB: Event_CAST_OUTOFMANA
| ---------------------------------------------------------------------------- 
    Sub Event_CAST_OUTOFMANA
        /if (${DebugCast}) /echo \atDEBUGCAST Event_CAST_OUTOFMANA \awEnter \agLine#: ${Macro.CurLine}
        /varset castReturn CAST_OUTOFMANA
        /if (${DebugCast}) /echo \atDEBUGCAST Event_CAST_OUTOFMANA \awLeave \agLine#: ${Macro.CurLine}
    /return
| ---------------------------------------------------------------------------- 
| SUB: Event_CAST_OUTOFRANGE
| ---------------------------------------------------------------------------- 
    Sub Event_CAST_OUTOFRANGE
        /if (${DebugCast}) /echo \atDEBUGCAST Event_CAST_OUTOFRANGE \awEnter \agLine#: ${Macro.CurLine}
        /varset castReturn CAST_OUTOFRANGE
        /if (${DebugCast}) /echo \atDEBUGCAST Event_CAST_OUTOFRANGE \awLeave \agLine#: ${Macro.CurLine}
    /return
| ---------------------------------------------------------------------------- 
| SUB: Event_CAST_RECOVER
| ---------------------------------------------------------------------------- 
    Sub Event_CAST_RECOVER
        /if (${DebugCast}) /echo \atDEBUGCAST Event_CAST_RECOVER \awEnter \agLine#: ${Macro.CurLine}
        /varset castReturn CAST_RECOVER
        /if (${DebugCast}) /echo \atDEBUGCAST Event_CAST_RECOVER \awLeave \agLine#: ${Macro.CurLine}
    /return
| ---------------------------------------------------------------------------- 
| SUB: Event_CAST_RESISTED
| ---------------------------------------------------------------------------- 
    Sub Event_CAST_RESISTED(line,name)
        /if (${DebugCast}) /echo \atDEBUGCAST Event_CAST_RESISTED \awEnter \agLine#: ${Macro.CurLine}
        /if (${DebugCast}) /echo \atDEBUGCAST Event_CAST_RESISTED \aw${line} \agLine#: ${Macro.CurLine}
        | /echo \aw${line} \ag
        /if (${castReturn.NotEqual[CAST_IMMUNE]}) /varset castReturn CAST_RESISTED
        /if (${DebugCast}) /echo \atDEBUGCAST Event_CAST_RESISTED \awLeave \agLine#: ${Macro.CurLine}
    /return
| ---------------------------------------------------------------------------- 
| SUB: Event_CAST_RESISTEDYOU
| ---------------------------------------------------------------------------- 
    Sub Event_CAST_RESISTEDYOU(line,name)
        /if (${DebugCast}) /echo \atDEBUGCAST Event_CAST_RESISTEDYOU \awEnter \agLine#: ${Macro.CurLine}
    
        /if (${DebugCast}) /echo \atDEBUGCAST Event_CAST_RESISTEDYOU \awLeave \agLine#: ${Macro.CurLine}
    /return
| ---------------------------------------------------------------------------- 
| SUB: Event_CAST_STANDING
| ---------------------------------------------------------------------------- 
    Sub Event_CAST_STANDING
        /if (${DebugCast}) /echo \atDEBUGCAST Event_CAST_STANDING \awEnter \agLine#: ${Macro.CurLine}
            /stand
        /varset castReturn CAST_RESTART
        /if (${DebugCast}) /echo \atDEBUGCAST Event_CAST_STANDING \awLeave \agLine#: ${Macro.CurLine}
    /return
| ---------------------------------------------------------------------------- 
| SUB: Event_CAST_STUNNED
| ---------------------------------------------------------------------------- 
    Sub Event_CAST_STUNNED
        /if (${DebugCast}) /echo \atDEBUGCAST Event_CAST_STUNNED \awEnter \agLine#: ${Macro.CurLine}
        /if (${Me.Stunned}) {
            /delay 3s !${Me.Stunned}
        } else {
            /delay 7
        }
        /varset castReturn CAST_STUNNED
        /if (${DebugCast}) /echo \atDEBUGCAST Event_CAST_STUNNED \awLeave \agLine#: ${Macro.CurLine}
    /return
| ---------------------------------------------------------------------------- 
| SUB: Event_CAST_TAKEHOLD
| ---------------------------------------------------------------------------- 
    Sub Event_CAST_TAKEHOLD
        /if (${DebugCast}) /echo \atDEBUGCAST Event_CAST_TAKEHOLD \awEnter \agLine#: ${Macro.CurLine}
        /varset castReturn CAST_TAKEHOLD
        /if (${DebugCast}) /echo \atDEBUGCAST Event_CAST_TAKEHOLD \awLeave \agLine#: ${Macro.CurLine}
    /return   
| ----------------------------------------------------------------------------
| SUB: Auto Load INI Entries
| ----------------------------------------------------------------------------
    Sub AutoLoad(string SectionName)
        /if (${SectionName.Equal[null]} || !${SectionName.Length}) /return
        /if (${Select[${SectionName},buffs,heals,dps]}==0) /return
        /echo AutoLoad INI - ${SectionName}
        /declare SpellLevel     int        local
        /declare SpellLevelChk  int        local
        /declare ka             int        local
        /declare kb             int        local
        /declare kc             int        local
        /declare kl             int        local
        /declare AutoLoadFile   string     local     AUTO${Me.Class.ShortName}.ini
        /declare SpellList      string     local
        /declare SpellName      string     local
        /declare SpellNameChk   string     local
        /declare VarArray       string     local
        /declare SpellTag       string     local
        /declare SpellTagL      string     local     null
        /if (${SectionName.Equal[buffs]}) {
            /varset VarArray Buffs
        } else /if (${SectionName.Equal[heals]}) {
            /varset VarArray Heals
        } else /if (${SectionName.Equal[dps]}) {
            /varset VarArray DPS
        } else {
            /echo Invalid Auto Array (${SectionName}) to check.
            /return
        }
        /varset ka 1
        /varset kc 0
        /while (1) {
            /if (${DebugFramework}) /Echo Current Line ${Macro.CurLine}
			/varset SpellList null
            /varset SpellLevel 0
            /varset SpellName null
            /if (${Ini[${AutoLoadFile},${SectionName},${VarArray}${ka}].Length}) {
                /varset SpellList ${Ini[${AutoLoadFile},${SectionName},${VarArray}${ka}]}
            }
            /if (${SpellList.NotEqual[null]}) {
                /varset kb 1
                /varset SpellTag null
                /if (!${SpellList.Find[,lowerlevel]}) {
                    /while (${Bool[${SpellList.Arg[${kb},,]}]}) {
                        /if (${DebugFramework}) /Echo Current Line ${Macro.CurLine}
						/varset SpellNameChk ${SpellList.Arg[${kb},,].Lower}
                        /if (${SpellNameChk.Left[4].NotEqual[tag:]}) { 
                            /varset SpellLevelChk ${Int[${Spell[${SpellNameChk}].Level}]}
                            /if (${SpellLevelChk}<=${Me.Level} && ${SpellLevel}<${SpellLevelChk}) {
                                | No ${FindItem[=${SpellNameChk}].ID} yet, For like Mounts and stuff. Will have to figure out later.
                                /if (${Me.Book[${SpellNameChk}]} || ${Me.AltAbility[${SpellNameChk}]} || ${Me.CombatAbility[${SpellNameChk}]} || ${Me.Ability[${SpellNameChk}]}) {
                                    /varset SpellLevel ${SpellLevelChk}
                                    /varset SpellName ${SpellNameChk}
                                    /varset kl ${kb}
                                }
                            }
                        } else {
                            /varset SpellTag ${SpellNameChk.Replace[tag:,]}
                            /varset SpellTagL null
                        }
                        /varcalc kb ${kb}+1
                    }
                } else {
                    /if (${kl}>1) {
                        /varcalc kl ${kl}-1
                        /varset SpellName ${SpellList.Arg[${kl},,].Lower}
                        /varset SpellLevel ${Int[${Spell[${SpellName}].Level}]}
                        /if (${SpellTagL.NotEqual[null]}) /varset SpellTag ${SpellTagL}
                    }
                }
                /if (${SpellName.NotEqual[null]} && ${SpellLevel}>0) {
                    /varcalc kc ${kc}+1
                    /if (${SpellTag.NotEqual[null]}) {
                        /varset SpellTagL ${SpellTag}
                        /varset SpellName ${SpellName}|${SpellTag}
                    } else {
                        /varset SpellTagL null
                    }
                    /ini "${IniFileName}" "${SectionName}" "${VarArray}${kc}" "${SpellName}"
                }
            } else {
                /break
            }
            /varcalc ka ${ka}+1
        }
    /return
| ----------------------------------------------------------------------------
| SUB: Write Buffs 
| ----------------------------------------------------------------------------
    Sub KissConditons    
        /call LoadIni KConditions ConOn               int         0
        /call LoadIni KConditions CondSize            int         5
        /declare Cond[${CondSize}]                  string      outer
        /call LoadIni KConditions Cond              string      TRUE      Cond
    /return    
| ----------------------------------------------------------------------------
| SUB: Write Buffs 
| ----------------------------------------------------------------------------
    Sub WriteBuffs
        /if (${WriteBuffsTimer} || !${Redguides} || ${AggroTargetID}) /return
        /if (${DebugBuffs}) /echo \atDEBUGBUFFS WriteBuffs Enter \agLine#: ${Macro.CurLine}
        /declare i int local 0
        /declare k int local 0
        /declare Blockedbuff string local
        /declare Blockedbufflist string local
        /declare BuffList string local
        /declare Writebufflist string local
        | Set block buffs count to 29 on emu servers and 39 on live
        /if (${MacroQuest.Build}==4) {
            /varset BlockedBuffsCount 29
        } else {
            /varset BlockedBuffsCount 39
        }    
        /call CleanBuffsFile
        | Write day of the month and hour. Entry will be deleted if more than a hour old
        /if (!${Ini[framework/${MacroName}_Buffs.ini,${Me.ID},Day].Length}) /ini framework/${MacroName}_Buffs.ini "${Me.ID}" Day "${Time.Day}"
        /if (!${Ini[framework/${MacroName}_Buffs.ini,${Me.ID},Hour].Length}) /ini framework/${MacroName}_Buffs.ini "${Me.ID}" Hour "${Time.Hour}"
        /if (!${Ini[framework/${MacroName}_Buffs.ini,${Me.ID},Zone].Length}) /ini framework/${MacroName}_Buffs.ini "${Me.ID}" Zone "${Zone.ID}"
        /if (!${Ini[framework/${MacroName}_Buffs.ini,${Me.ID},Buffs].Length}) /ini framework/${MacroName}_Buffs.ini "${Me.ID}" Buffs
        /if (!${Ini[framework/${MacroName}_Buffs.ini,${Me.ID},Blockedbuffs].Length}) /ini framework/${MacroName}_Buffs.ini "${Me.ID}" Blockedbuffs
        /ini framework/${MacroName}_Buffs.ini "${Me.ID}" AmILooting ${LootOn}
        /ini framework/${MacroName}_Buffs.ini "${Me.ID}" MyRole ${Role}
        | Write all current buffs to Kissassist_Buffs.ini file
        /for i 0 to 40
            /if (${Window[BuffWindow].Child[BW_Buff${i}_Button].Child[Buff${i}].Tooltip.Find[(]}) {
                /varset BuffList ${Window[BuffWindow].Child[BW_Buff${i}_Button].Child[Buff${i}].Tooltip.Arg[1,(].Left[-1]}
            } else {
                /varset BuffList ${Window[BuffWindow].Child[BW_Buff${i}_Button].Child[Buff${i}].Tooltip}
            } 
            /if (${BuffList.Length}) {
                /if (${Debug}) /echo \atDEBUG WriteBuffs: ${i}-${BuffList} \agLine#: ${Macro.CurLine}
                /if (${BuffList.Find[:Permanent]}>1) /varset BuffList ${BuffList.Left[${Math.Calc[${BuffList.Find[:Permanent]}-1]}]}
                /varset Writebufflist ${Writebufflist}|${BuffList}
            }
        /next i
        /ini framework/${MacroName}_Buffs.ini "${Me.ID}" Buffs "${Writebufflist}"
        /delay 15
        | Open Blocked Buffs window temporarily to read blocked buffs
        /if (!${Window[BlockedBuffWnd].Open} && !${BBWindowOpen}) {
            /windowstate BlockedBuffWnd open
            /varset BBWindowOpen 120m
            /delay 10
        } 
        | Write all blocked buffs to Kissassist_Buffs.ini file
        /for k 0 to ${BlockedBuffsCount}
            /varset Blockedbuff ${Window[BlockedBuffWnd].Child[BW_BLOCKEDBUFF${k}_Button].Child[BBuff${k}].Tooltip}
            /if (${Blockedbuff.Length}) {
                /varset Blockedbufflist ${Blockedbufflist}|${Blockedbuff}
            }
        /next k
        /if (${Blockedbufflist.Length}) /ini framework/${MacroName}_Buffs.ini "${Me.ID}" Blockedbuffs "${Blockedbufflist}"
        /if (${Window[BlockedBuffWnd].Open}) /windowstate BlockedBuffWnd close
        /varset WriteBuffsTimer 30s
        /if (${DebugBuffs}) /echo \atDEBUGBUFFS WriteBuffs Leave \agLine#: ${Macro.CurLine}
    /return
| -------------------------------------------------------------------------------------
| SUB: CheckCastMana
| -------------------------------------------------------------------------------------      
    Sub CheckCastMana(string SentFrom)
        /declare i int local

        /for i 1 to ${Buffs.Size}
            /if (${Buffs[${i}].Find[|0]} || ${Buffs[${i}].Equal[null]}) /continue
            /if (${Select[${Buffs[${i}].Arg[2,|]},mana,managroup]}==0) /continue
            /if (${Select[${Buffs[${i}].Arg[2,|]},mana,managroup]}==1) /varset checkmana 1
        /next i
/return
